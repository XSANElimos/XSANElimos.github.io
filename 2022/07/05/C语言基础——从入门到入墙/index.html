<!DOCTYPE html>


<html lang="cn">
  

    <head>
      <meta charset="utf-8" />
       
      <meta name="keywords" content="Elimos" />
       
      <meta name="description" content="嗷嗷这里是Elimos的小站" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>C语言基础——从入门到入墙 |  Elimos&#39;Home</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
      <canvas width="1777" height="841"
        style="position: fixed; left: 0px; top: 0px; z-index: 99999; pointer-events: none;"></canvas>
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-C语言基础——从入门到入墙"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  C语言基础——从入门到入墙
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/07/05/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%A2%99/" class="article-date">
  <time datetime="2022-07-05T08:51:34.000Z" itemprop="datePublished">2022-07-05</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Tutorial/">Tutorial</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> Word count:</span>
            <span class="post-count">11.7k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> Reading time≈</span>
            <span class="post-count">43 min</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h1><p>C语言作为一切学习的起点，要多回来复习复习哟</p>
<span id="more"></span>

<h1 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h1><h2 id="计算机存储单位-从小到大"><a href="#计算机存储单位-从小到大" class="headerlink" title="计算机存储单位(从小到大)"></a>计算机存储单位(从小到大)</h2><p>1bit（比特位）= 1位二进制(0或1)</p>
<p>1B（Byte字节）=8bit</p>
<p>1KB (Kilobyte 千字节)=1024B，</p>
<p>1MB (Mega byte 兆字节 简称“兆”)=1024KB，</p>
<p>1GB（Giga byte 吉字节 又称“千兆”)=1024MB，</p>
<p>1TB（Tera byte 万亿字节 太字节)=1024GB，其中1024=2^10 ( 2 的10次方)，</p>
<h2 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h2><p>计算机中存储数据的方式</p>
<ul>
<li><strong>大端序</strong></li>
</ul>
<blockquote>
<p>数据的高字节存放到低地址，低字节存放到高地址</p>
</blockquote>
<ul>
<li><strong>小端序</strong></li>
</ul>
<blockquote>
<p>数据的高字节存放到高地址，低字节存放到低地址</p>
</blockquote>
<h2 id="内存区域划分"><a href="#内存区域划分" class="headerlink" title="内存区域划分"></a>内存区域划分</h2><ul>
<li>堆空间</li>
</ul>
<blockquote>
<p>只有使用malloc,calloc,realloc这三个函数申请的空间才是堆空间，容量很大，使用完后需要使用free主动释放</p>
</blockquote>
<ul>
<li>栈空间</li>
</ul>
<blockquote>
<p>局部变量，函数调用都是要使用栈空间，先进后出，栈空间容量大概只有8M</p>
</blockquote>
<ul>
<li><p>数据段</p>
<ul>
<li>.bss 未初始化的静态变量(全局变量和static修饰的变量)</li>
<li>.data  初始化的静态变量(全局变量和static修饰的变量)</li>
<li>.rodata 常量 const修饰的常量</li>
</ul>
</li>
<li><p>代码段</p>
<ul>
<li>.text 程序员写的代码段</li>
<li>.init 汇编启动代码</li>
</ul>
</li>
</ul>
<h2 id="进制之间的转换，进制加减法"><a href="#进制之间的转换，进制加减法" class="headerlink" title="进制之间的转换，进制加减法"></a>进制之间的转换，进制加减法</h2><ul>
<li>短除法</li>
</ul>
<hr>
<h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>辅助别人看懂你的代码</p>
<h2 id="两种注释类型"><a href="#两种注释类型" class="headerlink" title="两种注释类型"></a>两种注释类型</h2><h3 id="单行注释"><a href="#单行注释" class="headerlink" title="单行注释"></a>单行注释</h3><ul>
<li>一次只可以注释掉一行代码，注释的代码是不参与编译的</li>
<li>用//表示单行注释</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一个行注释</span></span><br></pre></td></tr></table></figure>

<h3 id="块注释"><a href="#块注释" class="headerlink" title="块注释"></a>块注释</h3><ul>
<li>一次注释掉多行</li>
<li>用<code>/*CONTENT*/</code>表示块注释</li>
<li>块注释不可以嵌套块注释使用</li>
<li>块注释里面可以嵌套使用行注释</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这是一个块注释</span></span><br><span class="line"><span class="comment">// 这是一个块注释中嵌套的行注释</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">*/</span> <span class="comment">//这样使得后面的那一个*/失效</span></span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><ul>
<li>用来存储数据</li>
<li>变量实际上就是一块可以用来存储可变(类型可变，内容可变)的值的一块内存区域</li>
</ul>
<h2 id="定义-definition-和声明-declaration-变量"><a href="#定义-definition-和声明-declaration-变量" class="headerlink" title="定义(definition)和声明(declaration)变量"></a>定义(definition)和声明(declaration)变量</h2><h3 id="定义声明"><a href="#定义声明" class="headerlink" title="定义声明"></a>定义声明</h3><p><strong><code>[变量类型] &#123;变量名&#125;</code></strong></p>
<p>会分配内存的声明，有几种写法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义声明演示</span></span><br><span class="line"><span class="type">short</span> a;    <span class="comment">//定义一个short类型的变量,变量名为a,但是该变量没有初始化赋值</span></span><br><span class="line"></span><br><span class="line"><span class="type">short</span> a=<span class="number">89</span>; <span class="comment">//定义变量a，立马初始化为89</span></span><br><span class="line"></span><br><span class="line"><span class="type">short</span> a;    <span class="comment">//定义变量a</span></span><br><span class="line">a=<span class="number">78</span>;       <span class="comment">//在使用之前初始化为78</span></span><br><span class="line"></span><br><span class="line"><span class="type">short</span> a,b,c,d;  <span class="comment">//同时定义了四个变量,都是short类型,都没有初始化赋值</span></span><br><span class="line"></span><br><span class="line"><span class="type">short</span> a,b=<span class="number">89</span>,c,d=<span class="number">56</span>; <span class="comment">// 同时定义了四个short类型变量，部分变量初始化</span></span><br></pre></td></tr></table></figure>

<h3 id="普通声明"><a href="#普通声明" class="headerlink" title="普通声明"></a>普通声明</h3><p><strong><code>extern [变量类型] &#123;变量名&#125;</code></strong></p>
<p>仅声明，不会分配内存 如<code>extern int a[];</code></p>
<h3 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h3><ul>
<li><strong>变量名只能由字母，数字和下划线组成，不能包含其它特殊符号</strong></li>
<li><strong>变量名不可以跟C语言的关键字同名</strong></li>
<li><strong>首字符不可以是数字</strong></li>
<li>变量取名字通俗易懂，不要用拼音，用英文单词(行业潜规则)</li>
<li>大驼峰法：类名，函数名(通用)，属性名，命名空间</li>
<li>小驼峰：变量，函数名(Java系)</li>
</ul>
<hr>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h2><table>
<thead>
<tr>
<th>关键字</th>
<th>类型名</th>
<th>占用字节(Byte)</th>
</tr>
</thead>
<tbody><tr>
<td>short</td>
<td>短整型</td>
<td>2</td>
</tr>
<tr>
<td>int</td>
<td>整型</td>
<td>4</td>
</tr>
<tr>
<td>long</td>
<td>长整型</td>
<td>8(x64) / 4(x32)</td>
</tr>
<tr>
<td>long long</td>
<td>长长整型</td>
<td>8</td>
</tr>
<tr>
<td>unsigned short</td>
<td>无符号的短整型</td>
<td>2</td>
</tr>
<tr>
<td>unsigned int</td>
<td>无符号的整型</td>
<td>4</td>
</tr>
<tr>
<td>unsigned long</td>
<td>无符号的长整型</td>
<td>8(x64) / 4(x32)</td>
</tr>
<tr>
<td>unsigned long long</td>
<td>无符号的长长整型</td>
<td>8</td>
</tr>
</tbody></table>
<h2 id="整数在计算机中的存储方式"><a href="#整数在计算机中的存储方式" class="headerlink" title="整数在计算机中的存储方式"></a>整数在计算机中的存储方式</h2><p>最高位是符号位，用0表示正数，用1表示负数</p>
<ul>
<li>正数：在计算机中采用原码存储的</li>
<li>负数：在计算机中采用补码存储的</li>
<li>原码：指的是一个数原本的二进制</li>
<li>反码：原码全部取反</li>
<li>补码：反码加1得到补码</li>
</ul>
<h2 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h2><p>char类型表示字符，单引号表示单个字符</p>
<blockquote>
<p>char可以用ASCII码以整数的形式进行输出，这是因为键盘上的每一个字符都在ascii表中</p>
</blockquote>
<p>常用的ASCII码：</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>ASCII码值</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>65</td>
</tr>
<tr>
<td>a</td>
<td>97</td>
</tr>
<tr>
<td>‘0’</td>
<td>48</td>
</tr>
</tbody></table>
<p>查看ASCII码表:<code>man ascii</code></p>
<p><img src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F736fcfd5-972a-4d01-a871-7405c931f90a%2FUntitled.png?table=block&id=b18e6a4b-f4e0-4023-bb35-1dabeaa07422&spaceId=a06190ac-c5a8-4c56-b3ed-a0be13119ca5&width=2000&userId=9d2af0ed-9fc9-4b46-840a-8a61cda676c0&cache=v2" alt="ascii1"></p>
<p><img src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fce200f2b-055f-417b-b838-52e7b18e925b%2FUntitled.png?table=block&id=091e3d66-4222-4ebd-a78d-065b0e12d860&spaceId=a06190ac-c5a8-4c56-b3ed-a0be13119ca5&width=2000&userId=9d2af0ed-9fc9-4b46-840a-8a61cda676c0&cache=v2" alt="ascii2"></p>
<p><strong>char字符越界</strong></p>
<p>char类型数据本身占8位二进制，数据超出范围以后，计算机会把高位的去掉，保留低位</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符数据越界演示</span></span><br><span class="line"><span class="type">char</span> a=<span class="number">300</span>;      <span class="comment">// 字符数据越界</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a);  <span class="comment">// 结果:44</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> a=<span class="number">417</span>;      <span class="comment">// 字符数据越界</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a);  <span class="comment">// 结果:-95</span></span><br></pre></td></tr></table></figure>

<h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2><p>当计算机接收到一个浮点数常量时，计算机默认其数据类型为double</p>
<table>
<thead>
<tr>
<th>关键字</th>
<th>类型名</th>
<th>占用字节(Bte)</th>
</tr>
</thead>
<tbody><tr>
<td>float</td>
<td>单精度浮点型</td>
<td>4</td>
</tr>
<tr>
<td>double</td>
<td>双精度浮点型</td>
<td>8</td>
</tr>
</tbody></table>
<h3 id="浮点数在计算机中的存储方式"><a href="#浮点数在计算机中的存储方式" class="headerlink" title="浮点数在计算机中的存储方式"></a>浮点数在计算机中的存储方式</h3><ol>
<li>先求出整数部分的二进制(除2取余)</li>
<li>再来求出小数部分的二进制(乘2取整)</li>
<li>规格化存储</li>
</ol>
<blockquote>
<p>有些小数是无法精准表示：如12.56<br>有些小数是可以精准表示：如12.5</p>
</blockquote>
<h2 id="指针类型"><a href="#指针类型" class="headerlink" title="指针类型"></a>指针类型</h2><blockquote>
<p>在不同的处理器中指针长度不一，但在相同处理器中所有类型的指针长度都是一致的</p>
</blockquote>
<p>指针就是一个固定长度的地址变量，存放的数据类型是十六进制地址</p>
<h2 id="BOOL类型"><a href="#BOOL类型" class="headerlink" title="BOOL类型"></a>BOOL类型</h2><blockquote>
<p>在C99 中引入了_Bool类型 如果要使用bool的<code>true</code>与<code>false</code>, 则需要<code>#include &lt;stdbool.h&gt;</code></p>
</blockquote>
<ul>
<li>只要不是0，全部都是真(TRUE)的</li>
<li>只要是0，就是假(FALSE)的</li>
</ul>
<h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><p>枚举的本质就是整型常量</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><strong><code>enum 枚举名&#123;枚举值&#125;;</code></strong></p>
<ul>
<li>没有赋值符</li>
<li>枚举值不指定时，默认从0开始</li>
<li>枚举值不可以是整型</li>
</ul>
<h2 id="复合数据类型"><a href="#复合数据类型" class="headerlink" title="复合数据类型"></a>复合数据类型</h2><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>结构体中包含多种数据类型，可以处理复杂数据结构情况</p>
<h3 id="共用体"><a href="#共用体" class="headerlink" title="共用体"></a>共用体</h3><p>共用体中所有元素公用一块内存区域，共用体大小取决于其中最大的元素的大小，一般应用于互斥变量</p>
<h2 id="数据表示方式"><a href="#数据表示方式" class="headerlink" title="数据表示方式"></a>数据表示方式</h2><h3 id="格式控制符"><a href="#格式控制符" class="headerlink" title="格式控制符"></a>格式控制符</h3><table>
<thead>
<tr>
<th>格式控制符</th>
<th>释义</th>
</tr>
</thead>
<tbody><tr>
<td>%d</td>
<td>打印有符号整数的十进制</td>
</tr>
<tr>
<td>%i</td>
<td>输出:打印整数十进制      输入:接收八、十六进制</td>
</tr>
<tr>
<td>%ld</td>
<td>打印长整型</td>
</tr>
<tr>
<td>%lld</td>
<td>打印长整型</td>
</tr>
<tr>
<td>%hd</td>
<td>打印短整型</td>
</tr>
<tr>
<td>%c</td>
<td>打印字符的字面值</td>
</tr>
<tr>
<td>%u</td>
<td>把整数当成无符号数来计算然后打印</td>
</tr>
<tr>
<td>%lu</td>
<td>打印无符号长整型</td>
</tr>
<tr>
<td>%x</td>
<td>打印整数的十六进制</td>
</tr>
<tr>
<td>%#X</td>
<td>打印带0x的大写十六进制</td>
</tr>
<tr>
<td>%o</td>
<td>打印八进制</td>
</tr>
<tr>
<td>%#o</td>
<td>打印带0的八进制</td>
</tr>
<tr>
<td>%s</td>
<td>打印字符串</td>
</tr>
<tr>
<td>%p</td>
<td>打印地址值(首地址)，打印指针</td>
</tr>
<tr>
<td>%f</td>
<td>打印float (%.3f 保留小数点后3位)</td>
</tr>
<tr>
<td>%lf</td>
<td>打印double</td>
</tr>
</tbody></table>
<h3 id="位宽"><a href="#位宽" class="headerlink" title="位宽"></a>位宽</h3><p>打印输出变量值的时候，可以设置打印的位宽(打印出来的变量占用的位置宽度)</p>
<ul>
<li>正数位宽：在数据的左边补充空格，凑够你需要的位宽</li>
<li>负数位宽：在数据的右边补充空格，凑够你需要的位宽</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 位宽演示</span></span><br><span class="line"><span class="type">int</span> num = <span class="number">404</span>;  </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%-10d%d&quot;</span>,num,num); <span class="comment">//404       404 </span></span><br><span class="line"><span class="comment">// 中间间隔7个空格</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%2d&quot;</span>,num); <span class="comment">//404</span></span><br><span class="line"><span class="comment">// 设置2个位宽，位宽设置小了不起任何作用</span></span><br></pre></td></tr></table></figure>

<h3 id="小数位数"><a href="#小数位数" class="headerlink" title="小数位数"></a>小数位数</h3><ul>
<li>%f，%lf打印小数，默认是保留小数点后面6个有效数字</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 小数位数演示</span></span><br><span class="line">%<span class="number">-15.9f</span>   <span class="number">15</span>表示<span class="number">15</span>个位宽，<span class="number">9</span>表示小数点后面保留<span class="number">9</span>个数字</span><br></pre></td></tr></table></figure>

<h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><p>用<code>\</code>把一些特殊的字符转变含义</p>
<ul>
<li>\181  \7A  把8进制或16进制数转换成10进制</li>
<li>\x 把十六进制数转为十进制</li>
</ul>
<h3 id="进制表示-UnDone"><a href="#进制表示-UnDone" class="headerlink" title="进制表示[!UnDone]"></a>进制表示[!UnDone]</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 进制表示</span></span><br><span class="line"><span class="type">int</span> b = <span class="number">4&#x27;b</span>0111;  <span class="comment">//二进制</span></span><br><span class="line"><span class="type">int</span> n = <span class="number">123</span>;     <span class="comment">//十进制</span></span><br><span class="line"><span class="type">int</span> m = <span class="number">0123</span>;    <span class="comment">//八进制</span></span><br><span class="line"><span class="type">int</span> k = <span class="number">0x123</span>;   <span class="comment">//十六进制</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="格式化输入输出"><a href="#格式化输入输出" class="headerlink" title="格式化输入输出"></a>格式化输入输出</h1><h2 id="输入SCANF"><a href="#输入SCANF" class="headerlink" title="输入SCANF"></a>输入SCANF</h2><p><strong><code>scanf(&quot;格式控制符&quot;,变量的地址);</code></strong></p>
<p>scanf只会严格按照格式控制符进行读取，从键盘上读取到的输入会进入到缓冲区中，然后根据格式化控制符从IO缓冲区中读取合适的字符串后转换成对应的数据类型</p>
<p><code>int getchar(void)</code></p>
<ul>
<li>从缓冲区中一次读取一个字符</li>
<li>返回从缓冲区中读取到的字符的ASCII码值</li>
</ul>
<h2 id="输出PRINTF"><a href="#输出PRINTF" class="headerlink" title="输出PRINTF"></a>输出PRINTF</h2><p><strong><code>printf(&quot;格式控制符&quot;,变量的名字);</code></strong></p>
<p>printf会把存放在IO缓冲区中的内容在屏幕上显示出来</p>
<h2 id="IO缓冲区"><a href="#IO缓冲区" class="headerlink" title="IO缓冲区"></a>IO缓冲区</h2><p>有三种情况会自动刷新缓冲区（即输出缓冲区内容）</p>
<ol>
<li>return/exit/程序结束</li>
<li>缓冲区满</li>
<li>\n</li>
</ol>
<h3 id="清空标准IO缓冲区"><a href="#清空标准IO缓冲区" class="headerlink" title="清空标准IO缓冲区"></a>清空标准IO缓冲区</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(getchar() !=<span class="string">&#x27;\n&#x27;</span>);</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p><code>+</code>  算术加</p>
<p><code>-</code>  算术减</p>
<p><code>*</code>  算术乘</p>
<p><code>/</code>  算术除</p>
<p><code>%</code>  算术余(只能对整数求余)</p>
<h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p><code>||</code> 逻辑或</p>
<blockquote>
<p>可以理解为算术加 只要有1个1即为1</p>
</blockquote>
<ul>
<li>运算规则:从左到右依次判断每个表达式的值是否为真，如果有一个表达式为真，后面的表达式不参与计算，整个表达式全部为真</li>
</ul>
<p><code>&amp;&amp;</code> 逻辑与</p>
<blockquote>
<p>可以理解位算术乘 只要有1个0即为0</p>
</blockquote>
<ul>
<li>运算规则:从左到右依次判断每个表达式的值是否为真，如果有一个表达式为假，后面的表达式不参与计算，整个表达式全部为假</li>
</ul>
<p><code>!</code>  逻辑反</p>
<blockquote>
<p>取反 有1变0 有0变1</p>
</blockquote>
<h3 id="逻辑运算符混合运算"><a href="#逻辑运算符混合运算" class="headerlink" title="逻辑运算符混合运算"></a>逻辑运算符混合运算</h3><blockquote>
<p>由于&amp;&amp;优先级高，所以先用括号把&amp;&amp;括起来作为一个整体，其它部分(其它部门都是逻辑或)按照从左到右</p>
</blockquote>
<ul>
<li>条件1||条件2&amp;&amp;条件3||条件4</li>
</ul>
<p>例如：if((a&gt;b)||(a=a+10)&amp;&amp;(b=b-a)||(a-b&lt;3))<br>整体看成逻辑或，从左到右计算，中间的条件2和条件3看成整体</p>
<ul>
<li>条件1&amp;&amp;条件2||条件3||条件4</li>
</ul>
<p>例如：if((a&gt;b)&amp;&amp;(a=a+10)||(b=b-a)||(a-b&lt;3))<br>整体看成逻辑或，从左到右计算，前面的条件1和条件2看成整体</p>
<ul>
<li>条件1||条件2||条件3&amp;&amp;条件4</li>
</ul>
<p>if((a&gt;b)||(a=a+10)||(b=b-a)&amp;&amp;(a-b&lt;3))</p>
<h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><p><code>&gt;</code>   关系大于</p>
<p><code>&lt;</code>   关系小于</p>
<p><code>==</code>  关系等于</p>
<p><code>!=</code>  关系不等</p>
<p><code>&gt;=</code>  关系大于等于</p>
<p><code>&lt;=</code>  关系小于等于</p>
<h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p><code>=</code> 赋值运算符</p>
<h3 id="左值"><a href="#左值" class="headerlink" title="左值"></a>左值</h3><p>赋值运算左边的那个式子，就叫做左值</p>
<ul>
<li>左值只能是变量名，不可以是表达式，不可以是常量</li>
</ul>
<h3 id="右值"><a href="#右值" class="headerlink" title="右值"></a>右值</h3><p>赋值运算右边的那个式子，叫做右值</p>
<ul>
<li>右值可以是任何合法的C语言表达式</li>
</ul>
<h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><p><code>~</code> 按位逻辑取反</p>
<blockquote>
<p>有1则0 有0则1</p>
</blockquote>
<p><code>&amp;</code> 按位逻辑与</p>
<blockquote>
<p>全1则1 有0则0</p>
</blockquote>
<ul>
<li>任何二进制跟1按位与，结果保持不变</li>
<li>任何二进制跟0按位与，结果一定是0</li>
</ul>
<p><code>|</code> 按位逻辑或</p>
<blockquote>
<p>有1则1 全0则0</p>
</blockquote>
<ul>
<li>任何二进制跟0按位或，结果保持不变</li>
<li>任何二进制跟1按位或，结果一定是1</li>
</ul>
<p><code>^</code> 按位逻辑异或</p>
<blockquote>
<p>异则1 同则0</p>
</blockquote>
<ul>
<li>任何一个数跟自己异或，结果是0</li>
<li>任何一个数跟1异或，结果是把这个数最低的二进制反转</li>
<li>任何一个数跟0异或，结果保持不变</li>
</ul>
<blockquote>
<p>求异或后取反可以表示<code>逻辑同或</code></p>
</blockquote>
<h2 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h2><p><code>? :</code></p>
<blockquote>
<p>表达式1?表达式2:表达式3</p>
</blockquote>
<ul>
<li>表达式1为真返回表达式2</li>
<li>表达式1为假返回表达式3</li>
</ul>
<h2 id="其它运算符"><a href="#其它运算符" class="headerlink" title="其它运算符"></a>其它运算符</h2><p><code>++</code> 自增</p>
<p>前置自增</p>
<blockquote>
<p><code>++a;</code>先把a的值加1，然后使用加1之后的结果</p>
</blockquote>
<p>后置自增</p>
<blockquote>
<p><code>a++;</code>，先使用a原本的值，然后再把a加1</p>
</blockquote>
<p><code>--</code> 自减</p>
<p>前置自减</p>
<blockquote>
<p><code>--a;</code>先把a的值减1，然后使用减1之后的结果</p>
</blockquote>
<p>后置自减</p>
<blockquote>
<p><code>a--;</code>，先使用a原本的值，然后再把a减1</p>
</blockquote>
<p><code>,</code>  逗号表达式</p>
<p><code>变量=(表达式1,表达式2,表达式3...);</code></p>
<blockquote>
<p>从左到右计算，最后的结果由最右边的表达式来决定</p>
</blockquote>
<p><code>+=</code> <code>-=</code> <code>*=</code> <code>/=</code> <code>%=</code> <code>&lt;&lt;=</code> <code>&gt;&gt;=</code> <code>&amp;=</code> <code>|=</code> <code>^=</code> 组合运算符</p>
<blockquote>
<p><code>a += b;</code> 等价于 <code>a = a + b;</code></p>
</blockquote>
<p><code>sizeof</code> 取变量类型大小</p>
<blockquote>
<p>sizeof括号内的表达式不会执行，sizeof只会去取表达式结果的类型</p>
</blockquote>
<ul>
<li>如<code>sizeof(i++);</code>执行后i值不变</li>
</ul>
<p><code>&lt;&lt;</code> 左移</p>
<blockquote>
<p>把一个整数的二进制向左边移动若干位(舍弃高位)，低位补0</p>
</blockquote>
<p><code>&gt;&gt;</code> 右移</p>
<blockquote>
<p>不同的操作系统采用不同的右移方式</p>
</blockquote>
<ul>
<li>逻辑右移:把一个整数的二进制向右边移动若干位(舍弃低位),高位补0</li>
<li>算术右移:把一个整数的二进制向右边移动若干位(舍弃低位),高位补符号位的拷贝</li>
</ul>
<p><code>.</code> <code>-&gt;</code> 成员运算符</p>
<p><code>&amp;</code> 取地址 </p>
<blockquote>
<p>获取变量在内存中的地址</p>
</blockquote>
<p><code>*</code> 解引用</p>
<blockquote>
<p>获取地址中保存的内容</p>
</blockquote>
<h2 id="运算符的优先级-UnDone"><a href="#运算符的优先级-UnDone" class="headerlink" title="运算符的优先级[!UnDone]"></a>运算符的优先级[!UnDone]</h2><hr>
<h1 id="程序控制关键字"><a href="#程序控制关键字" class="headerlink" title="程序控制关键字"></a>程序控制关键字</h1><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><blockquote>
<p>循环内的变量都属于静态局部变量，循环外不可使用，循环内的定义不会导致重复定义</p>
</blockquote>
<h3 id="FOR循环"><a href="#FOR循环" class="headerlink" title="FOR循环"></a>FOR循环</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(表达式<span class="number">1</span>; 表达式<span class="number">2</span>; 表达式<span class="number">3</span>) <span class="comment">// 循环控制 表达式分别都可以省略</span></span><br><span class="line">&#123;</span><br><span class="line">		<span class="comment">// 循环体代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>先执行表达式1</li>
<li>再判断表达式2是否成立</li>
</ol>
<ul>
<li>表达式2成立：执行花括号里面的代码，然后执行表达式3，继续判断表达式2</li>
<li>表达式2不成立：结束循环</li>
</ul>
<h3 id="WHILE循环"><a href="#WHILE循环" class="headerlink" title="WHILE循环"></a>WHILE循环</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(条件表达式)  <span class="comment">//循环控制</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 循环体代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>条件为真，则执行循环，循环完成一轮后重新判断条件是否成立，若为假退出循环</li>
</ul>
<h3 id="DOWHILE循环"><a href="#DOWHILE循环" class="headerlink" title="DOWHILE循环"></a>DOWHILE循环</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 循环体代码块</span></span><br><span class="line">&#125;<span class="keyword">while</span>(条件表达式);</span><br></pre></td></tr></table></figure>

<ul>
<li>循环一定会至少执行一次</li>
<li>条件为真，则继续执行循环，循环完成一轮后重新判断条件是否成立，若为假退出循环</li>
</ul>
<h3 id="循环控制关键字"><a href="#循环控制关键字" class="headerlink" title="循环控制关键字"></a>循环控制关键字</h3><ul>
<li><code>break</code>   提前彻底结束循环</li>
<li><code>continue</code>  结束本次循环，继续后面的循环</li>
</ul>
<h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><h3 id="if-else-if-else多分支"><a href="#if-else-if-else多分支" class="headerlink" title="if-else if-else多分支"></a>if-else if-else多分支</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件判断式)&#123;</span><br><span class="line">		<span class="comment">//分支1</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(条件判断式<span class="number">2</span>)&#123;</span><br><span class="line">		<span class="comment">//分支2</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="comment">//分支3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>分支只有的一句话的时候可以省略花括号</li>
<li>else永远和距离最近的if配对</li>
<li>关键字与花括号之间不能有除空格或回车以外的其他字符</li>
</ul>
<h3 id="选择分支"><a href="#选择分支" class="headerlink" title="选择分支"></a>选择分支</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(变量)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">         <span class="comment">// 分支1</span></span><br><span class="line">         <span class="keyword">break</span>;     <span class="comment">// 结束case语句</span></span><br><span class="line">   <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">         <span class="comment">// 分支2  继续往下执行</span></span><br><span class="line">   <span class="keyword">default</span>: <span class="comment">// 不符合case列举除的情况则执行</span></span><br><span class="line">         <span class="comment">// 分支3</span></span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>switch-case中的变量，只能是整数，字符，枚举这些类型</li>
<li>default与break都是可选项，default可以随意调整位置</li>
<li>case中的分支可以用花括号包裹，如果在case中定义新变量则必须使用花括号包裹</li>
</ul>
<h3 id="三目分支"><a href="#三目分支" class="headerlink" title="?:三目分支"></a>?:三目分支</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">条件判断式 ? 分支<span class="number">1</span> : 分支<span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<h3 id="跳转分支"><a href="#跳转分支" class="headerlink" title="跳转分支"></a>跳转分支</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LabelName:</span><br><span class="line">	<span class="comment">// 语句</span></span><br><span class="line">	<span class="keyword">goto</span> LabelName; </span><br></pre></td></tr></table></figure>

<ul>
<li>标签下不可以定义新的变量(重复定义)</li>
<li>goto只能在同一个函数内部跳转</li>
</ul>
<hr>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>当需要保存一定数量的相同类型的数据时，就需要用到数组</p>
<blockquote>
<p>任何合法的C语言类型，都可以定义成数组</p>
</blockquote>
<h2 id="数组定义"><a href="#数组定义" class="headerlink" title="数组定义"></a>数组定义</h2><p><strong><code>[数据类型] &#123;数组名&#125;[数组元素个数]</code></strong></p>
<blockquote>
<p><code>数组名</code>出现在表达式中，本身就是一个指针, 一个指向本数组首元素地址的指针<br><code>&amp;数组名</code> 表示的是指向整个数组的一个指针(数组指针)</p>
</blockquote>
<h2 id="数组初始化以及赋值"><a href="#数组初始化以及赋值" class="headerlink" title="数组初始化以及赋值"></a>数组初始化以及赋值</h2><ul>
<li><strong>完全初始化</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">5</span>]=&#123;<span class="number">45</span>,<span class="number">85</span>,<span class="number">74</span>,<span class="number">96</span>,<span class="number">63</span>&#125;;  </span><br><span class="line"><span class="type">char</span> b[<span class="number">10</span>]=<span class="string">&quot;hello&quot;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>部分初始化</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">5</span>]=&#123;<span class="number">45</span>,<span class="number">25</span>&#125;;              </span><br><span class="line"><span class="type">char</span> b[<span class="number">10</span>]=&#123;<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span>&#125;; <span class="comment">// &#x27;h&#x27; 表示单个字符</span></span><br><span class="line"><span class="type">char</span> s[<span class="number">20</span>]=&#123;<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;h&#x27;</span>,<span class="number">0</span>&#125;  <span class="comment">// \0的ASCII码就是0 &#123;0&#125;即等价于&#123;’\0’&#125; </span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>其它没有初始化的都是0</p>
</blockquote>
<ul>
<li><strong>自适应长度初始化</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[]=&#123;<span class="number">85</span>,<span class="number">96</span>&#125;;      </span><br><span class="line"><span class="type">char</span> b[]=<span class="string">&quot;world&quot;</span> <span class="comment">// &quot;world&quot; 表示字符串 多个字符</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>只能在定义数组的时候立马初始化才可行</p>
</blockquote>
<ul>
<li><strong>延迟赋值</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>];    <span class="comment">//定义了数组，但是没有初始化</span></span><br><span class="line">a[<span class="number">0</span>]=<span class="number">45</span>;     <span class="comment">//正确</span></span><br><span class="line">a[<span class="number">1</span>]=<span class="number">85</span>;     <span class="comment">//正确</span></span><br><span class="line">a[<span class="number">3</span>]=<span class="number">88</span>;     <span class="comment">//数组越界</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>分块初始化</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> b[<span class="number">100</span>] = &#123;[<span class="number">0</span> ... <span class="number">49</span>]=<span class="number">100</span>, [<span class="number">50</span> ... <span class="number">99</span>]=<span class="number">200</span>&#125;; </span><br><span class="line"><span class="comment">//把数组前面50个元素初始化为100，后面50个初始化为200</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>...</code> 左右两边必须要有空格</p>
</blockquote>
<h3 id="数组重复写入"><a href="#数组重复写入" class="headerlink" title="数组重复写入"></a>数组重复写入</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buf[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,buf);  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// buf的值 (0表示\0)</span></span><br><span class="line"><span class="comment">// abcdefg0 </span></span><br><span class="line"><span class="comment">// hijk0fg0</span></span><br><span class="line"><span class="comment">// lm0k0fg0</span></span><br></pre></td></tr></table></figure>

<h2 id="数组访问"><a href="#数组访问" class="headerlink" title="数组访问"></a>数组访问</h2><p>通过下标来对数组进行读或写</p>
<h3 id="数组指针访问"><a href="#数组指针访问" class="headerlink" title="数组指针访问"></a>数组指针访问</h3><p><code>*(p+n)</code> 等价于 <code>p[n]</code></p>
<blockquote>
<p>假如第一次输入的字符串长一点，下一次输入的字符串短一点，scanf都会自动帮你在字符串后面添加\0保存到buf中，短一点的字符串覆盖长字符串的前面部分，并且有个\0在后面(易忽略)</p>
</blockquote>
<h3 id="数组清空"><a href="#数组清空" class="headerlink" title="数组清空"></a>数组清空</h3><blockquote>
<p>若是在使用前不对数组进行清空，则有可能会有残留的不确定的值还存留在数组涵盖的范围内(如上所示)，导致程序运行时产生不确定的结果</p>
</blockquote>
<ul>
<li><code>void bzero(void *s, size_t n);</code></li>
</ul>
<p>s:数组名 n:数组大小</p>
<ul>
<li>初始化时利用 <code>int buf[10]=&#123;0&#125;;</code></li>
</ul>
<p>利用部分初始化把数组清零,-其它没有初始化的默认都是0</p>
<h3 id="数组越界"><a href="#数组越界" class="headerlink" title="数组越界"></a>数组越界</h3><p>数组的下标范围是从0到数组的长度-1，若是访问的时候下标不在该范围内，就会出现数组越界，有可能会导致段错误(Segmentation fault)，越界也分为往前越界和往后越界</p>
<h3 id="段错误"><a href="#段错误" class="headerlink" title="段错误"></a>段错误</h3><p>由于程序员在代码中访问了非法地址导致的(经常见于指针没有初始化，数组越界)</p>
<h3 id="数组怪异的写法"><a href="#数组怪异的写法" class="headerlink" title="数组怪异的写法"></a>数组怪异的写法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> buf[<span class="number">10</span>];</span><br><span class="line"><span class="number">0</span>[buf]=<span class="number">11</span>; <span class="comment">//等价于buf[0]=11; </span></span><br></pre></td></tr></table></figure>

<h3 id="数组取地址的写法-易混淆"><a href="#数组取地址的写法-易混淆" class="headerlink" title="数组取地址的写法(易混淆)"></a>数组取地址的写法(易混淆)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组 int a[10]</span></span><br><span class="line">a       <span class="comment">// int *类型的指针</span></span><br><span class="line">&amp;a      <span class="comment">// 数组指针  </span></span><br><span class="line">a[<span class="number">0</span>]    <span class="comment">// 非指针，数组首元素值</span></span><br><span class="line">&amp;a[<span class="number">0</span>]   <span class="comment">// 数组首元素的地址</span></span><br><span class="line">a+<span class="number">1</span>     <span class="comment">// 加类型的大小  4个字节(int)</span></span><br><span class="line">&amp;a+<span class="number">1</span>    <span class="comment">// 加的是整个数组的大小(10*4)</span></span><br><span class="line">a[<span class="number">0</span>]+<span class="number">1</span>  <span class="comment">// 把a[0]的值加1</span></span><br><span class="line">&amp;a[<span class="number">0</span>]+<span class="number">1</span> <span class="comment">// 加类型的大小  4个字节(int)</span></span><br></pre></td></tr></table></figure>

<h2 id="数组指针"><a href="#数组指针" class="headerlink" title="数组指针"></a>数组指针</h2><p>指向某个数组的指针</p>
<p> <code>**类型 (*指针名)[数组元素个数]**</code></p>
<h3 id="数组指针的定义"><a href="#数组指针的定义" class="headerlink" title="数组指针的定义"></a>数组指针的定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="type">char</span> b[<span class="number">15</span>];</span><br><span class="line"><span class="type">int</span> c[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> (*p)[<span class="number">10</span>]=&amp;a;    <span class="comment">//定义了 int[10]类型的数组指针，指向a</span></span><br><span class="line">p=&amp;c;               <span class="comment">//p又转而指向同类型，不同地址的c</span></span><br><span class="line"><span class="type">char</span> (*q)[<span class="number">15</span>]=&amp;b;   <span class="comment">//定义了 char[15]类型的数组指针，指向b</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>同类型的数组指针仍然可以直接赋值，反之不行</p>
</blockquote>
<h3 id="同数组的指针相减"><a href="#同数组的指针相减" class="headerlink" title="同数组的指针相减"></a>同数组的指针相减</h3><p>表示的是数组中两个指针之间间隔了多少个数据</p>
<h2 id="数组存储"><a href="#数组存储" class="headerlink" title="数组存储"></a>数组存储</h2><p>数组在计算机中是连续存储(数组元素的地址是紧挨着的)</p>
<h3 id="字符串存储"><a href="#字符串存储" class="headerlink" title="字符串存储"></a>字符串存储</h3><p>字符串默认有一个结束标记\0(ASCII码值就是0)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buf1[<span class="number">10</span>]=<span class="string">&quot;hello&quot;</span>; <span class="comment">//会自动在字符串的末尾添加\0</span></span><br><span class="line"><span class="type">char</span> buf2[<span class="number">5</span>]=<span class="string">&quot;hello&quot;</span>; <span class="comment">//没有空位自动添加\0</span></span><br><span class="line"><span class="type">char</span> buf[]=&#123;<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span>&#125;; <span class="comment">// 属于字符数组存储 sizeof结果为5,没有加\0</span></span><br><span class="line"><span class="type">char</span> buf[]=<span class="string">&quot;hello&quot;</span>  <span class="comment">// 属于字符串存储 sizeof结果为6，加上了\0</span></span><br></pre></td></tr></table></figure>

<h2 id="一维数组大小"><a href="#一维数组大小" class="headerlink" title="一维数组大小"></a>一维数组大小</h2><p><code>sizeof();</code></p>
<blockquote>
<p>求任何类型数据的大小的<strong>运算符</strong>，若是计算字符串的长度，则会算上\0</p>
</blockquote>
<p><code>size_t strlen(const char *s);</code></p>
<blockquote>
<p>专门(只能)用来求字符串的实际长度的<strong>函数</strong>，使用时需要导入<code>#include &lt;string.h&gt;</code></p>
</blockquote>
<p>返回值：字符串的实际长度(不包括\0)  s:要计算长度的字符串<br>原理：计算字符串实际长度，遇到\0认为字符串结束了</p>
<blockquote>
<p>%s打印字符串的时候，也是遇到\0就认为字符串结束了</p>
</blockquote>
<hr>
<h1 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h1><p>用二维的方式存放大量相同类型的数据</p>
<h2 id="二维数组定义"><a href="#二维数组定义" class="headerlink" title="二维数组定义"></a>二维数组定义</h2><p><strong><code>[数据类型] &#123;数组名&#125;[行数][列数]</code></strong></p>
<p>任何合法的C语言类型，都可以定义成二维数组</p>
<blockquote>
<p><code>二维数组名</code>在表达式中代表该数组首元素的地址 相当于一个指向本数组首元素地址的指针<br><code>&amp;二维数组名</code>表示的是指向整个数组的一个指针(数组指针)</p>
</blockquote>
<h2 id="二维数组初始化和赋值"><a href="#二维数组初始化和赋值" class="headerlink" title="二维数组初始化和赋值"></a>二维数组初始化和赋值</h2><ul>
<li><strong>部分初始化</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">5</span>][<span class="number">6</span>]=&#123;<span class="number">45</span>,<span class="number">78</span>,<span class="number">96</span>&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其它没有初始化的默认全部都是0</p>
</blockquote>
<ul>
<li><strong>自适应行数初始化</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[][<span class="number">6</span>]=&#123;<span class="number">89</span>,<span class="number">9</span>&#125;;                   <span class="comment">//正确</span></span><br><span class="line"><span class="type">char</span> b[][<span class="number">10</span>]=&#123;<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span>,<span class="string">&quot;gec&quot;</span>&#125;;<span class="comment">//正确</span></span><br><span class="line"><span class="type">int</span> a[][]=&#123;<span class="number">89</span>,<span class="number">9</span>&#125;;                    <span class="comment">//错误</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">5</span>][]=&#123;<span class="number">89</span>,<span class="number">9</span>&#125;;                   <span class="comment">//错误</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>不能自适应行列数是因为编译器无法正确确定行列排布方式，具有二义性</p>
</blockquote>
<ul>
<li><strong>分组初始化</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> b[<span class="number">3</span>][<span class="number">10</span>]=&#123;&#123;<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span>&#125;,&#123;<span class="string">&#x27;g&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&#125;&#125;   <span class="comment">//正确</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">5</span>][<span class="number">6</span>]=&#123;&#123;<span class="number">5</span>&#125;,<span class="number">8</span>,<span class="number">9</span>,&#123;<span class="number">89</span>,<span class="number">63</span>&#125;&#125;;                        <span class="comment">//错误</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>要求从左到右连续分组，中间不要间断</p>
</blockquote>
<ul>
<li><strong>单独初始化</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分别赋值</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">5</span>][<span class="number">6</span>];  </span><br><span class="line">a[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">99</span>;</span><br><span class="line">a[<span class="number">1</span>][<span class="number">2</span>]=<span class="number">67</span>;</span><br><span class="line"><span class="type">char</span> b[<span class="number">3</span>][<span class="number">10</span>];</span><br><span class="line">b[<span class="number">0</span>][<span class="number">1</span>]=<span class="string">&#x27;h&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="二维数组的访问"><a href="#二维数组的访问" class="headerlink" title="二维数组的访问"></a>二维数组的访问</h2><p>行和列的下标：都是从0开始,注意越界问题</p>
<h3 id="二维数组的指针访问"><a href="#二维数组的指针访问" class="headerlink" title="二维数组的指针访问"></a>二维数组的指针访问</h3><p><code>*(*(a+i)+j)</code>等价于 <code>*(a[i]+j)</code>等价于<code>a[i][j]</code></p>
<h2 id="二维数组的存储"><a href="#二维数组的存储" class="headerlink" title="二维数组的存储"></a>二维数组的存储</h2><p>二维数组在计算机中是连续存储(数组元素的地址是紧挨着的)</p>
<blockquote>
<p>可以把它看作是特殊的”一维数组”<br>可以把二维数组拆分成多个一维数组</p>
</blockquote>
<h2 id="二维数组占用空间大小"><a href="#二维数组占用空间大小" class="headerlink" title="二维数组占用空间大小"></a>二维数组占用空间大小</h2><p>依据初始化列表中值的个数 (行下标为空的情况下)，确定有几行,再通过 <strong>行<em>列</em>sizeof(类型)</strong> 确定大小</p>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p>字符串的本质就是<code>**char 字符串名[字符串长度]</code>** </p>
<p>各类字符串的操作函数都需要先引入<code>#include &lt;string.h&gt;</code></p>
<h2 id="复制、拷贝字符串"><a href="#复制、拷贝字符串" class="headerlink" title="复制、拷贝字符串"></a>复制、拷贝字符串</h2><p><code>char *strcpy(char *dest, const char *src);</code></p>
<blockquote>
<p>把src中的字符串拷贝一份到dest里</p>
</blockquote>
<ul>
<li>strcpy拷贝字符串会自动在后面加上\0(特别是src比dest要短的情况下)</li>
</ul>
<p><code>char *strncpy(char *dest, const char *src, size_t n);</code></p>
<blockquote>
<p>把src中的字符串拷贝一份到dest里面，拷贝n个字节</p>
</blockquote>
<ul>
<li>strncpy拷贝字符串的时候不会自动添加\0</li>
</ul>
<h2 id="字符串的比较"><a href="#字符串的比较" class="headerlink" title="字符串的比较"></a>字符串的比较</h2><blockquote>
<p>比较标准：按照两个字符串中字符的ASCII码排列顺序来比较</p>
</blockquote>
<p><code>int strcmp(const char *s1, const char *s2);</code></p>
<ul>
<li>参数：s1 s2就是你要比较的两个字符串</li>
</ul>
<p>返回值：</p>
<ul>
<li>s1大于s2  返回值&gt;0</li>
<li>s1小于s2  返回值&lt;0</li>
<li>s1等于s2  返回0</li>
</ul>
<p><code>int strncmp(const char *s1, const char *s2, size_t n);</code></p>
<ul>
<li>参数：比较s1和s2的最前面的n个字符是否相同</li>
</ul>
<h2 id="字符串合并，拼接"><a href="#字符串合并，拼接" class="headerlink" title="字符串合并，拼接"></a>字符串合并，拼接</h2><p><code>char *strcat(char *dest, const char *src);</code></p>
<ul>
<li>参数：把src合并到dest中，合并的结果存放到dest中</li>
</ul>
<p><code>char *strncat(char *dest, const char *src, size_t n);</code></p>
<blockquote>
<p>注意：dest总的大小必须要超过dest字符串+src字符串之和</p>
</blockquote>
<p><code>int sprintf(char *str, const char *format, ...);</code></p>
<ul>
<li>参数：str：保存拼接之后的字符串 format：格式控制字符串</li>
</ul>
<h2 id="字符串的切割"><a href="#字符串的切割" class="headerlink" title="字符串的切割"></a>字符串的切割</h2><p><code>char *strtok(char *str, const char *delim);</code></p>
<blockquote>
<p>底层原理:strtok会改变原始字符串，strtok会把原始字符串中遇到的切割符号替换成\0</p>
</blockquote>
<blockquote>
<p>第一次使用的时候str填原始字符串 之后使用时该参数为NULL</p>
</blockquote>
<ul>
<li>参数：str：你要切割的字符串  delim：切割的标准</li>
</ul>
<p>返回值：</p>
<ul>
<li>切割成功返回切割得到的子串</li>
<li>字符串切割完毕或者切割过程中发了错误，返回NULL</li>
</ul>
<h2 id="判断子串"><a href="#判断子串" class="headerlink" title="判断子串"></a>判断子串</h2><p><code>char *strchr(const char *s, int c);</code></p>
<ul>
<li>参数：s ：你要查找的字符串  c：你要找的字符</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回字符c首次在s中出现的位置</li>
<li>如果没有出现，返回NULL</li>
</ul>
<p><code>char *strstr(const char *haystack, const char *needle);</code></p>
<blockquote>
<p>实际用途：判断文件类型</p>
</blockquote>
<h2 id="二维数组名的写法-易混淆"><a href="#二维数组名的写法-易混淆" class="headerlink" title="二维数组名的写法(易混淆)"></a>二维数组名的写法(易混淆)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">a          <span class="comment">// 二维数组首元素的地址-&gt;  a[0]的地址,数组指针  int (*p)[10]</span></span><br><span class="line">&amp;a         <span class="comment">// 数组指针    int (*p)[7][10]  </span></span><br><span class="line">a[<span class="number">0</span>]       <span class="comment">// 第一个一维数组int[10]的名字，表示该数组首元素a[0][0]的地址  int *</span></span><br><span class="line">&amp;a[<span class="number">0</span>]      <span class="comment">// 数组指针    int (*p)[10]</span></span><br><span class="line">a[<span class="number">0</span>][<span class="number">0</span>]    <span class="comment">// 非指针</span></span><br><span class="line">&amp;a[<span class="number">0</span>][<span class="number">0</span>]   <span class="comment">// int *</span></span><br><span class="line">a+<span class="number">1</span>        <span class="comment">// 加类型的大小  int[10]大小</span></span><br><span class="line">&amp;a+<span class="number">1</span>       <span class="comment">// 加的是整个数组的大小,int[7][10]大小</span></span><br><span class="line">a[<span class="number">0</span>]+<span class="number">1</span>     <span class="comment">// 4个字节</span></span><br><span class="line">&amp;a[<span class="number">0</span>]+<span class="number">1</span>    <span class="comment">// 加类型的大小  int[10]大小</span></span><br><span class="line">a[<span class="number">0</span>][<span class="number">0</span>]+<span class="number">1</span>  <span class="comment">// 把数据加1</span></span><br><span class="line">&amp;a[<span class="number">0</span>][<span class="number">0</span>]+<span class="number">1</span> <span class="comment">// 4个字节</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><p>用来存放变量在内存中的地址首地址，使用指针可以间接访问地址中的变量值，指针的大小跟指针的类型没有任何关系，只跟操作系统的位数有关。在32位系统上，所有的指针大小都是4个字节，在64位系统上，所有的指针大小都是8个字节，指针是来存放变量在内存中的首地址的，而64位系统上所有的地址长度都是8个字节</p>
<blockquote>
<p>首地址:在一定地址范围中地址值最小的那个，就是该地址范围的首地址</p>
</blockquote>
<h2 id="指针定义"><a href="#指针定义" class="headerlink" title="指针定义"></a>指针定义</h2><p><strong><code>[数据类型] *指针名</code></strong></p>
<blockquote>
<p>指针本身也是一个变量，只是这个变量存储的是地址值</p>
</blockquote>
<h2 id="指针类型转换"><a href="#指针类型转换" class="headerlink" title="指针类型转换"></a>指针类型转换</h2><p><code>指针1=(指针类型)指针2</code></p>
<p>当两个指针类型不一致的时候又需要传值的时候，就需要强制转换</p>
<h2 id="指针初始化和赋值"><a href="#指针初始化和赋值" class="headerlink" title="指针初始化和赋值"></a>指针初始化和赋值</h2><ul>
<li><strong>立即初始化</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">99</span>;</span><br><span class="line"><span class="type">int</span> *p=&amp;a;  <span class="comment">//定义了指针p，p里面存放变量a在内存中地址</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>延迟初始化</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> b=<span class="number">77</span>;</span><br><span class="line"><span class="type">int</span> *q;  <span class="comment">// 定义了指针q</span></span><br><span class="line">q=&amp;b;    <span class="comment">// 指针q中存放变量b在内存的地址</span></span><br></pre></td></tr></table></figure>

<h3 id="通用指针"><a href="#通用指针" class="headerlink" title="通用指针"></a>通用指针</h3><p><code>void *</code>类型的指针，可以兼容任何其它类型的指针转换</p>
<h3 id="野指针"><a href="#野指针" class="headerlink" title="野指针"></a>野指针</h3><blockquote>
<p>定义了指针，但是指针没有明确的指向,这种指针就叫做野指针，解引用时会导致段错误</p>
</blockquote>
<h3 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h3><blockquote>
<p>在C语言中 NULL 和 0 指的都是空指针，C++11后专门加入了nullptr来表示空指针</p>
</blockquote>
<p>NULL表示的内存中的0x0000 0000</p>
<h2 id="指针的读写"><a href="#指针的读写" class="headerlink" title="指针的读写"></a>指针的读写</h2><p><strong>解引用和取地址互为逆运算</strong></p>
<ul>
<li>解引用：获取地址中保存的内容</li>
</ul>
<p><code>*指针</code></p>
<blockquote>
<p>用于指针访问或者修改变量的值</p>
</blockquote>
<ul>
<li>取地址：获取变量在内存中的地址</li>
</ul>
<h3 id="地址分配"><a href="#地址分配" class="headerlink" title="地址分配"></a>地址分配</h3><p>地址的分配和释放都需要导入<code>#include &lt;stdlib.h&gt;</code></p>
<p><code>void *malloc(size_t size);</code></p>
<blockquote>
<p>分配堆内存空间</p>
</blockquote>
<ul>
<li>参数：size：要分配的堆空间的大小(单位：字节)</li>
</ul>
<p>返回值：</p>
<ul>
<li>分配给你的堆空间的首地址</li>
</ul>
<p><code>void *calloc(size_t nmemb, size_t size);</code> </p>
<blockquote>
<p>申请分配nmemb块内存，每个的大小是size</p>
</blockquote>
<ul>
<li>参数：nmemb：申请的内存区域块数  size：申请的内存区域每一块的大小</li>
</ul>
<p>返回值：</p>
<ul>
<li>分配给你的堆空间的首地址</li>
</ul>
<p><code>void *realloc(void *ptr, size_t size);</code> </p>
<blockquote>
<p>重新分配堆内存</p>
</blockquote>
<ul>
<li>参数：ptr：要重新分配空间的堆空间的首地址 size：新的堆空间的大小</li>
</ul>
<p>返回值：</p>
<ul>
<li>分配给你的新的堆空间的首地址</li>
</ul>
<h3 id="地址释放"><a href="#地址释放" class="headerlink" title="地址释放"></a>地址释放</h3><p><code>void free(void *ptr);</code>  </p>
<blockquote>
<p>释放堆空间，<strong>申请的堆空间必须主动释放，操作系统不会帮你释放</strong></p>
</blockquote>
<ul>
<li>参数：ptr：之前申请过的堆空间首地址</li>
</ul>
<h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><p>一直申请堆内存，但是都没有释放，导致堆内存越来越少，最后没有可以使用的堆内存</p>
<h3 id="堆内碎块"><a href="#堆内碎块" class="headerlink" title="堆内碎块"></a>堆内碎块</h3><p>频繁地分配和释放不同大小的堆空间会导致堆内碎块</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *p = <span class="string">&quot;hello&quot;</span>; <span class="comment">// 指针指向字符串常量 常量无法修改</span></span><br><span class="line">*p = <span class="string">&#x27;k&#x27;</span>; <span class="comment">// 断错误</span></span><br><span class="line"><span class="type">char</span> str[<span class="number">10</span>] = [<span class="string">&quot;hello&quot;</span>];</span><br><span class="line"><span class="type">char</span> *p;</span><br><span class="line">p = str;  <span class="comment">// 指针指向变量 ，可以修改</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>( 一 ) char p=”String” 此”String” 为常量 ( 二 ) strcpy(*str,”String”)，此字符串是常量</p>
</blockquote>
<h2 id="指针的运算"><a href="#指针的运算" class="headerlink" title="指针的运算"></a>指针的运算</h2><p><code>+</code> 算术加</p>
<blockquote>
<p>用指针去加一个整数,指针做加法，加的是类型的大小</p>
</blockquote>
<p>一个指针加上另外一个指针没有任何实际意义</p>
<p><code>-</code>  算术减</p>
<blockquote>
<p>用指针去减一个整数,指针做减法，减的是类型的大小<br>结果：(指针1地址值-指针2地址值)/类型大小</p>
</blockquote>
<p>一个指针减去另外一个指针有实际意义(在数组中是有意义的)<br>一个指针减另外一个指针，结果不是地址值直接相减，而是两个指针之间相差的对应类型之间的位数<br><code>++</code> 自增</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*p++   <span class="comment">//先解引用p，然后p加1</span></span><br><span class="line">(*p)++ <span class="comment">//先解引用p，然后把解引用的值加1</span></span><br><span class="line">*++p   <span class="comment">//先将++用于p，然后解引用</span></span><br><span class="line">++*p   <span class="comment">//先解引用，然后把结果加1</span></span><br></pre></td></tr></table></figure>

<p><code>=</code> 关系判断</p>
<blockquote>
<p>比较两个指针是否相等</p>
</blockquote>
<h2 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h2><p>数组中存放的全部都是指针，这种数组就叫做指针数组</p>
<p><strong><code>指针类型 数组名[数组元素个数];</code></strong></p>
<h3 id="指针数组的定义"><a href="#指针数组的定义" class="headerlink" title="指针数组的定义"></a>指针数组的定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *a[<span class="number">3</span>];  <span class="comment">//3个int *</span></span><br><span class="line"><span class="type">char</span> *b[<span class="number">4</span>]; <span class="comment">//4个char *</span></span><br></pre></td></tr></table></figure>

<h2 id="二级指针"><a href="#二级指针" class="headerlink" title="二级指针"></a>二级指针</h2><p>二级指针也是指针，该指针用来存放一个一级指针在内存中的地址</p>
<p>二级指针解引用将变成对应的一级指针</p>
<h3 id="二级指针的运算"><a href="#二级指针的运算" class="headerlink" title="二级指针的运算"></a>二级指针的运算</h3><p>二级指针做加减法，加减的是指针(一级指针)的大小(64位系统加减8的倍数   32系统加减4的倍数)</p>
<h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>指向函数的入口地址的指针</p>
<blockquote>
<p>函数名就是个指针，函数名表示函数的入口地址</p>
</blockquote>
<h3 id="函数指针定义"><a href="#函数指针定义" class="headerlink" title="函数指针定义"></a>函数指针定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>;</span><br><span class="line"><span class="comment">//定义一个函数指针指向add</span></span><br><span class="line"><span class="type">int</span> (*p)(<span class="type">int</span>,<span class="type">int</span>)=add;</span><br><span class="line"><span class="type">int</span> *(*<span class="built_in">array</span>[<span class="number">10</span>])(<span class="type">int</span>) <span class="comment">// 定义一个数组,这个数组可以存放10个p类型的指针</span></span><br><span class="line"><span class="comment">//int *(*函数指针名字)(int)  -&gt; int *(*数组名[10])(int)</span></span><br></pre></td></tr></table></figure>

<h3 id="函数指针调用"><a href="#函数指针调用" class="headerlink" title="函数指针调用"></a>函数指针调用</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*p)(<span class="type">int</span>,<span class="type">int</span>)=&amp;add;</span><br><span class="line">(*p)(<span class="number">15</span>,<span class="number">16</span>);</span><br><span class="line">p(<span class="number">15</span>,<span class="number">16</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>函数指针的写法很特殊，add和&amp;add没有区别</p>
</blockquote>
<hr>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>将代码模块化，用来提升代码的复用率</p>
<p>函数封装原则上要”高内聚，低耦合”，高内聚就是把功能相关的模块集合在一起，低耦合就是每个模块之间的关联性降到可控范围的最低。</p>
<h2 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">返回值类型  函数名字(形参列表) <span class="comment">// 函数头</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>函数头</li>
</ul>
<blockquote>
<p>函数的属性描述，如<code>int add(int a,int b)</code>就是一个函数头</p>
</blockquote>
<ul>
<li>函数体：{}中包裹的代码块</li>
<li>返回值类型：调用函数后将会返回的结果</li>
<li>函数的声明(函数原型声明)</li>
</ul>
<blockquote>
<p>函数声明可以放在主函数的前面，也可以单独放去头文件中</p>
</blockquote>
<ul>
<li>函数的定义：函数头和函数体完整地放在一起就是函数的定义</li>
</ul>
<blockquote>
<p>函数可以定义在主函数前面，也可以先在主函数前声明后，定义在主函数后</p>
</blockquote>
<ul>
<li>形参：形式参数，函数声明中或者函数定义中圆括号里面的就是形参</li>
<li>实参：实际参数，函数调用时程序员传递的参数就是实参</li>
</ul>
<h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><p><strong><code>函数名字(实参);</code></strong></p>
<h2 id="函数调用的过程"><a href="#函数调用的过程" class="headerlink" title="函数调用的过程"></a>函数调用的过程</h2><p>当你调用一个函数的时候，操作系统会帮你把这个函数入栈(压栈)<br>当函数调用结束的时候，函数会被自动出栈(弹栈)</p>
<h3 id="入栈-压栈"><a href="#入栈-压栈" class="headerlink" title="入栈(压栈)"></a>入栈(压栈)</h3><p>把局部变量/函数的入口地址存放到栈空间的栈顶</p>
<h3 id="出栈-弹栈"><a href="#出栈-弹栈" class="headerlink" title="出栈(弹栈)"></a>出栈(弹栈)</h3><p>把局部变量/函数的入口地址从栈空间的栈顶自动释放掉</p>
<h3 id="函数的入口地址"><a href="#函数的入口地址" class="headerlink" title="函数的入口地址"></a>函数的入口地址</h3><p>函数名就是个指针，就代表该函数在计算机中的地址(入口地址)</p>
<h2 id="实参和形参"><a href="#实参和形参" class="headerlink" title="实参和形参"></a>实参和形参</h2><ul>
<li>无参传参</li>
</ul>
<blockquote>
<p>其实就是传入void类型的参数</p>
</blockquote>
<ul>
<li>传值传参</li>
</ul>
<blockquote>
<p>实参把自己的值拷贝一份给形参，只要函数的形参写成普通变量(非指针)，那就是传值</p>
</blockquote>
<ul>
<li>传址传参</li>
</ul>
<blockquote>
<p>实参把自己的地址赋值给形参，只要函数的形参写成指针，那就是传地址</p>
</blockquote>
<ul>
<li>实参和形参拥有各自独立的地址空间</li>
<li>实参和形参可以同名</li>
<li>任何数组作为函数的形参，sizeof()求大小都是当成指针来求大小</li>
</ul>
<h2 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h2><ul>
<li>没有返回值 void</li>
</ul>
<p>要退出函数时直接写return</p>
<ul>
<li>返回普通变量类型</li>
</ul>
<p>要退出函数时return对应的值，编译器会把局部变量的值备份一份到寄存器中,返回的就是寄存器里面的备份值</p>
<blockquote>
<p>一般来说，如果函数的返回值类型是int，return 0表示函数正常退出，-1表示函数异常退出</p>
</blockquote>
<ul>
<li>返回指针</li>
</ul>
<blockquote>
<p>不可以返回局部变量的地址</p>
</blockquote>
<p>局部变量的作用域只是在定义它的函数中生效，当函数退出的时候，该局部变量的地址(栈空间)空间会被自动释放</p>
<h2 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h2><p>一个函数在执行的过程中，又再一次调用了该函数本身</p>
<p>一般栈空间只有数M，因此递归非常容易产生栈溢出，一定要保证初始化和退出条件的正确性。</p>
<h3 id="递归三要素"><a href="#递归三要素" class="headerlink" title="递归三要素"></a>递归三要素</h3><ol>
<li>确定递归形式参数</li>
<li>确定终止条件</li>
<li>确定求值逻辑</li>
</ol>
<h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><p>当函数代码量很小，并且需要反复使用的时候，就可以选择加上<code>inline</code>关键字定义成内联</p>
<p>当gcc无法识别内联函数的关键字时，可以尝试在编译时使用<code>-fgnu89-inline</code> 参数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> 函数的返回值  函数名(形参)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>解决函数调用时入栈和出栈的时间耗费，对于经常要使用的，短小的代码适合定义成内联函数</p>
</blockquote>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>编译器会在调用的位置直接把内联函数的源码展开</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>节约了函数调用入栈出栈的时间耗费，内联函数用内联代码替换函数调用，内联函数体的代码不能过长，因为内联函数省去调用函数的时间是以代码膨胀为代价的，内联函数不能包含循环语句，因为执行循环语句要比调用函数的开销大</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>增加主程序的长度，增加了主函数占用的内存，耗费了比较多的内存</p>
<h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><p>将函数作为参数交给适合触发该函数的函数，这个参数函数就称为回调函数。</p>
<h2 id="变参函数"><a href="#变参函数" class="headerlink" title="变参函数"></a>变参函数</h2><p>一个函数的形参类型，个数不确定，这种函数就是变参函数</p>
<p><code>...</code> 用来来省略参数的类型和个数</p>
<h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>第一个参数必须是确定的</p>
<p>参数从右到左依次进栈，由前面确定的参数回溯出后面的变参(例如：printf的第一个参数格式输出符号回溯出后面的参数有几个，分别是什么类型)</p>
<blockquote>
<p>char和short会被自动提升为int，float会被提升为double</p>
</blockquote>
<h2 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h2><p><strong><code>int main(int argc,char **argv)</code></strong></p>
<p>主函数也是一个参数，在运行程序的时候，空格后跟着的字符串作为主函数的参数传入</p>
<ul>
<li>参数 argc 参数个数  argv 参数字符串组</li>
</ul>
<p>如果传入的是数字，这时候就需要将数字字符串转换成整型数字，<br><code>int atoi(const char *nptr);</code></p>
<p>将字符串转换成数字，需要导入<code>#include &lt;stdlib.h&gt;</code></p>
<ul>
<li>参数：nptr –》你要转换的字符串</li>
<li>返回值：转换后的整数</li>
</ul>
<h2 id="指针函数"><a href="#指针函数" class="headerlink" title="指针函数"></a>指针函数</h2><p>只要一个函数的返回值是指针，那么这个函数就叫做指针函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *<span class="title function_">p</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span>;   <span class="comment">// 指针函数</span></span><br><span class="line"><span class="comment">//返回函数指针: 返回值类型  (*函数名字(形参))(形参)</span></span><br><span class="line"><span class="comment">//返回数组指针: 数组类型  (*函数名字(形参))[数组元素个数]</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="结构体-1"><a href="#结构体-1" class="headerlink" title="结构体"></a>结构体</h1><p>结构体是一种复合数据类型</p>
<h2 id="结构体定义"><a href="#结构体定义" class="headerlink" title="结构体定义"></a>结构体定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> (结构体名)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="comment">// 数据类型...</span></span><br><span class="line">&#125;(别名);</span><br></pre></td></tr></table></figure>

<ul>
<li>不加结构体名则为匿名结构体</li>
</ul>
<h2 id="结构体使用"><a href="#结构体使用" class="headerlink" title="结构体使用"></a>结构体使用</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在定义前加上typedef </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> name[<span class="number">10</span>]; <span class="comment">//姓名</span></span><br><span class="line">&#125;stu; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">stu1</span>;</span></span><br><span class="line">stu stu2;  <span class="comment">//等价于struct student stu2;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给匿名结构体类型取别名stu，结构体指针类型取别名stup</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>  </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> name[<span class="number">10</span>]; <span class="comment">//姓名</span></span><br><span class="line">&#125;stu,*stup;</span><br><span class="line">stu stu1;  <span class="comment">//定义了一个学生结构体变量叫做stu1</span></span><br><span class="line">stup p;   <span class="comment">//定义了一个学生结构体指针叫做p</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义结构体时，定义一个结构体变量stu并初始化stu里的元素值</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span>  </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> name[<span class="number">10</span>]; <span class="comment">//姓名</span></span><br><span class="line">  <span class="type">int</span> age; <span class="comment">//年龄</span></span><br><span class="line">  <span class="type">float</span> score; <span class="comment">//分数</span></span><br><span class="line">&#125;stu=&#123;<span class="string">&quot;zhangsan&quot;</span>,<span class="number">18</span>,<span class="number">65.5</span>&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>结构体中不能直接定义函数，但是可以声明函数指针，给函数指针赋值一个函数即可通过结构体调用结构体中定义的函数函数赋值的函数</li>
</ul>
<h2 id="结构体赋值与初始化"><a href="#结构体赋值与初始化" class="headerlink" title="结构体赋值与初始化"></a>结构体赋值与初始化</h2><ul>
<li>直接赋值</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">structstudent stu1=&#123;<span class="string">&quot;zhangsan&quot;</span>,<span class="number">18</span>,<span class="number">56.9</span>&#125;;     </span><br></pre></td></tr></table></figure>

<ul>
<li>延迟赋值</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">stu1</span>;</span></span><br><span class="line"><span class="built_in">strcpy</span>(stu1.name,<span class="string">&quot;张三&quot;</span>);  <span class="comment">//char数组不能直接赋值字符串 stu1.name=&quot;张三&quot;;是错误的</span></span><br><span class="line">stu1.age=<span class="number">19</span>;</span><br><span class="line">stu1.score=<span class="number">85.5</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>命名赋值</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">stu1</span>=</span>&#123;</span><br><span class="line">   .score=<span class="number">56</span>,</span><br><span class="line">   .age=<span class="number">15</span>,</span><br><span class="line">   .name=<span class="string">&quot;李四&quot;</span></span><br><span class="line">&#125;;      </span><br></pre></td></tr></table></figure>

<blockquote>
<p>还可以部分初始化，十分灵活</p>
</blockquote>
<ul>
<li>结构体赋值</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">stu2</span>;</span></span><br><span class="line">stu2=stu1;</span><br></pre></td></tr></table></figure>

<h2 id="结构体运算"><a href="#结构体运算" class="headerlink" title="结构体运算"></a>结构体运算</h2><p><code>.</code> 直接成员运算符</p>
<p>调用普通结构体里面的成员</p>
<p><code>-&gt;</code> 间接成员运算符</p>
<p>调用结构体指针里面的成员</p>
<p><code>sizeof()</code> 结构体大小</p>
<p>结构体的存储需要满足字节对齐，如果你的操作系统是64位系统：</p>
<blockquote>
<p>找到结构体中类型最大的成员，如果类型最大的成员&gt;=8字节，整个结构体依照8字节对齐，如果类型最大的成员&lt;8字节，整个结构体依照类型最大的成员对齐</p>
</blockquote>
<h3 id="位域"><a href="#位域" class="headerlink" title="位域"></a>位域</h3><p>有些信息在存储时，并不需要占用一个完整的字节， 而只需占几个或一个二进制位。例如在存放一个开关量时，只有0和1 两种状态， 用一位二进位即可。为了节省存储空间，并使处理简便，Ｃ语言又提供了一种数据结构，称为“位域”或“位段”。所谓“位域”是把一个字节中的二进位划分为几个不同的区域， 并说明每个区域的位数。每个域有一个域名，允许在程序中按域名进行操作。 这样就可以把几个不同的对象用一个字节的二进制位域来表示。</p>
<h1 id="共用体-1"><a href="#共用体-1" class="headerlink" title="共用体"></a>共用体</h1><p>联合体中所有的成员共用同一块内存区域，联合体的大小由最大的成员大小来决定，也要满足字节对齐</p>
<h2 id="共用体的定义"><a href="#共用体的定义" class="headerlink" title="共用体的定义"></a>共用体的定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> 共用体名</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">//成员;</span></span><br><span class="line">&#125;(别名);</span><br></pre></td></tr></table></figure>

<h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><p>表示变量的作用范围</p>
<ul>
<li>如果全局变量跟局部变量同名，此时局部变量会隐藏全局变量，导致全局变量不可见</li>
</ul>
<h2 id="全局作用域-文件作用域"><a href="#全局作用域-文件作用域" class="headerlink" title="全局作用域(文件作用域)"></a>全局作用域(文件作用域)</h2><p>在所有函数的外面定义的变量就是全局变量</p>
<ul>
<li>全局变量可以被所有的函数共享</li>
<li>实际开发中，全局变量往往用来在不同的函数之间传递信息的(共享信息)</li>
<li>全局变量没有初始化，默认都是0</li>
</ul>
<h2 id="局部作用域-代码块作用域"><a href="#局部作用域-代码块作用域" class="headerlink" title="局部作用域(代码块作用域)"></a>局部作用域(代码块作用域)</h2><p>在函数里面定义(包括形参)的变量，或者在for循环里面定义的就是局部变量</p>
<ul>
<li>局部变量只可以在定义它的那个函数范围内使用</li>
<li>局部变量没有初始化，默认是垃圾数</li>
</ul>
<h1 id="链接性"><a href="#链接性" class="headerlink" title="链接性"></a>链接性</h1><p>变量能否在不同的文件中共享</p>
<h2 id="外部链接性"><a href="#外部链接性" class="headerlink" title="外部链接性"></a>外部链接性</h2><p>全局变量具备外部链接性</p>
<ul>
<li>全局变量可以在定义它的.c文件中使用，也可以在其它的.c文件中使用</li>
</ul>
<h2 id="内部链接性"><a href="#内部链接性" class="headerlink" title="内部链接性"></a>内部链接性</h2><p>用static修饰的静态全局变量具备内部链接性(extern staic const define typedef)</p>
<ul>
<li>变量只能在定义它的.c文件中使用，其它文件中不能使用</li>
</ul>
<h2 id="无链接性"><a href="#无链接性" class="headerlink" title="无链接性"></a>无链接性</h2><p>局部变量是无链接性,局部变量只能在定义的函数里面使用</p>
<h1 id="存储持续性"><a href="#存储持续性" class="headerlink" title="存储持续性"></a>存储持续性</h1><p>描述变量的生命周期</p>
<ul>
<li>自动存储</li>
</ul>
<p>变量从定义的位置开始，到函数结束自动释放（局部变量就是自动存储）</p>
<ul>
<li>静态存储</li>
</ul>
<p>只要是static修饰的变量都是静态存储，全局变量也是静态存储，变量从定义的位置开始，到整个程序结束才释放</p>
<ul>
<li>动态存储</li>
</ul>
<p>使用堆空间,只要使用malloc calloc  realloc分配的地址空间，全部都是动态存储, 使用的时候要申请分配，使用完毕需要主动free释放</p>
<h1 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h1><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><ul>
<li>static修饰全局变量</li>
</ul>
<p>改变全局变量的链接性，全局变量的链接性会从外部链接变成内部链接，此时这个全局变量只能在定义它的.c文件中使用，其它.c文件不可以使用</p>
<ul>
<li>static修饰局部变量</li>
</ul>
<p>表示该局部变量只能被初始化一次，static修饰的局部变量存放在数据段中<br>普通的局部变量存放在栈空间</p>
<ul>
<li>static修饰函数</li>
</ul>
<p>普通函数具备外部链接性，static修饰的函数具备内部链接性,只能在定义它的.c文件中使用</p>
<h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><ul>
<li>修饰普通变量</li>
</ul>
<p>标记为常量，常量是只读的(可以访问,不能修改)</p>
<ul>
<li>修饰指针</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">99</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p=&amp;a;  <span class="comment">//表示指针p不可以修改a的内容</span></span><br><span class="line"><span class="type">int</span> <span class="type">const</span> *p=&amp;a;  <span class="comment">//第一种和第二种是等价的</span></span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> p=&amp;a;  <span class="comment">//p指向a以后，后面就不可以再去指向其他变量的地址</span></span><br><span class="line"><span class="type">int</span> <span class="type">const</span> * <span class="type">const</span> p=&amp;a; <span class="comment">//p既不能修改指向的变量，也不能指向其他变量的地址</span></span><br></pre></td></tr></table></figure>

<h2 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h2><ul>
<li>声明外部全局变量</li>
</ul>
<p>如果当前文件需要使用在别的.c文件中定义的全局变量(非静态)，用extern声明即可</p>
<ul>
<li>声明外部函数</li>
</ul>
<p>如果当前文件需要使用在别的.c文件中定义的函数(非静态)，用extern声明即可</p>
<h2 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h2><p>给变量类型取别名</p>
<p><strong><code>typedef 基本数据类型  新的别名;</code></strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> u32;  <span class="comment">// 给基本数据类型取别名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> * charp; <span class="comment">// 给指针取别名(用的比较多)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span><span class="params">(*funp)</span><span class="params">(<span class="type">int</span>)</span>;  <span class="comment">//给int(*)(int)函数指针，取了别名，叫做funp</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> a[<span class="number">10</span>]; <span class="comment">//给int[10]这种类型的数组，取了别名，叫做a</span></span><br><span class="line"><span class="comment">// 给结构体取别名</span></span><br></pre></td></tr></table></figure>

<h3 id="定义可移植数据类型"><a href="#定义可移植数据类型" class="headerlink" title="定义可移植数据类型"></a>定义可移植数据类型</h3><p>同样的代码，编译运行的时候，不同的系统可能会出现数据越界问题</p>
<p>解决方法：用别名来定义数据，需要的时候直接修改别名对应的数据类型即可</p>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>修饰易变的变量，告诉编译器这个变量的值短时间内会改变很多次，不要去优化该变量</p>
<p>一个定义为volatile的变量说明此变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份</p>
<h3 id="编译器优化的含义"><a href="#编译器优化的含义" class="headerlink" title="编译器优化的含义"></a>编译器优化的含义</h3><p>例如编译器会聪明地认为如果一个变量i赋值给了a，然后执行几行代码之后再赋值给b，那么编译器会认为a和b是相等的（过程中没有代码改变i的值），其实这是不完全对的，有些情况下虽然代码不能改变i的值，但是其他行为可以改变（例如i是一个寄存器变量或者端口数据）</p>
<h1 id="预处理编译"><a href="#预处理编译" class="headerlink" title="预处理编译"></a>预处理编译</h1><h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><p>用来包含其他头文件,函数的声明，全局变量，结构体，共用体，枚举的定义，内联函数等</p>
<p><code>#include &lt;头文件&gt;</code></p>
<h2 id="自定义头文件"><a href="#自定义头文件" class="headerlink" title="自定义头文件"></a>自定义头文件</h2><p><code>“”</code> 用于自定义的头文件，编译器默认会先从当前路径下寻找这个头文件，如果找不到，就去系统的环境变量中查找头文件，两个地方都找不到就报错(没有这个头文件)</p>
<p><code>&lt;&gt;</code> 通常用于系统提供的头文件，编译器默认去系统的环境变量中查找头文件</p>
<h2 id="解决头文件重复包含的问题"><a href="#解决头文件重复包含的问题" class="headerlink" title="解决头文件重复包含的问题"></a>解决头文件重复包含的问题</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span>  _头文件的名字_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  _头文件的名字_H</span></span><br><span class="line">	<span class="comment">//头文件里面的具体内容</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h2 id="宏定义define"><a href="#宏定义define" class="headerlink" title="宏定义define"></a>宏定义define</h2><p>用作字符的替换，一般写成大写</p>
<ul>
<li>普通宏定义 不带参数</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  PATH  <span class="string">&quot;/dev/fb0&quot;</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>宏函数 带参</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> max(a,b) a&gt;b?a:b;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>宏函数不是真正意义上的函数,宏函数没有入栈出栈的操作,普通函数需要入栈，出栈</p>
</blockquote>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol>
<li>每个单独的宏定义，都各自占一行</li>
<li>宏定义一行写不下，必须加上续行符</li>
<li>宏定义中的参数都是没有数据类型的</li>
<li>带参数的宏定义，参数用圆括号括起来</li>
</ol>
<h2 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h2><p>满足条件，编译器就会编译对应的代码，不满足，代码会被编译器忽略(相当于注释掉了代码)</p>
<ul>
<li>条件满足编译</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEFINE</span></span><br><span class="line">	<span class="comment">// CODE</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> OTHERDEFINE</span></span><br><span class="line">	 <span class="comment">// CODE</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span> OTHERDEFINE2</span></span><br><span class="line">	 <span class="comment">// CODE</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>条件不满足编译</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> DEFINE</span></span><br><span class="line">		 <span class="comment">// CODE</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br></pre></td></tr></table></figure>

<h1 id="程序编译"><a href="#程序编译" class="headerlink" title="程序编译"></a>程序编译</h1><h2 id="一键生成可执行文件"><a href="#一键生成可执行文件" class="headerlink" title="一键生成可执行文件"></a>一键生成可执行文件</h2><p><code>gcc program.c -o program</code></p>
<h2 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h2><p>展开预处理命令</p>
<p><code>gcc program.c -o program.i -E</code></p>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>生成汇编文件</p>
<p><code>gcc program.i -o program.s -S</code></p>
<h2 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h2><p>生成可重定位文件</p>
<p><code>gcc program.s -o program.o -c</code></p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>链接生成可执行文件</p>
<p><code>gcc program.o -o program</code></p>
 
      <!-- reward -->
      
      <div id="reword-out">
        <div id="reward-btn">
          Donate
        </div>
      </div>
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>Copyright： </strong>
          
          Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source.
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://elimos.cn/2022/07/05/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%A2%99/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2022/07/09/%E6%B5%85%E8%B0%88%E6%A0%A1%E5%9B%AD%E7%BD%91%E5%AE%BD%E5%B8%A6%E7%A0%B4%E8%A7%A3/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            浅谈校园网宽带破解
          
        </div>
      </a>
    
    
      <a href="/2022/07/02/%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E4%B8%8E%E7%B3%BB%E7%BB%9F%E9%9B%86%E6%88%90/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">网络应用开发与系统集成</div>
      </a>
    
  </nav>

  
   
    
    <script src="https://cdn.staticfile.org/twikoo/1.4.18/twikoo.all.min.js"></script>
    <div id="twikoo" class="twikoo"></div>
    <script>
        twikoo.init({
            envId: ""
        })
    </script>
 
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2022
        <i class="ri-heart-fill heart_icon"></i> Elimos
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="Elimos&#39;Home"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/photos">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.png">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.png">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->
 <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.staticfile.org/mathjax/2.7.7/MathJax.js"></script>
<script src="https://cdn.staticfile.org/mathjax/2.7.7/config/TeX-AMS-MML_HTMLorMML-full.js"></script>
<script>
  var ayerConfig = {
    mathjax: true,
  };
</script>

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->
 
<script src="/js/clickBoom2.js"></script>
 
<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->
 
<script src="/js/dz.js"></script>
 
<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>